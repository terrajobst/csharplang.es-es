---
ms.openlocfilehash: f238a711e710bbac7f5b7400fa938bd85dec00c6
ms.sourcegitcommit: 5278336b61519956240a6f7d83bcb4322019e032
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/10/2020
ms.locfileid: "79484145"
---
# <a name="support-for--and--on-tuple-types"></a><span data-ttu-id="a7f5d-101">Compatibilidad con = = y! = en tipos de tupla</span><span class="sxs-lookup"><span data-stu-id="a7f5d-101">Support for == and != on tuple types</span></span>

<span data-ttu-id="a7f5d-102">Permite expresiones `t1 == t2` en las que `t1` y `t2` son tipos de tupla que aceptan valores NULL de tupla o que aceptan valores NULL y los evalúan aproximadamente como `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (suponiendo `var temp1 = t1; var temp2 = t2;`).</span><span class="sxs-lookup"><span data-stu-id="a7f5d-102">Allow expressions `t1 == t2` where `t1` and `t2` are tuple or nullable tuple types of same cardinality, and evaluate them roughly as `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (assuming `var temp1 = t1; var temp2 = t2;`).</span></span>

<span data-ttu-id="a7f5d-103">Por el contrario, permitiría `t1 != t2` y la evaluaría como `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-103">Conversely it would allow `t1 != t2` and evaluate it as `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`.</span></span>

<span data-ttu-id="a7f5d-104">En el caso que acepta valores NULL, se usan comprobaciones adicionales para `temp1.HasValue` y `temp2.HasValue`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-104">In the nullable case, additional checks for `temp1.HasValue` and `temp2.HasValue` are used.</span></span> <span data-ttu-id="a7f5d-105">Por ejemplo, `nullableT1 == nullableT2` se evalúa como `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-105">For instance, `nullableT1 == nullableT2` evaluates as `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`.</span></span>

<span data-ttu-id="a7f5d-106">Cuando una comparación de elementos devuelve un resultado no bool (por ejemplo, cuando se utiliza un `operator ==` o `operator !=` definido por el usuario no bool, o en una comparación dinámica), ese resultado se convertirá en `bool` o se ejecutará a través de `operator true` o `operator false` para obtener una `bool`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-106">When an element-wise comparison returns a non-bool result (for instance, when a non-bool user-defined `operator ==` or `operator !=` is used, or in a dynamic comparison), then that result will be either converted to `bool` or run through `operator true` or `operator false` to get a `bool`.</span></span> <span data-ttu-id="a7f5d-107">La comparación de tupla siempre termina con la devolución de un `bool`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-107">The tuple comparison always ends up returning a `bool`.</span></span>

<span data-ttu-id="a7f5d-108">A partir C# de 7,2, este código produce un error (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), a menos que haya un `operator==`definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-108">As of C# 7.2, such code produces an error (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), unless there is a user-defined `operator==`.</span></span>

## <a name="details"></a><span data-ttu-id="a7f5d-109">Detalles</span><span class="sxs-lookup"><span data-stu-id="a7f5d-109">Details</span></span>

<span data-ttu-id="a7f5d-110">Al enlazar el operador `==` (o `!=`), las reglas existentes son: (1) caso dinámico, (2) resolución de sobrecarga y (3) producen un error.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-110">When binding the `==` (or `!=`) operator, the existing rules are: (1) dynamic case, (2) overload resolution, and (3) fail.</span></span>
<span data-ttu-id="a7f5d-111">Esta propuesta agrega un caso de tupla entre (1) y (2): si ambos operandos de un operador de comparación son tuplas (tienen tipos de tupla o son literales de tupla) y tienen una cardinalidad coincidente, la comparación se realiza a elemento.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-111">This proposal adds a tuple case between (1) and (2): if both operands of a comparison operator are tuples (have tuple types or are tuple literals) and have matching cardinality, then the comparison is performed element-wise.</span></span> <span data-ttu-id="a7f5d-112">Esta igualdad de tupla también se eleva en tuplas que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-112">This tuple equality is also lifted onto nullable tuples.</span></span>

<span data-ttu-id="a7f5d-113">Ambos operandos (y, en el caso de los literales de tupla, sus elementos) se evalúan en orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-113">Both operands (and, in the case of tuple literals, their elements) are evaluated in order from left to right.</span></span> <span data-ttu-id="a7f5d-114">A continuación, cada par de elementos se utiliza como operandos para enlazar el operador `==` (o `!=`), de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-114">Each pair of elements is then used as operands to bind the operator `==` (or `!=`), recursively.</span></span> <span data-ttu-id="a7f5d-115">Los elementos con el tipo en tiempo de compilación `dynamic` producen un error.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-115">Any elements with compile-time type `dynamic` cause an error.</span></span> <span data-ttu-id="a7f5d-116">Los resultados de esas comparaciones de elementos se usan como operandos en una cadena de operadores condicionales AND (or OR).</span><span class="sxs-lookup"><span data-stu-id="a7f5d-116">The results of those element-wise comparisons are used as operands in a chain of conditional AND (or OR) operators.</span></span>

<span data-ttu-id="a7f5d-117">Por ejemplo, en el contexto de `(int, (int, int)) t1, t2;`, `t1 == (1, (2, 3))` se evaluaría como `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-117">For instance, in the context of `(int, (int, int)) t1, t2;`, `t1 == (1, (2, 3))` would evaluate as `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`.</span></span>

<span data-ttu-id="a7f5d-118">Cuando se usa un literal de tupla como operando (en cualquiera de los dos lados), recibe un tipo de tupla convertido formado por las conversiones de elementos que se introducen al enlazar el operador `==` (o `!=`).</span><span class="sxs-lookup"><span data-stu-id="a7f5d-118">When a tuple literal is used as operand (on either side), it receives a converted tuple type formed by the element-wise conversions which are introduced when binding the operator `==` (or `!=`) element-wise.</span></span> 

<span data-ttu-id="a7f5d-119">Por ejemplo, en `(1L, 2, "hello") == (1, 2L, null)`, el tipo convertido para ambos literales de tupla es `(long, long, string)` y el segundo literal no tiene ningún tipo natural.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-119">For instance, in `(1L, 2, "hello") == (1, 2L, null)`, the converted type for both tuple literals is `(long, long, string)` and the second literal has no natural type.</span></span>


### <a name="deconstruction-and-conversions-to-tuple"></a><span data-ttu-id="a7f5d-120">Desconstrucción y conversiones a tupla</span><span class="sxs-lookup"><span data-stu-id="a7f5d-120">Deconstruction and conversions to tuple</span></span>
<span data-ttu-id="a7f5d-121">En `(a, b) == x`, el hecho de que `x` puede deconstruir en dos elementos no desempeña un rol.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-121">In `(a, b) == x`, the fact that `x` can deconstruct into two elements does not play a role.</span></span> <span data-ttu-id="a7f5d-122">Esto podría estar en una propuesta futura, aunque podría plantear preguntas sobre `x == y` (es una comparación simple o una comparación de elementos y, si así se usa la cardinalidad?).</span><span class="sxs-lookup"><span data-stu-id="a7f5d-122">That could conceivably be in a future proposal, although it would raise questions about `x == y` (is this a simple comparison or an element-wise comparison, and if so using what cardinality?).</span></span>
<span data-ttu-id="a7f5d-123">Del mismo modo, las conversiones a tupla no juegan ningún rol.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-123">Similarly, conversions to tuple play no role.</span></span>

### <a name="tuple-element-names"></a><span data-ttu-id="a7f5d-124">Nombres de elementos de tupla</span><span class="sxs-lookup"><span data-stu-id="a7f5d-124">Tuple element names</span></span>

<span data-ttu-id="a7f5d-125">Al convertir un literal de tupla, se advierte cuando se proporciona un nombre de elemento de tupla explícito en el literal, pero no coincide con el nombre de elemento de la tupla de destino.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-125">When converting a tuple literal, we warn when an explicit tuple element name was provided in the literal, but it doesn't match the target tuple element name.</span></span>
<span data-ttu-id="a7f5d-126">Usamos la misma regla en la comparación de tuplas, de modo que Supongamos `(int a, int b) t` se advierte de `d` en `t == (c, d: 0)`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-126">We use the same rule in tuple comparison, so that assuming `(int a, int b) t` we warn on `d` in `t == (c, d: 0)`.</span></span>

### <a name="non-bool-element-wise-comparison-results"></a><span data-ttu-id="a7f5d-127">Resultados de la comparación de elementos no booleanos</span><span class="sxs-lookup"><span data-stu-id="a7f5d-127">Non-bool element-wise comparison results</span></span>

<span data-ttu-id="a7f5d-128">Si una comparación de elementos es dinámica en una igualdad de tupla, usamos una invocación dinámica del operador `false` y niega eso para obtener un `bool` y continuar con comparaciones de elementos adicionales.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-128">If an element-wise comparison is dynamic in a tuple equality, we use a dynamic invocation of the operator `false` and negate that to get a `bool` and continue with further element-wise comparisons.</span></span> 

<span data-ttu-id="a7f5d-129">Si una comparación de elementos devuelve algún otro tipo que no sea bool en una igualdad de tupla, hay dos casos:</span><span class="sxs-lookup"><span data-stu-id="a7f5d-129">If an element-wise comparison returns some other non-bool type in a tuple equality, there are two cases:</span></span>
- <span data-ttu-id="a7f5d-130">Si el tipo no bool se convierte en `bool`, se aplica esa conversión.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-130">if the non-bool type converts to `bool`, we apply that conversion,</span></span>
- <span data-ttu-id="a7f5d-131">Si no hay tal conversión, pero el tipo tiene un operador `false`, lo usaremos y negará el resultado.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-131">if there is no such conversion, but the type has an operator `false`, we'll use that and negate the result.</span></span>

<span data-ttu-id="a7f5d-132">En una desigualdad de tupla, se aplican las mismas reglas excepto que usaremos el operador `true` (sin negación) en lugar del operador `false`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-132">In a tuple inequality, the same rules apply except that we'll use the operator `true` (without negation) instead of the operator `false`.</span></span>

<span data-ttu-id="a7f5d-133">Estas reglas son similares a las reglas implicadas para usar un tipo que no sea bool en una instrucción `if` y otros contextos existentes.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-133">Those rules are similar to the rules involved for using a non-bool type in an `if` statement and some other existing contexts.</span></span>

## <a name="evaluation-order-and-special-cases"></a><span data-ttu-id="a7f5d-134">Orden de evaluación y casos especiales</span><span class="sxs-lookup"><span data-stu-id="a7f5d-134">Evaluation order and special cases</span></span>
<span data-ttu-id="a7f5d-135">El valor del lado izquierdo se evalúa primero, después el valor del lado derecho, y, a continuación, las comparaciones de elementos de izquierda a derecha (incluidas las conversiones y con la salida temprana en función de las reglas existentes para los operadores condicionales y/o).</span><span class="sxs-lookup"><span data-stu-id="a7f5d-135">The left-hand-side value is evaluated first, then the right-hand-side value, then the element-wise comparisons from left to right (including conversions, and with early exit based on existing rules for conditional AND/OR operators).</span></span>

<span data-ttu-id="a7f5d-136">Por ejemplo, si hay una conversión del tipo `A` al tipo `B` y un método `(A, A) GetTuple()`, evaluar `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` significa:</span><span class="sxs-lookup"><span data-stu-id="a7f5d-136">For instance, if there is a conversion from type `A` to type `B` and a method `(A, A) GetTuple()`, evaluating `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` means:</span></span>
- `new A(1)`
- `new B(2)`
- `new B(3)`
- `new B(4)`
- `GetTuple()`
- <span data-ttu-id="a7f5d-137">a continuación, se evalúan las conversiones y comparaciones de elementos y la lógica condicional (convertir `new A(1)` al tipo `B`, compararlo con `new B(4)`, etc.).</span><span class="sxs-lookup"><span data-stu-id="a7f5d-137">then the element-wise conversions and comparisons and conditional logic is evaluated (convert `new A(1)` to type `B`, then compare it with `new B(4)`, and so on).</span></span>

### <a name="comparing-null-to-null"></a><span data-ttu-id="a7f5d-138">Comparar `null` con `null`</span><span class="sxs-lookup"><span data-stu-id="a7f5d-138">Comparing `null` to `null`</span></span>

<span data-ttu-id="a7f5d-139">Este es un caso especial de las comparaciones normales, que lleva a las comparaciones de tupla.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-139">This is a special case from regular comparisons, that carries over to tuple comparisons.</span></span> <span data-ttu-id="a7f5d-140">Se permite la comparación de `null == null` y los literales de `null` no obtienen ningún tipo.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-140">The `null == null` comparison is allowed, and the `null` literals do not get any type.</span></span>
<span data-ttu-id="a7f5d-141">En igualdad de tupla, esto significa que también se permite `(0, null) == (0, null)` y los literales de `null` y tupla no obtienen un tipo.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-141">In tuple equality, this means, `(0, null) == (0, null)` is also allowed and the `null` and tuple literals don't get a type either.</span></span>

### <a name="comparing-a-nullable-struct-to-null-without-operator"></a><span data-ttu-id="a7f5d-142">Comparar un struct que acepta valores NULL con `null` sin `operator==`</span><span class="sxs-lookup"><span data-stu-id="a7f5d-142">Comparing a nullable struct to `null` without `operator==`</span></span>

<span data-ttu-id="a7f5d-143">Este es otro caso especial de las comparaciones normales, que lleva a las comparaciones de tupla.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-143">This is another special case from regular comparisons, that carries over to tuple comparisons.</span></span>
<span data-ttu-id="a7f5d-144">Si tiene un `struct S` sin `operator==`, se permite la comparación de `(S?)x == null` y se interpreta como `((S?).x).HasValue`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-144">If you have a `struct S` without `operator==`, the `(S?)x == null` comparison is allowed, and it is interpreted as `((S?).x).HasValue`.</span></span>
<span data-ttu-id="a7f5d-145">En la igualdad de tupla, se aplica la misma regla, por lo que se permite `(0, (S?)x) == (0, null)`.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-145">In tuple equality, the same rule is applied, so `(0, (S?)x) == (0, null)` is allowed.</span></span>

## <a name="compatibility"></a><span data-ttu-id="a7f5d-146">Compatibilidad</span><span class="sxs-lookup"><span data-stu-id="a7f5d-146">Compatibility</span></span>

<span data-ttu-id="a7f5d-147">Si alguien escribe sus propios tipos de `ValueTuple` con una implementación del operador de comparación, se habrían elegido previamente por la resolución de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-147">If someone wrote their own `ValueTuple` types with  an implementation of the comparison operator, it would have previously been picked up by overload resolution.</span></span> <span data-ttu-id="a7f5d-148">Pero como el nuevo caso de tupla viene antes de la resolución de sobrecarga, se trataría este caso con la comparación de tupla en lugar de depender de la comparación definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="a7f5d-148">But since the new tuple case comes before overload resolution, we would handle this case with tuple comparison instead of relying on the user-defined comparison.</span></span>

----

<span data-ttu-id="a7f5d-149">Está relacionado con los [operadores relacionales y de prueba de tipos](../../spec/expressions.md#relational-and-type-testing-operators) relacionados con [#190](https://github.com/dotnet/csharplang/issues/190)</span><span class="sxs-lookup"><span data-stu-id="a7f5d-149">Relates to [relational and type testing operators](../../spec/expressions.md#relational-and-type-testing-operators) Relates to [#190](https://github.com/dotnet/csharplang/issues/190)</span></span>
