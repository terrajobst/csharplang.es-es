---
ms.openlocfilehash: ecdad8c863d0695bc901e4d96d9ca3decbc248eb
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/25/2019
ms.locfileid: "79483599"
---
# <a name="nullable-reference-types-in-c"></a><span data-ttu-id="ad924-101">Tipos de referencia que aceptan valores NULL enC#</span><span class="sxs-lookup"><span data-stu-id="ad924-101">Nullable reference types in C#</span></span> #

<span data-ttu-id="ad924-102">El objetivo de esta característica es:</span><span class="sxs-lookup"><span data-stu-id="ad924-102">The goal of this feature is to:</span></span>

* <span data-ttu-id="ad924-103">Permite a los desarrolladores expresar si una variable, un parámetro o un resultado de un tipo de referencia está pensado para ser null o no.</span><span class="sxs-lookup"><span data-stu-id="ad924-103">Allow developers to express whether a variable, parameter or result of a reference type is intended to be null or not.</span></span>
* <span data-ttu-id="ad924-104">Proporcionar advertencias cuando tales variables, parámetros y resultados no se usan según esa intención.</span><span class="sxs-lookup"><span data-stu-id="ad924-104">Provide warnings when such variables, parameters and results are not used according to that intent.</span></span>

## <a name="expression-of-intent"></a><span data-ttu-id="ad924-105">Expresión de intención</span><span class="sxs-lookup"><span data-stu-id="ad924-105">Expression of intent</span></span>

<span data-ttu-id="ad924-106">El lenguaje ya contiene la sintaxis de `T?` para los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="ad924-106">The language already contains the `T?` syntax for value types.</span></span> <span data-ttu-id="ad924-107">Es sencillo extender esta sintaxis a tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="ad924-107">It is straightforward to extend this syntax to reference types.</span></span>

<span data-ttu-id="ad924-108">Se supone que el intento de un tipo de referencia no adornado `T` es que no sea NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-108">It is assumed that the intent of an unadorned reference type `T` is for it to be non-null.</span></span>

## <a name="checking-of-nullable-references"></a><span data-ttu-id="ad924-109">Comprobando referencias que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="ad924-109">Checking of nullable references</span></span>

<span data-ttu-id="ad924-110">Un análisis de flujo realiza un seguimiento de las variables de referencia que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-110">A flow analysis tracks nullable reference variables.</span></span> <span data-ttu-id="ad924-111">Si el análisis considera que no sería null (por ejemplo, después de una comprobación o una asignación), su valor se considerará una referencia no NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-111">Where the analysis deems that they would not be null (e.g. after a check or an assignment), their value will be considered a non-null reference.</span></span>

<span data-ttu-id="ad924-112">Una referencia que acepta valores null también se puede tratar explícitamente como no NULL con el operador de `x!` postfijo (el operador "Dammit"), para cuando el análisis de flujo no pueda establecer una situación que no sea NULL y sepa que el desarrollador está allí.</span><span class="sxs-lookup"><span data-stu-id="ad924-112">A nullable reference can also explicitly be treated as non-null with the postfix `x!` operator (the "dammit" operator), for when flow analysis cannot establish a non-null situation that the developer knows is there.</span></span>

<span data-ttu-id="ad924-113">De lo contrario, se proporciona una advertencia si se desreferencia una referencia que acepta valores NULL o si se convierte en un tipo que no sea NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-113">Otherwise, a warning is given if a nullable reference is dereferenced, or is converted to a non-null type.</span></span>

<span data-ttu-id="ad924-114">Se proporciona una advertencia al convertir de `S[]` a `T?[]` y de `S?[]` a `T[]`.</span><span class="sxs-lookup"><span data-stu-id="ad924-114">A warning is given when converting from `S[]` to `T?[]` and from `S?[]` to `T[]`.</span></span>

<span data-ttu-id="ad924-115">Se proporciona una advertencia al convertir de `C<S>` a `C<T?>` excepto cuando el parámetro de tipo es covariante (`out`), y al convertir de `C<S?>` a `C<T>` excepto cuando el parámetro de tipo es contravariante (`in`).</span><span class="sxs-lookup"><span data-stu-id="ad924-115">A warning is given when converting from `C<S>` to `C<T?>` except when the type parameter is covariant (`out`), and when converting from `C<S?>` to `C<T>` except when the type parameter is contravariant (`in`).</span></span>

<span data-ttu-id="ad924-116">Se proporciona una advertencia en `C<T?>` si el parámetro de tipo tiene restricciones que no son NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-116">A warning is given on `C<T?>` if the type parameter has non-null constraints.</span></span> 

## <a name="checking-of-non-null-references"></a><span data-ttu-id="ad924-117">Comprobando referencias no nulas</span><span class="sxs-lookup"><span data-stu-id="ad924-117">Checking of non-null references</span></span>

<span data-ttu-id="ad924-118">Se proporciona una advertencia si un literal NULL se asigna a una variable que no es null o se pasa como un parámetro que no es NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-118">A warning is given if a null literal is assigned to a non-null variable or passed as a non-null parameter.</span></span>

<span data-ttu-id="ad924-119">También se proporciona una advertencia si un constructor no inicializa explícitamente los campos de referencia no NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-119">A warning is also given if a constructor does not explicitly initialize non-null reference fields.</span></span>

<span data-ttu-id="ad924-120">No se puede realizar un seguimiento adecuado de que se inicializan todos los elementos de una matriz de referencias no nulas.</span><span class="sxs-lookup"><span data-stu-id="ad924-120">We cannot adequately track that all elements of an array of non-null references are initialized.</span></span> <span data-ttu-id="ad924-121">Sin embargo, podríamos emitir una advertencia si no se asigna ningún elemento de una matriz recién creada antes de que la matriz se lea o se pase.</span><span class="sxs-lookup"><span data-stu-id="ad924-121">However, we could issue a warning if no element of a newly created array is assigned to before the array is read from or passed on.</span></span> <span data-ttu-id="ad924-122">Esto podría controlar el caso común sin ser demasiado ruidoso.</span><span class="sxs-lookup"><span data-stu-id="ad924-122">That might handle the common case without being too noisy.</span></span>

<span data-ttu-id="ad924-123">Necesitamos decidir si `default(T)` genera una advertencia o simplemente se trata como el tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="ad924-123">We need to decide whether `default(T)` generates a warning, or is simply treated as being of the type `T?`.</span></span>

## <a name="metadata-representation"></a><span data-ttu-id="ad924-124">Representación de metadatos</span><span class="sxs-lookup"><span data-stu-id="ad924-124">Metadata representation</span></span>

<span data-ttu-id="ad924-125">Los elementos gráficos de nulabilidad se deben representar en metadatos como atributos.</span><span class="sxs-lookup"><span data-stu-id="ad924-125">Nullability adornments should be represented in metadata as attributes.</span></span> <span data-ttu-id="ad924-126">Esto significa que los compiladores de nivel inferior lo ignorarán.</span><span class="sxs-lookup"><span data-stu-id="ad924-126">This means that downlevel compilers will ignore them.</span></span>

<span data-ttu-id="ad924-127">Necesitamos decidir si solo se incluyen las anotaciones que aceptan valores NULL, o si hay también alguna indicación de si el valor de "ON" no es null en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ad924-127">We need to decide if only nullable annotations are included, or there's also some indication of whether non-null was "on" in the assembly.</span></span>

## <a name="generics"></a><span data-ttu-id="ad924-128">Genéricos</span><span class="sxs-lookup"><span data-stu-id="ad924-128">Generics</span></span>

<span data-ttu-id="ad924-129">Si un parámetro de tipo `T` tiene restricciones que no aceptan valores NULL, se trata como un valor que no acepta valores NULL dentro de su ámbito.</span><span class="sxs-lookup"><span data-stu-id="ad924-129">If a type parameter `T` has non-nullable constraints, it is treated as non-nullable within its scope.</span></span>

<span data-ttu-id="ad924-130">Si un parámetro de tipo no está restringido o solo tiene restricciones que aceptan valores NULL, la situación es un poco más compleja: Esto significa que el argumento de tipo correspondiente podría admitir valores NULL o que no admita *valores NULL.*</span><span class="sxs-lookup"><span data-stu-id="ad924-130">If a type parameter is unconstrained or has only nullable constraints, the situation is a little more complex: this means that the corresponding type argument could be *either* nullable or non-nullable.</span></span> <span data-ttu-id="ad924-131">Lo más seguro que hacer en esa situación es tratar el *parámetro de tipo como valores* NULL y que no aceptan valores NULL, lo que permite recibir advertencias cuando se infringe cualquiera de ellos.</span><span class="sxs-lookup"><span data-stu-id="ad924-131">The safe thing to do in that situation is to treat the type parameter as *both* nullable and non-nullable, giving warnings when either is violated.</span></span> 

<span data-ttu-id="ad924-132">Merece la pena considerar si se deben permitir las restricciones de referencia explícitas que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-132">It is worth considering whether explicit nullable reference constraints should be allowed.</span></span> <span data-ttu-id="ad924-133">Tenga en cuenta, sin embargo, que no se puede evitar que los tipos de referencia que aceptan valores NULL sean restricciones de forma *implícita* en ciertos casos (restricciones heredadas).</span><span class="sxs-lookup"><span data-stu-id="ad924-133">Note, however, that we cannot avoid having nullable reference types *implicitly* be constraints in certain cases (inherited constraints).</span></span>

<span data-ttu-id="ad924-134">La restricción `class` no es NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-134">The `class` constraint is non-null.</span></span> <span data-ttu-id="ad924-135">Podemos considerar si `class?` debe ser una restricción válida que acepte valores NULL que indique "tipo de referencia que acepta valores NULL".</span><span class="sxs-lookup"><span data-stu-id="ad924-135">We can consider whether `class?` should be a valid nullable constraint denoting "nullable reference type".</span></span>

## <a name="type-inference"></a><span data-ttu-id="ad924-136">Inferencia de tipos</span><span class="sxs-lookup"><span data-stu-id="ad924-136">Type inference</span></span>

<span data-ttu-id="ad924-137">En la inferencia de tipos, si un tipo de contribución es un tipo de referencia que acepta valores NULL, el tipo resultante debe admitir valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-137">In type inference, if a contributing type is a nullable reference type, the resulting type should be nullable.</span></span> <span data-ttu-id="ad924-138">En otras palabras, se propaga la nulación.</span><span class="sxs-lookup"><span data-stu-id="ad924-138">In other words, nullness is propagated.</span></span>

<span data-ttu-id="ad924-139">Debemos tener en cuenta si el `null` literal como una expresión participante debe aportar null.</span><span class="sxs-lookup"><span data-stu-id="ad924-139">We should consider whether the `null` literal as a participating expression should contribute nullness.</span></span> <span data-ttu-id="ad924-140">En la actualidad: para los tipos de valor, conduce a un error, mientras que en los tipos de referencia el valor NULL se convierte correctamente en el tipo simple.</span><span class="sxs-lookup"><span data-stu-id="ad924-140">It doesn't today: for value types it leads to an error, whereas for reference types the null successfully converts to the plain type.</span></span> 

```csharp
string? n = "world";
var x = b ? "Hello" : n; // string?
var y = b ? "Hello" : null; // string? or error
var z = b ? 7 : null; // Error today, could be int?
```

## <a name="breaking-changes"></a><span data-ttu-id="ad924-141">Últimos cambios</span><span class="sxs-lookup"><span data-stu-id="ad924-141">Breaking changes</span></span>

<span data-ttu-id="ad924-142">Las advertencias que no son NULL son un cambio importante evidente en el código existente y deben ir acompañados de un mecanismo de participación.</span><span class="sxs-lookup"><span data-stu-id="ad924-142">Non-null warnings are an obvious breaking change on existing code, and should be accompanied with an opt-in mechanism.</span></span>

<span data-ttu-id="ad924-143">Menos obvio, las advertencias de tipos que aceptan valores NULL (como se describió anteriormente) son un cambio importante en el código existente en ciertos escenarios en los que la nulabilidad es implícita:</span><span class="sxs-lookup"><span data-stu-id="ad924-143">Less obviously, warnings from nullable types (as described above) are a breaking change on existing code in certain scenarios where the nullability is implicit:</span></span>

* <span data-ttu-id="ad924-144">Los parámetros de tipo sin restricciones se tratarán como Nullable implícitamente, por lo que asignarlos a `object` o tener acceso a, por ejemplo, `ToString` producirá advertencias.</span><span class="sxs-lookup"><span data-stu-id="ad924-144">Unconstrained type parameters will be treated as implicitly nullable, so assigning them to `object` or accessing e.g. `ToString` will yield warnings.</span></span>
* <span data-ttu-id="ad924-145">Si la inferencia de tipos infiere la nulidad de `null` expresiones, a veces el código existente producirá valores NULL en lugar de tipos que no aceptan valores NULL, lo que puede dar lugar a nuevas advertencias.</span><span class="sxs-lookup"><span data-stu-id="ad924-145">if type inference infers nullness from `null` expressions, then existing code will sometimes yield nullable rather than non-nullable types, which can lead to new warnings.</span></span>

<span data-ttu-id="ad924-146">Por lo tanto, las advertencias que aceptan valores null también deben ser opcionales</span><span class="sxs-lookup"><span data-stu-id="ad924-146">So nullable warnings also need to be optional</span></span>

<span data-ttu-id="ad924-147">Por último, la adición de anotaciones a una API existente será un cambio importante para los usuarios que hayan participado en las advertencias al actualizar la biblioteca.</span><span class="sxs-lookup"><span data-stu-id="ad924-147">Finally, adding annotations to an existing API will be a breaking change to users who have opted in to warnings, when they upgrade the library.</span></span> <span data-ttu-id="ad924-148">Esto también merece la posibilidad de participar o no. "Quiero correcciones de errores, pero no estoy listo para tratar con sus nuevas anotaciones"</span><span class="sxs-lookup"><span data-stu-id="ad924-148">This, too, merits the ability to opt in or out. "I want the bug fixes, but I am not ready to deal with their new annotations"</span></span>

<span data-ttu-id="ad924-149">En Resumen, debe ser capaz de participar o no de:</span><span class="sxs-lookup"><span data-stu-id="ad924-149">In summary, you need to be able to opt in/out of:</span></span>
* <span data-ttu-id="ad924-150">Advertencias que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="ad924-150">Nullable warnings</span></span>
* <span data-ttu-id="ad924-151">Advertencias no nulas</span><span class="sxs-lookup"><span data-stu-id="ad924-151">Non-null warnings</span></span>
* <span data-ttu-id="ad924-152">Advertencias de anotaciones en otros archivos</span><span class="sxs-lookup"><span data-stu-id="ad924-152">Warnings from annotations in other files</span></span>

<span data-ttu-id="ad924-153">La granularidad de la participación sugiere un modelo similar a un analizador, en el que el usuario puede elegir y deshabilitar swaths de código con las directivas pragma y los niveles de gravedad.</span><span class="sxs-lookup"><span data-stu-id="ad924-153">The granularity of the opt-in suggests an analyzer-like model, where swaths of code can opt in and out with pragmas and severity levels can be chosen by the user.</span></span> <span data-ttu-id="ad924-154">Además, las opciones por biblioteca ("omitir las anotaciones de JSON.NET hasta que esté listo para tratar con el descenso") pueden expresarse en el código como atributos.</span><span class="sxs-lookup"><span data-stu-id="ad924-154">Additionally, per-library options ("ignore the annotations from JSON.NET until I'm ready to deal with the fall out") may be expressible in code as attributes.</span></span>

<span data-ttu-id="ad924-155">El diseño de la experiencia de participación o transición es fundamental para el éxito y la utilidad de esta característica.</span><span class="sxs-lookup"><span data-stu-id="ad924-155">The design of the opt-in/transition experience is crucial to the success and usefulness of this feature.</span></span> <span data-ttu-id="ad924-156">Debemos asegurarnos de que:</span><span class="sxs-lookup"><span data-stu-id="ad924-156">We need to make sure that:</span></span>

* <span data-ttu-id="ad924-157">Los usuarios pueden adoptar la comprobación de la nulabilidad gradualmente como deseen</span><span class="sxs-lookup"><span data-stu-id="ad924-157">Users can adopt nullability checking gradually as they want to</span></span>
* <span data-ttu-id="ad924-158">Los autores de bibliotecas pueden agregar anotaciones de nulabilidad sin miedo a los clientes de la interrupción</span><span class="sxs-lookup"><span data-stu-id="ad924-158">Library authors can add nullability annotations without fear of breaking customers</span></span>
* <span data-ttu-id="ad924-159">A pesar de esto, no hay una idea de la "pesadilla de configuración".</span><span class="sxs-lookup"><span data-stu-id="ad924-159">Despite these, there is not a sense of "configuration nightmare"</span></span>

## <a name="tweaks"></a><span data-ttu-id="ad924-160">Ajustes</span><span class="sxs-lookup"><span data-stu-id="ad924-160">Tweaks</span></span>

<span data-ttu-id="ad924-161">Podríamos considerar no usar las anotaciones de `?` en variables locales, sino que solo observa si se usan de acuerdo con lo que se les asigna.</span><span class="sxs-lookup"><span data-stu-id="ad924-161">We could consider not using the `?` annotations on locals, but just observing whether they are used in accordance with what gets assigned to them.</span></span> <span data-ttu-id="ad924-162">No me gusta esto; Creo que deberíamos permitir que los usuarios expresen su intención.</span><span class="sxs-lookup"><span data-stu-id="ad924-162">I don't favor this; I think we should uniformly let people express their intent.</span></span>

<span data-ttu-id="ad924-163">Podríamos considerar una `T! x` abreviada en los parámetros, que genera automáticamente una comprobación de NULL en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ad924-163">We could consider a shorthand `T! x` on parameters, that auto-generates a runtime null check.</span></span>

<span data-ttu-id="ad924-164">Algunos patrones de tipos genéricos, como `FirstOrDefault` o `TryGet`, tienen un comportamiento ligeramente extraño con argumentos de tipo que no aceptan valores NULL, ya que producen explícitamente valores predeterminados en determinadas situaciones.</span><span class="sxs-lookup"><span data-stu-id="ad924-164">Certain patterns on generic types, such as `FirstOrDefault` or `TryGet`, have slightly weird behavior with non-nullable type arguments, because they explicitly yield default values in certain situations.</span></span> <span data-ttu-id="ad924-165">Podríamos intentar maticar el sistema de tipos para acomodarlos mejor.</span><span class="sxs-lookup"><span data-stu-id="ad924-165">We could try to nuance the type system to accommodate these better.</span></span> <span data-ttu-id="ad924-166">Por ejemplo, podríamos permitir `?` en parámetros de tipo sin restricciones, aunque el argumento de tipo ya podría aceptar valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-166">For instance, we could allow `?` on unconstrained type parameters, even though the type argument could already be nullable.</span></span> <span data-ttu-id="ad924-167">No dude en que merezca la pena, y conduce a la extrañaidad relacionada con la interacción con tipos de *valor* que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-167">I doubt that it is worth it, and it leads to weirdness related to interaction with nullable *value* types.</span></span> 

## <a name="nullable-value-types"></a><span data-ttu-id="ad924-168">Tipos de valor que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="ad924-168">Nullable value types</span></span>

<span data-ttu-id="ad924-169">Podríamos considerar adoptar también algunas de las semánticas anteriores para los tipos de valor que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-169">We could consider adopting some of the above semantics for nullable value types as well.</span></span>

<span data-ttu-id="ad924-170">Ya hemos mencionado la inferencia de tipos, donde podríamos deducir `int?` de `(7, null)`, en lugar de simplemente producir un error.</span><span class="sxs-lookup"><span data-stu-id="ad924-170">We already mentioned type inference, where we could infer `int?` from `(7, null)`, instead of just giving an error.</span></span>

<span data-ttu-id="ad924-171">Otra posibilidad es aplicar el análisis de flujo a tipos de valor que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ad924-171">Another opportunity is to apply the flow analysis to nullable value types.</span></span> <span data-ttu-id="ad924-172">Cuando se consideran no NULL, en realidad podríamos permitir el uso de como tipo que no acepta valores NULL de ciertas maneras (por ejemplo, acceso a miembros).</span><span class="sxs-lookup"><span data-stu-id="ad924-172">When they are deemed non-null, we could actually allow using as the non-nullable type in certain ways (e.g. member access).</span></span> <span data-ttu-id="ad924-173">Simplemente tenemos que tener cuidado de que se prefieran las cosas que *ya* puede realizar en un tipo de valor que acepta valores NULL, por motivos de compatibilidad con las copias de seguridad.</span><span class="sxs-lookup"><span data-stu-id="ad924-173">We just have to be careful that the things that you can *already* do on a nullable value type will be preferred, for back compat reasons.</span></span>
