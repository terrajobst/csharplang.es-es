---
ms.openlocfilehash: ff31585520c9090ad92893a930327112743c8e77
ms.sourcegitcommit: 892af9016b3317a8fae12d195014dc38ba51cf16
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/01/2019
ms.locfileid: "71704007"
---
# <a name="basic-concepts"></a><span data-ttu-id="c7b0f-101">Conceptos básicos</span><span class="sxs-lookup"><span data-stu-id="c7b0f-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="c7b0f-102">Inicio de la aplicación</span><span class="sxs-lookup"><span data-stu-id="c7b0f-102">Application Startup</span></span>

<span data-ttu-id="c7b0f-103">Un ensamblado que tiene un ***punto de entrada*** se denomina ***aplicación***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="c7b0f-104">Cuando se ejecuta una aplicación, se crea un nuevo ***dominio de aplicación*** .</span><span class="sxs-lookup"><span data-stu-id="c7b0f-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="c7b0f-105">Puede haber varias instancias diferentes de una aplicación en el mismo equipo al mismo tiempo, y cada una tiene su propio dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="c7b0f-106">Un dominio de aplicación permite el aislamiento de aplicaciones actuando como un contenedor para el estado de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="c7b0f-107">Un dominio de aplicación actúa como contenedor y límite para los tipos definidos en la aplicación y las bibliotecas de clases que usa.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="c7b0f-108">Los tipos que se cargan en un dominio de aplicación son distintos del mismo tipo cargado en otro dominio de aplicación y las instancias de objetos no se comparten directamente entre los dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="c7b0f-109">Por ejemplo, cada dominio de aplicación tiene su propia copia de variables estáticas para estos tipos, y un constructor estático para un tipo se ejecuta como máximo una vez por dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="c7b0f-110">Las implementaciones son gratuitas para proporcionar directivas específicas de implementación o mecanismos para la creación y destrucción de dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="c7b0f-111">El inicio de la ***aplicación*** se produce cuando el entorno de ejecución llama a un método designado, al que se hace referencia como punto de entrada de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="c7b0f-112">Este método de punto de entrada siempre se denomina `Main`y puede tener una de las firmas siguientes:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="c7b0f-113">Como se muestra, el punto de entrada puede devolver opcionalmente un valor `int`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="c7b0f-114">Este valor devuelto se usa en la finalización de la aplicación ([finalización](basic-concepts.md#application-termination)de la aplicación).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="c7b0f-115">El punto de entrada puede tener opcionalmente un parámetro formal.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="c7b0f-116">El parámetro puede tener cualquier nombre, pero el tipo del parámetro debe ser `string[]`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="c7b0f-117">Si el parámetro formal está presente, el entorno de ejecución crea y pasa un argumento `string[]` que contiene los argumentos de la línea de comandos que se especificaron al iniciarse la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="c7b0f-118">El argumento `string[]` nunca es null, pero puede tener una longitud de cero si no se especificó ningún argumento de línea de comandos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="c7b0f-119">Puesto C# que admite la sobrecarga de métodos, una clase o struct puede contener varias definiciones de algún método, siempre que cada una tenga una firma diferente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="c7b0f-120">Sin embargo, dentro de un único programa, ninguna clase o struct puede contener más de un método llamado `Main` cuya definición lo califica para que se use como punto de entrada de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="c7b0f-121">No obstante, se permiten otras versiones sobrecargadas de `Main`, siempre que tengan más de un parámetro o su único parámetro sea distinto del tipo `string[]`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="c7b0f-122">Una aplicación puede estar formada por varias clases o Structs.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="c7b0f-123">Es posible que más de una de estas clases o Structs contengan un método denominado `Main` cuya definición sea apta para su uso como punto de entrada de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="c7b0f-124">En tales casos, se debe usar un mecanismo externo (como una opción del compilador de línea de comandos) para seleccionar uno de estos métodos `Main` como punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="c7b0f-125">En C#, cada método se debe definir como miembro de una clase o struct.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="c7b0f-126">Normalmente, la accesibilidad declarada ([accesibilidad declarada](basic-concepts.md#declared-accessibility)) de un método viene determinada por los modificadores de acceso ([modificadores de acceso](classes.md#access-modifiers)) especificados en su declaración y, de igual forma, la accesibilidad declarada de un tipo viene determinada por los modificadores de acceso especificados en su declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="c7b0f-127">Para que se pueda llamar a un método dado de un tipo determinado, tanto el tipo como el miembro deben ser accesibles.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="c7b0f-128">Sin embargo, el punto de entrada de la aplicación es un caso especial.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="c7b0f-129">En concreto, el entorno de ejecución puede tener acceso al punto de entrada de la aplicación, independientemente de su accesibilidad declarada y sin tener en consideración la accesibilidad declarada de sus declaraciones de tipos envolventes.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="c7b0f-130">Es posible que el método de punto de entrada de la aplicación no esté en una declaración de clase genérica.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="c7b0f-131">En todos los demás aspectos, los métodos de punto de entrada se comportan como los que no son puntos de entrada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="c7b0f-132">Finalización de la aplicación</span><span class="sxs-lookup"><span data-stu-id="c7b0f-132">Application termination</span></span>

<span data-ttu-id="c7b0f-133">La ***finalización*** de la aplicación devuelve el control al entorno de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="c7b0f-134">Si el tipo de valor devuelto del método de ***punto de entrada*** de la aplicación es `int`, el valor devuelto actúa como el código de ***Estado de terminación***de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="c7b0f-135">El propósito de este código es permitir la comunicación de éxito o error en el entorno de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="c7b0f-136">Si el tipo de valor devuelto del método de punto de entrada es `void`, al llegar a la llave de cierre (`}`) que finaliza ese método, o al ejecutar una instrucción `return` que no tiene ninguna expresión, se genera un código de estado de finalización de `0`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="c7b0f-137">Antes de la finalización de una aplicación, se llama a los destructores para todos sus objetos que todavía no se han recolectado como elemento no utilizado, a menos que se haya suprimido dicha limpieza (por ejemplo, mediante una llamada al método de biblioteca `GC.SuppressFinalize`).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="c7b0f-138">Declaraciones</span><span class="sxs-lookup"><span data-stu-id="c7b0f-138">Declarations</span></span>

<span data-ttu-id="c7b0f-139">Las declaraciones de un C# programa definen los elementos constituyentes del programa.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="c7b0f-140">C#los programas se organizan mediante espacios de nombres ([espacios](namespaces.md)de nombres), que pueden contener declaraciones de tipos y declaraciones de espacio de nombres anidadas.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="c7b0f-141">Las declaraciones de tipos ([declaraciones de tipo](namespaces.md#type-declarations)) se utilizan para definir clases ([clases](classes.md)), Structs ([Structs](structs.md)), interfaces ([interfaces](interfaces.md)), enumeraciones ([enumeraciones](enums.md)) y delegados ([delegados](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="c7b0f-142">Los tipos de miembros permitidos en una declaración de tipo dependen del formulario de la declaración de tipos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="c7b0f-143">Por ejemplo, las declaraciones de clase pueden contener declaraciones de constantes ([constantes](classes.md#constants)). campos ([campos](classes.md#fields)), métodos ([métodos](classes.md#methods)), propiedades ([propiedades](classes.md#properties)), eventos ([eventos](classes.md#events)), indexadores ([indizadores](classes.md#indexers)), operadores ([operadores](classes.md#operators)), constructores de instancias ([constructores de instancias](classes.md#instance-constructors)), constructores estáticos ([constructores estáticos](classes.md#static-constructors)), destructores ([destructores](classes.md#destructors)) y tipos anidados ([tipos anidados](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="c7b0f-144">Una declaración define un nombre en el ***espacio de declaración*** al que pertenece la declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="c7b0f-145">A excepción de los miembros sobrecargados ([firmas y sobrecarga](basic-concepts.md#signatures-and-overloading)), es un error en tiempo de compilación tener dos o más declaraciones que introducen miembros con el mismo nombre en un espacio de declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="c7b0f-146">Nunca es posible que un espacio de declaración contenga distintos tipos de miembros con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="c7b0f-147">Por ejemplo, un espacio de declaración nunca puede contener un campo y un método con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="c7b0f-148">Hay varios tipos diferentes de espacios de declaración, como se describe a continuación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="c7b0f-149">En todos los archivos de código fuente de un programa, *namespace_member_declaration*s sin *namespace_declaration* de inclusión son miembros de un único espacio de declaración combinado denominado ***espacio de declaración global***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="c7b0f-150">Dentro de todos los archivos de código fuente de un programa, *namespace_member_declaration*s dentro de *namespace_declaration*s que tienen el mismo nombre de espacio de nombres completo son miembros de un solo espacio de declaración combinado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="c7b0f-151">Cada declaración de clase, struct o interfaz crea un nuevo espacio de declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="c7b0f-152">Los nombres se introducen en este espacio de declaración a través de *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s o *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="c7b0f-153">A excepción de las declaraciones de constructor de instancia sobrecargadas y las declaraciones de constructor estático, una clase o struct no puede contener una declaración de miembro con el mismo nombre que la clase o la estructura.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="c7b0f-154">Una clase, estructura o interfaz permite la declaración de métodos sobrecargados e indexadores.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="c7b0f-155">Además, una clase o struct permite la declaración de constructores de instancia sobrecargados y operadores.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="c7b0f-156">Por ejemplo, una clase, un struct o una interfaz pueden contener varias declaraciones de método con el mismo nombre, siempre que estas declaraciones de método difieran en su firma ([firmas y sobrecarga](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="c7b0f-157">Tenga en cuenta que las clases base no contribuyen al espacio de declaración de una clase, y las interfaces base no contribuyen al espacio de declaración de una interfaz.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="c7b0f-158">Por lo tanto, una clase derivada o una interfaz pueden declarar un miembro con el mismo nombre que un miembro heredado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="c7b0f-159">Este miembro se dice que ***oculta*** el miembro heredado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="c7b0f-160">Cada declaración de delegado crea un nuevo espacio de declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="c7b0f-161">Los nombres se introducen en este espacio de declaración a través de parámetros formales (*fixed_parameter*s y *parameter_array*s) y *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="c7b0f-162">Cada declaración de enumeración crea un nuevo espacio de declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="c7b0f-163">Los nombres se introducen en este espacio de declaración a través de *enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="c7b0f-164">Cada declaración de método, declaración de indexador, declaración de operador, declaración de constructor de instancia y función anónima crea un nuevo espacio de declaración denominado ***espacio de declaración de variable local***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="c7b0f-165">Los nombres se introducen en este espacio de declaración a través de parámetros formales (*fixed_parameter*s y *parameter_array*s) y *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="c7b0f-166">El cuerpo del miembro de función o de la función anónima, si existe, se considera anidado dentro del espacio de declaración de la variable local.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="c7b0f-167">Es un error que un espacio de declaración de variable local y un espacio de declaración de variable local anidada contengan elementos con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="c7b0f-168">Por lo tanto, dentro de un espacio de declaración anidado no es posible declarar una variable o constante local con el mismo nombre que una variable o constante local en un espacio de declaración de inclusión.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="c7b0f-169">Es posible que dos espacios de declaración contengan elementos con el mismo nombre siempre y cuando ningún espacio de declaración contenga el otro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="c7b0f-170">Cada *bloque* o *switch_block* , así como una instrucción *for*, *foreach* y *using* , crea un espacio de declaración de variable local para las variables locales y las constantes locales.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="c7b0f-171">Los nombres se introducen en este espacio de declaración a través de *local_variable_declaration*s y *local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="c7b0f-172">Tenga en cuenta que los bloques que se producen como o dentro del cuerpo de un miembro de función o de una función anónima están anidados dentro del espacio de declaración de variable local declarado por esas funciones para sus parámetros.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="c7b0f-173">Por lo tanto, es un error tener, por ejemplo, un método con una variable local y un parámetro con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="c7b0f-174">Cada *bloque* o *switch_block* crea un espacio de declaración independiente para las etiquetas.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="c7b0f-175">Los nombres se introducen en este espacio de declaración a través de *labeled_statement*s y se hace referencia a los nombres a través de *goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="c7b0f-176">El ***espacio de declaración de etiqueta*** de un bloque incluye cualquier bloque anidado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="c7b0f-177">Por lo tanto, dentro de un bloque anidado no es posible declarar una etiqueta con el mismo nombre que una etiqueta en un bloque de inclusión.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="c7b0f-178">El orden textual en el que se declaran los nombres no suele ser significativo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="c7b0f-179">En concreto, el orden textual no es significativo para la declaración y el uso de espacios de nombres, constantes, métodos, propiedades, eventos, indizadores, operadores, constructores de instancias, destructores, constructores estáticos y tipos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="c7b0f-180">El orden de declaración es significativo de las siguientes maneras:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="c7b0f-181">El orden de declaración de las declaraciones de campo y las declaraciones de variables locales determina el orden en que se ejecutan sus inicializadores (si existen).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="c7b0f-182">Las variables locales deben definirse antes de que se usen ([ámbitos](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="c7b0f-183">El orden de declaración para las declaraciones de miembros de enumeración ([miembros de enumeración](enums.md#enum-members)) es importante cuando se omiten los valores de *constant_expression* .</span><span class="sxs-lookup"><span data-stu-id="c7b0f-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="c7b0f-184">El espacio de declaración de un espacio de nombres es "Open Terminated" y dos declaraciones de espacios de nombres con el mismo nombre completo contribuyen al mismo espacio de declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="c7b0f-185">Por ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="c7b0f-186">Las dos declaraciones de espacios de nombres anteriores contribuyen al mismo espacio de declaración; en este caso, se declaran dos clases con los nombres completos `Megacorp.Data.Customer` y `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="c7b0f-187">Dado que las dos declaraciones contribuyen al mismo espacio de declaración, habría producido un error en tiempo de compilación si cada una de ellas contenía una declaración de una clase con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="c7b0f-188">Tal y como se especificó anteriormente, el espacio de declaración de un bloque incluye cualquier bloque anidado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="c7b0f-189">Por lo tanto, en el ejemplo siguiente, los métodos `F` y `G` producen un error en tiempo de compilación porque el nombre `i` se declara en el bloque exterior y no se puede volver a declarar en el bloque interno.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="c7b0f-190">Sin embargo, los métodos `H` y `I` son válidos, ya que los dos `i`se declaran en bloques independientes no anidados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="c7b0f-191">Miembros</span><span class="sxs-lookup"><span data-stu-id="c7b0f-191">Members</span></span>

<span data-ttu-id="c7b0f-192">Los espacios de nombres y ***los***tipos tienen miembros.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="c7b0f-193">Los miembros de una entidad están disponibles con carácter general a través del uso de un nombre completo que empieza por una referencia a la entidad, seguido de un token "`.`", seguido del nombre del miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="c7b0f-194">Los miembros de un tipo se declaran en la declaración de tipos o se ***heredan*** de la clase base del tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="c7b0f-195">Cuando un tipo hereda de una clase base, todos los miembros de la clase base, excepto los constructores de instancia, destructores y constructores estáticos, se convierten en miembros del tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="c7b0f-196">La accesibilidad declarada de un miembro de clase base no controla si el miembro se hereda (la herencia se extiende a cualquier miembro que no sea un constructor de instancia, un constructor estático o un destructor).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="c7b0f-197">Sin embargo, es posible que no se pueda obtener acceso a un miembro heredado en un tipo derivado, ya sea debido a su accesibilidad declarada ([accesibilidad declarada](basic-concepts.md#declared-accessibility)) o porque está oculta por una declaración en el propio tipo ([ocultando a través](basic-concepts.md#hiding-through-inheritance)de la herencia).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="c7b0f-198">Miembros de espacio de nombres</span><span class="sxs-lookup"><span data-stu-id="c7b0f-198">Namespace members</span></span>

<span data-ttu-id="c7b0f-199">Los espacios de nombres y los tipos que no tienen ningún espacio de nombres envolvente son miembros del ***espacio de nombres global***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="c7b0f-200">Se corresponde directamente con los nombres declarados en el espacio de declaración global.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="c7b0f-201">Los espacios de nombres y los tipos declarados dentro de un espacio de nombres son miembros de ese espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="c7b0f-202">Esto corresponde directamente a los nombres declarados en el espacio de declaración del espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="c7b0f-203">Los espacios de nombres no tienen restricciones de acceso.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="c7b0f-204">No es posible declarar espacios de nombres privados, protegidos o internos, y los nombres de los espacios de nombres siempre son accesibles públicamente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="c7b0f-205">Miembros de struct</span><span class="sxs-lookup"><span data-stu-id="c7b0f-205">Struct members</span></span>

<span data-ttu-id="c7b0f-206">Los miembros de un struct son los miembros declarados en la estructura y los miembros heredados de la clase base directa de la estructura `System.ValueType` y la clase base indirecta `object`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="c7b0f-207">Los miembros de un tipo simple se corresponden directamente con los miembros del tipo de struct con alias del tipo simple:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="c7b0f-208">Los miembros de `sbyte` son los miembros del struct `System.SByte`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="c7b0f-209">Los miembros de `byte` son los miembros del struct `System.Byte`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="c7b0f-210">Los miembros de `short` son los miembros del struct `System.Int16`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="c7b0f-211">Los miembros de `ushort` son los miembros del struct `System.UInt16`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="c7b0f-212">Los miembros de `int` son los miembros del struct `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="c7b0f-213">Los miembros de `uint` son los miembros del struct `System.UInt32`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="c7b0f-214">Los miembros de `long` son los miembros del struct `System.Int64`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="c7b0f-215">Los miembros de `ulong` son los miembros del struct `System.UInt64`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="c7b0f-216">Los miembros de `char` son los miembros del struct `System.Char`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="c7b0f-217">Los miembros de `float` son los miembros del struct `System.Single`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="c7b0f-218">Los miembros de `double` son los miembros del struct `System.Double`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="c7b0f-219">Los miembros de `decimal` son los miembros del struct `System.Decimal`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="c7b0f-220">Los miembros de `bool` son los miembros del struct `System.Boolean`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="c7b0f-221">Miembros de enumeración</span><span class="sxs-lookup"><span data-stu-id="c7b0f-221">Enumeration members</span></span>

<span data-ttu-id="c7b0f-222">Los miembros de una enumeración son las constantes declaradas en la enumeración y los miembros heredados de la clase base directa de la enumeración `System.Enum` y las clases base indirectas `System.ValueType` y `object`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="c7b0f-223">Miembros de la clase</span><span class="sxs-lookup"><span data-stu-id="c7b0f-223">Class members</span></span>

<span data-ttu-id="c7b0f-224">Los miembros de una clase son los miembros declarados en la clase y los miembros heredados de la clase base (excepto para la clase `object` que no tiene ninguna clase base).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="c7b0f-225">Los miembros heredados de la clase base incluyen las constantes, campos, métodos, propiedades, eventos, indizadores, operadores y tipos de la clase base, pero no los constructores de instancias, destructores y constructores estáticos de la clase base.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="c7b0f-226">Los miembros de clase base se heredan sin tener en cuenta su accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="c7b0f-227">Una declaración de clase puede contener declaraciones de constantes, campos, métodos, propiedades, eventos, indizadores, operadores, constructores de instancias, destructores, constructores estáticos y tipos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="c7b0f-228">Los miembros de `object` y `string` corresponden directamente a los miembros de los tipos de clase a los que se les ha contorno:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="c7b0f-229">Los miembros de `object` son los miembros de la clase `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="c7b0f-230">Los miembros de `string` son los miembros de la clase `System.String`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="c7b0f-231">Miembros de interfaz</span><span class="sxs-lookup"><span data-stu-id="c7b0f-231">Interface members</span></span>

<span data-ttu-id="c7b0f-232">Los miembros de una interfaz son los miembros declarados en la interfaz y en todas las interfaces base de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="c7b0f-233">Los miembros de la clase `object` no son, estrictamente hablando, miembros de cualquier interfaz (miembros de la[interfaz](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="c7b0f-234">Sin embargo, los miembros de la clase `object` están disponibles a través de la búsqueda de miembros en cualquier tipo de interfaz ([búsqueda de miembros](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="c7b0f-235">Miembros de matriz</span><span class="sxs-lookup"><span data-stu-id="c7b0f-235">Array members</span></span>

<span data-ttu-id="c7b0f-236">Los miembros de una matriz son los miembros heredados de la clase `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="c7b0f-237">Miembros de delegado</span><span class="sxs-lookup"><span data-stu-id="c7b0f-237">Delegate members</span></span>

<span data-ttu-id="c7b0f-238">Los miembros de un delegado son los miembros heredados de la clase `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="c7b0f-239">Acceso a miembros</span><span class="sxs-lookup"><span data-stu-id="c7b0f-239">Member access</span></span>

<span data-ttu-id="c7b0f-240">Las declaraciones de miembros permiten el control sobre el acceso a miembros.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="c7b0f-241">La accesibilidad de un miembro se establece mediante la accesibilidad declarada ([accesibilidad declarada](basic-concepts.md#declared-accessibility)) del miembro combinado con la accesibilidad del tipo contenedor inmediato, si existe.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="c7b0f-242">Cuando se permite el acceso a un miembro determinado, se dice que el miembro es ***accesible***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="c7b0f-243">Por el contrario, cuando no se permite el acceso a un miembro determinado, se dice que el miembro no es ***accesible***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="c7b0f-244">Se permite el acceso a un miembro cuando la ubicación textual en la que tiene lugar el acceso se incluye en el dominio de accesibilidad ([dominios de accesibilidad](basic-concepts.md#accessibility-domains)) del miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="c7b0f-245">Accesibilidad declarada</span><span class="sxs-lookup"><span data-stu-id="c7b0f-245">Declared accessibility</span></span>

<span data-ttu-id="c7b0f-246">La ***accesibilidad declarada*** de un miembro puede ser una de las siguientes:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="c7b0f-247">Público, que se selecciona mediante la inclusión de un modificador `public` en la declaración de miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="c7b0f-248">El significado intuitivo de `public` es "acceso no limitado".</span><span class="sxs-lookup"><span data-stu-id="c7b0f-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="c7b0f-249">Protected, que se selecciona mediante la inclusión de un modificador `protected` en la declaración de miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="c7b0f-250">El significado intuitivo de `protected` es "acceso limitado a la clase contenedora o a los tipos derivados de la clase contenedora".</span><span class="sxs-lookup"><span data-stu-id="c7b0f-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="c7b0f-251">Internal, que se selecciona mediante la inclusión de un modificador `internal` en la declaración de miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="c7b0f-252">El significado intuitivo de `internal` es "acceso limitado a este programa".</span><span class="sxs-lookup"><span data-stu-id="c7b0f-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="c7b0f-253">Protected internal (es decir, Protected o Internal), que se selecciona mediante la inclusión de un `protected` y un modificador `internal` en la declaración de miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="c7b0f-254">El significado intuitivo de `protected internal` es "acceso limitado a este programa o tipos derivados de la clase contenedora".</span><span class="sxs-lookup"><span data-stu-id="c7b0f-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="c7b0f-255">Private, que se selecciona mediante la inclusión de un modificador `private` en la declaración de miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="c7b0f-256">El significado intuitivo de `private` es "acceso limitado al tipo contenedor".</span><span class="sxs-lookup"><span data-stu-id="c7b0f-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="c7b0f-257">Dependiendo del contexto en el que tenga lugar una declaración de miembro, solo se permiten determinados tipos de accesibilidad declarada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="c7b0f-258">Además, cuando una declaración de miembro no incluye modificadores de acceso, el contexto en el que se produce la declaración determina la accesibilidad declarada predeterminada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="c7b0f-259">Los espacios de nombres tienen implícitamente `public` la accesibilidad declarada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="c7b0f-260">No se permiten modificadores de acceso en las declaraciones de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="c7b0f-261">Los tipos declarados en unidades de compilación o espacios de nombres pueden tener `public` o `internal` la accesibilidad declarada y de forma predeterminada `internal` accesibilidad declarada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="c7b0f-262">Los miembros de clase pueden tener cualquiera de los cinco tipos de accesibilidad declarada y tienen como valor predeterminado `private` accesibilidad declarada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="c7b0f-263">(Tenga en cuenta que un tipo declarado como miembro de una clase puede tener cualquiera de los cinco tipos de accesibilidad declarada, mientras que un tipo declarado como miembro de un espacio de nombres solo puede tener `public` o `internal` la accesibilidad declarada).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="c7b0f-264">Los miembros de struct pueden tener `public`, `internal`o `private` la accesibilidad declarada y de forma predeterminada a `private` la accesibilidad declarada porque los Structs están sellados implícitamente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="c7b0f-265">Los miembros de estructura introducidos en un struct (es decir, no heredados por ese struct) no pueden tener `protected` o `protected internal` declaran la accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="c7b0f-266">(Tenga en cuenta que un tipo declarado como miembro de un struct puede tener `public`, `internal`o `private` accesibilidad declarada, mientras que un tipo declarado como miembro de un espacio de nombres solo puede tener `public` o `internal` accesibilidad declarada.)</span><span class="sxs-lookup"><span data-stu-id="c7b0f-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="c7b0f-267">Los miembros de interfaz tienen implícitamente `public` la accesibilidad declarada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="c7b0f-268">No se permiten modificadores de acceso en las declaraciones de miembros de interfaz.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="c7b0f-269">Los miembros de enumeración tienen implícitamente `public` la accesibilidad declarada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="c7b0f-270">No se permiten modificadores de acceso en las declaraciones de miembros de enumeración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="c7b0f-271">Dominios de accesibilidad</span><span class="sxs-lookup"><span data-stu-id="c7b0f-271">Accessibility domains</span></span>

<span data-ttu-id="c7b0f-272">El ***dominio de accesibilidad*** de un miembro se compone de las secciones (posiblemente disjuntos) del texto del programa en el que se permite el acceso al miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="c7b0f-273">A efectos de definir el dominio de accesibilidad de un miembro, se dice que un miembro es de ***nivel superior*** si no se declara dentro de un tipo, y se dice que un miembro está ***anidado*** si se declara dentro de otro tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="c7b0f-274">Además, el ***texto*** del programa de un programa se define como todo el texto del programa contenido en todos los archivos de código fuente del programa, y el texto del programa de un tipo se define como todo el texto del programa incluido en el *type_declaration*s de ese tipo (incluidos, posiblemente, los tipos que están anidados dentro del tipo).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="c7b0f-275">El dominio de accesibilidad de un tipo predefinido (como `object`, `int`o `double`) es ilimitado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="c7b0f-276">El dominio de accesibilidad de un tipo sin enlazar de nivel superior `T` ([tipos enlazados y sin enlazar](types.md#bound-and-unbound-types)) que se declara en un programa `P` se define de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="c7b0f-277">Si la accesibilidad declarada de `T` es `public`, el dominio de accesibilidad de `T` es el texto de programa de `P` y cualquier programa que haga referencia a `P`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="c7b0f-278">Si la accesibilidad declarada de `T` es `internal`, el dominio de accesibilidad de `T` es el texto de programa de `P`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="c7b0f-279">A partir de estas definiciones, sigue que el dominio de accesibilidad de un tipo sin enlazar de nivel superior siempre es al menos el texto del programa del programa en el que se declara ese tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="c7b0f-280">El dominio de accesibilidad de un tipo construido `T<A1, ..., An>` es la intersección del dominio de accesibilidad del tipo genérico sin enlazar `T` y los dominios de accesibilidad de los argumentos de tipo `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="c7b0f-281">El dominio de accesibilidad de un miembro anidado `M` declarados en un tipo `T` dentro de un programa `P` se define de la manera siguiente (teniendo en cuenta que el propio `M` puede ser un tipo):</span><span class="sxs-lookup"><span data-stu-id="c7b0f-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="c7b0f-282">Si la accesibilidad declarada de `M` es `public`, el dominio de accesibilidad de `M` es el dominio de accesibilidad de `T`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="c7b0f-283">Si la accesibilidad declarada de `M` es `protected internal`, permita que `D` sea la Unión del texto del programa de `P` y el texto del programa de cualquier tipo derivado de `T`, que se declara fuera de `P`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="c7b0f-284">El dominio de accesibilidad de `M` es la intersección del dominio de accesibilidad de `T` con `D`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="c7b0f-285">Si la accesibilidad declarada de `M` es `protected`, permita que `D` sea la Unión del texto del programa de `T` y el texto del programa de cualquier tipo derivado de `T`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="c7b0f-286">El dominio de accesibilidad de `M` es la intersección del dominio de accesibilidad de `T` con `D`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="c7b0f-287">Si la accesibilidad declarada de `M` es `internal`, el dominio de accesibilidad de `M` es la intersección del dominio de accesibilidad de `T` con el texto de programa de `P`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="c7b0f-288">Si la accesibilidad declarada de `M` es `private`, el dominio de accesibilidad de `M` es el texto de programa de `T`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="c7b0f-289">A partir de estas definiciones, sigue que el dominio de accesibilidad de un miembro anidado siempre es al menos el texto del programa del tipo en el que se declara el miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="c7b0f-290">Además, sigue que el dominio de accesibilidad de un miembro nunca es más inclusivo que el dominio de accesibilidad del tipo en el que se declara el miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="c7b0f-291">En términos intuitivos, cuando se tiene acceso a un tipo o miembro `M`, se evalúan los pasos siguientes para asegurarse de que se permite el acceso:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="c7b0f-292">En primer lugar, si `M` se declara dentro de un tipo (en lugar de una unidad de compilación o un espacio de nombres), se produce un error en tiempo de compilación si ese tipo no es accesible.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="c7b0f-293">A continuación, si se `public``M`, se permite el acceso.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="c7b0f-294">De lo contrario, si se `protected internal``M`, se permite el acceso si se produce en el programa en el que se declara `M`, o bien, si se produce en una clase derivada de la clase en la que se declara `M` y tiene lugar a través del tipo de clase derivada ([acceso protegido para miembros de instancia](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="c7b0f-295">De lo contrario, si se `protected``M`, se permite el acceso si se produce dentro de la clase en la que se declara `M`, o bien, si se produce en una clase derivada de la clase en la que se declara `M` y tiene lugar a través del tipo de clase derivada ([acceso protegido para miembros de instancia](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="c7b0f-296">De lo contrario, si se `internal``M`, se permite el acceso si se produce en el programa en el que se declara `M`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="c7b0f-297">De lo contrario, si se `private``M`, se permite el acceso si se produce en el tipo en el que se declara `M`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="c7b0f-298">De lo contrario, no se puede obtener acceso al tipo o miembro y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="c7b0f-299">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="c7b0f-300">las clases y los miembros tienen los siguientes dominios de accesibilidad:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="c7b0f-301">El dominio de accesibilidad de `A` y `A.X` es ilimitado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="c7b0f-302">El dominio de accesibilidad de `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`y `B.C.Y` es el texto del programa que lo contiene.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="c7b0f-303">El dominio de accesibilidad de `A.Z` es el texto de programa de `A`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="c7b0f-304">El dominio de accesibilidad de `B.Z` y `B.D` es el texto del programa de `B`, incluido el texto del programa de `B.C` y `B.D`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="c7b0f-305">El dominio de accesibilidad de `B.C.Z` es el texto de programa de `B.C`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="c7b0f-306">El dominio de accesibilidad de `B.D.X` y `B.D.Y` es el texto del programa de `B`, incluido el texto del programa de `B.C` y `B.D`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="c7b0f-307">El dominio de accesibilidad de `B.D.Z` es el texto de programa de `B.D`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="c7b0f-308">Como se muestra en el ejemplo, el dominio de accesibilidad de un miembro nunca es mayor que el de un tipo contenedor.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="c7b0f-309">Por ejemplo, aunque todos los miembros de `X` tienen una accesibilidad declarada pública, todos pero `A.X` tienen dominios de accesibilidad que están restringidos por un tipo contenedor.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="c7b0f-310">Como se describe en [miembros](basic-concepts.md#members), todos los miembros de una clase base, excepto los constructores de instancias, destructores y constructores estáticos, los heredan los tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="c7b0f-311">Esto incluye incluso miembros privados de una clase base.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-311">This includes even private members of a base class.</span></span> <span data-ttu-id="c7b0f-312">Sin embargo, el dominio de accesibilidad de un miembro privado incluye solo el texto del programa del tipo en el que se declara el miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="c7b0f-313">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="c7b0f-314">la clase `B` hereda el miembro privado `x` de la clase `A`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="c7b0f-315">Dado que el miembro es privado, solo es accesible dentro del *class_body* de `A`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="c7b0f-316">Por lo tanto, el acceso a `b.x` se realiza correctamente en el método `A.F`, pero produce un error en el método `B.F`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="c7b0f-317">Acceso protegido para miembros de instancia</span><span class="sxs-lookup"><span data-stu-id="c7b0f-317">Protected access for instance members</span></span>

<span data-ttu-id="c7b0f-318">Cuando se tiene acceso a un miembro de instancia de `protected` fuera del texto del programa de la clase en la que se declara, y cuando se tiene acceso a un miembro de instancia de `protected internal` fuera del texto del programa en el que se declara, el acceso debe realizarse dentro de una declaración de clase que deriva de la clase en la que se declara.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="c7b0f-319">Además, el acceso debe realizarse a través de una instancia de ese tipo de clase derivada o de un tipo de clase construido a partir de él.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="c7b0f-320">Esta restricción evita que una clase derivada tenga acceso a miembros protegidos de otras clases derivadas, incluso cuando los miembros se heredan de la misma clase base.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="c7b0f-321">Permita que `B` sea una clase base que declare un miembro de instancia protegido `M`y deje que `D` sea una clase que derive de `B`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="c7b0f-322">En el *class_body* de `D`, el acceso a `M` puede adoptar una de las siguientes formas:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="c7b0f-323">*Type_name* o *primary_expression* no calificados con el formato `M`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="c7b0f-324">*Primary_expression* del `E.M`de formulario, siempre que el tipo de `E` sea `T` o una clase derivada de `T`, donde `T` es el tipo de clase `D`, o un tipo de clase construido a partir de `D`</span><span class="sxs-lookup"><span data-stu-id="c7b0f-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="c7b0f-325">*Primary_expression* del `base.M`de formulario.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="c7b0f-326">Además de estas formas de acceso, una clase derivada puede tener acceso a un constructor de instancia protegido de una clase base en un *constructor_initializer* ([inicializadores de constructor](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="c7b0f-327">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="c7b0f-328">dentro de `A`, es posible tener acceso a `x` a través de instancias de `A` y `B`, ya que en cualquier caso el acceso se realiza a través de una instancia de `A` o una clase derivada de `A`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="c7b0f-329">Sin embargo, dentro de `B`, no es posible tener acceso a `x` a través de una instancia de `A`, ya que `A` no se deriva de `B`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="c7b0f-330">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="c7b0f-331">las tres asignaciones a `x` se permiten porque todas tienen lugar a través de instancias de tipos de clase construidas a partir del tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="c7b0f-332">Restricciones de accesibilidad</span><span class="sxs-lookup"><span data-stu-id="c7b0f-332">Accessibility constraints</span></span>

<span data-ttu-id="c7b0f-333">Varias construcciones del C# lenguaje requieren que un tipo sea ***al menos tan accesible como*** miembro u otro tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="c7b0f-334">Se dice que un tipo `T` es al menos tan accesible como miembro o tipo `M` si el dominio de accesibilidad de `T` es un supraconjunto del dominio de accesibilidad de `M`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="c7b0f-335">En otras palabras, `T` es al menos tan accesible como `M` si `T` está accesible en todos los contextos en los que se puede tener acceso a `M`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="c7b0f-336">Existen las siguientes restricciones de accesibilidad:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="c7b0f-337">La clase base directa de un tipo de clase debe ser al menos igual de accesible que el propio tipo de clase.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="c7b0f-338">Las interfaces base explícitas de un tipo de interfaz deben ser al menos igual de accesibles que el propio tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="c7b0f-339">El tipo de valor devuelto y los tipos de parámetros de un tipo de delegado deben ser al menos igual de accesibles que el propio tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="c7b0f-340">El tipo de una constante debe ser al menos igual de accesible que la propia constante.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="c7b0f-341">El tipo de un campo debe ser al menos igual de accesible que el propio campo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="c7b0f-342">El tipo de valor devuelto y los tipos de parámetros de un método deben ser al menos igual de accesibles que el propio método.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="c7b0f-343">El tipo de una propiedad debe ser al menos igual de accesible que la misma propiedad.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="c7b0f-344">El tipo de un evento debe ser al menos igual de accesible que el propio evento.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="c7b0f-345">Los tipos de parámetro y el tipo de un indexador deben ser al menos igual de accesibles que el propio indexador.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="c7b0f-346">El tipo de valor devuelto y los tipos de parámetro de un operador deben ser al menos igual de accesibles que el propio operador.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="c7b0f-347">Los tipos de parámetro de un constructor de instancia deben ser al menos tan accesibles como el propio constructor de instancia.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="c7b0f-348">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="c7b0f-349">la clase `B` produce un error en tiempo de compilación porque `A` no es al menos tan accesible como `B`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="c7b0f-350">Del mismo modo, en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="c7b0f-351">el método `H` de `B` produce un error en tiempo de compilación porque el tipo de valor devuelto `A` no es al menos tan accesible como el método.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="c7b0f-352">Firmas y sobrecarga</span><span class="sxs-lookup"><span data-stu-id="c7b0f-352">Signatures and overloading</span></span>

<span data-ttu-id="c7b0f-353">Los métodos, los constructores de instancia, los indizadores y los operadores se caracterizan por sus ***firmas***:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="c7b0f-354">La firma de un método consta del nombre del método, el número de parámetros de tipo y el tipo y la clase (valor, referencia o salida) de cada uno de sus parámetros formales, que se considera en el orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="c7b0f-355">Para estos propósitos, cualquier parámetro de tipo del método que se produce en el tipo de un parámetro formal se identifica no por su nombre, sino por su posición ordinal en la lista de argumentos de tipo del método.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="c7b0f-356">La firma de un método no incluye específicamente el tipo de valor devuelto, el modificador `params` que se puede especificar para el parámetro situado más a la derecha, ni las restricciones de parámetro de tipo opcional.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="c7b0f-357">La firma de un constructor de instancia consta del tipo y el tipo (valor, referencia o salida) de cada uno de sus parámetros formales, considerados en el orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="c7b0f-358">La firma de un constructor de instancia no incluye específicamente el modificador `params` que se puede especificar para el parámetro situado más a la derecha.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="c7b0f-359">La firma de un indexador consta del tipo de cada uno de sus parámetros formales, que se considera en el orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="c7b0f-360">La firma de un indexador no incluye específicamente el tipo de elemento, ni incluye el modificador `params` que se puede especificar para el parámetro situado más a la derecha.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="c7b0f-361">La firma de un operador consta del nombre del operador y el tipo de cada uno de sus parámetros formales, considerados en el orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="c7b0f-362">La firma de un operador no incluye específicamente el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="c7b0f-363">Las firmas son el mecanismo de habilitación para la ***sobrecarga*** de miembros en clases, Structs e interfaces:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="c7b0f-364">La sobrecarga de métodos permite a una clase, estructura o interfaz declarar varios métodos con el mismo nombre, siempre que sus firmas sean únicas dentro de esa clase, estructura o interfaz.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="c7b0f-365">La sobrecarga de constructores de instancia permite a una clase o struct declarar varios constructores de instancia, siempre que sus firmas sean únicas dentro de esa clase o estructura.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="c7b0f-366">La sobrecarga de indexadores permite a una clase, estructura o interfaz declarar varios indexadores, siempre que sus firmas sean únicas dentro de esa clase, estructura o interfaz.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="c7b0f-367">La sobrecarga de los operadores permite a una clase o struct declarar varios operadores con el mismo nombre, siempre que sus firmas sean únicas dentro de esa clase o estructura.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="c7b0f-368">Aunque los modificadores de parámetro `out` y `ref` se consideran parte de una firma, los miembros declarados en un tipo único no pueden diferir en la firma únicamente en `ref` y `out`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="c7b0f-369">Se produce un error en tiempo de compilación si dos miembros se declaran en el mismo tipo con firmas que serían iguales si todos los parámetros de ambos métodos con modificadores `out` se cambiaran a `ref` modificadores.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="c7b0f-370">Para otros propósitos de coincidencia de la firma (por ejemplo, ocultar o reemplazar), `ref` y `out` se consideran parte de la firma y no coinciden entre sí.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="c7b0f-371">(Esta restricción consiste en permitir C# que los programas se traduzcan fácilmente para ejecutarse en el Common Language Infrastructure (CLI), que no proporciona una manera de definir métodos que difieren únicamente en `ref` y `out`).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="c7b0f-372">En el caso de las firmas, los tipos `object` y `dynamic` se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="c7b0f-373">Por lo tanto, los miembros declarados en un tipo único pueden no diferir en la firma únicamente por `object` y `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="c7b0f-374">En el ejemplo siguiente se muestra un conjunto de declaraciones de método sobrecargado junto con sus firmas.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="c7b0f-375">Tenga en cuenta que los modificadores de parámetro `ref` y `out` ([parámetros de método](classes.md#method-parameters)) forman parte de una firma.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="c7b0f-376">Por lo tanto, `F(int)` y `F(ref int)` son firmas únicas.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="c7b0f-377">Sin embargo, `F(ref int)` y `F(out int)` no se pueden declarar dentro de la misma interfaz porque las firmas difieren únicamente en `ref` y `out`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="c7b0f-378">Además, tenga en cuenta que el tipo de valor devuelto y el modificador `params` no forman parte de una firma, por lo que no es posible sobrecargar únicamente en función del tipo de valor devuelto o de la inclusión o exclusión del modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="c7b0f-379">Como tal, las declaraciones de los métodos `F(int)` y `F(params string[])` identificados anteriormente provocan un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="c7b0f-380">Ámbitos</span><span class="sxs-lookup"><span data-stu-id="c7b0f-380">Scopes</span></span>

<span data-ttu-id="c7b0f-381">El ***ámbito*** de un nombre es la región del texto del programa en la que es posible hacer referencia a la entidad declarada por el nombre sin la calificación del nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="c7b0f-382">Los ámbitos se pueden ***anidar***y un ámbito interno puede volver a declarar el significado de un nombre desde un ámbito externo (sin embargo, no se quita la restricción impuesta por las [declaraciones](basic-concepts.md#declarations) que se encuentran dentro de un bloque anidado no es posible declarar una variable local con el mismo nombre que una variable local en un bloque de inclusión).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="c7b0f-383">A continuación, se dice que el nombre del ámbito externo está ***oculto*** en la región del texto del programa que abarca el ámbito interno y el acceso al nombre externo solo es posible mediante la calificación del nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="c7b0f-384">El ámbito de un miembro de espacio de nombres declarado por un *namespace_member_declaration* ([miembros de espacio de nombres](namespaces.md#namespace-members)) sin ningún *namespace_declaration* envolvente es todo el texto del programa.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="c7b0f-385">El ámbito de un miembro de espacio de nombres declarado por una *namespace_member_declaration* dentro de una *namespace_declaration* cuyo nombre completo es `N` es el *namespace_body* de cada *namespace_declaration* cuyo nombre completo se `N` o comienza por `N`, seguido de un punto.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="c7b0f-386">El ámbito del nombre definido por una *extern_alias_directive* se extiende por las *using_directive*s, *global_attributes* y *namespace_member_declaration*s de su unidad de compilación o cuerpo de espacio de nombres que contiene inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="c7b0f-387">Un *extern_alias_directive* no aporta ningún miembro nuevo al espacio de declaración subyacente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="c7b0f-388">En otras palabras, una *extern_alias_directive* no es transitiva, sino que afecta solo a la unidad de compilación o al cuerpo del espacio de nombres en el que se produce.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="c7b0f-389">El ámbito de un nombre definido o importado por un *using_directive* ([mediante directivas](namespaces.md#using-directives)) se extiende por los *namespace_member_declaration*s del *compilation_unit* o *namespace_body* en el que se produce el *using_directive* .</span><span class="sxs-lookup"><span data-stu-id="c7b0f-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="c7b0f-390">Un *using_directive* puede hacer que cero o más nombres de espacio de nombres, tipo o miembro estén disponibles dentro de un *compilation_unit* o *namespace_body*determinado, pero no aporta ningún miembro nuevo al espacio de declaración subyacente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="c7b0f-391">En otras palabras, una *using_directive* no es transitiva sino que solo afecta al *compilation_unit* o *namespace_body* en el que se produce.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="c7b0f-392">El ámbito de un parámetro de tipo declarado por un *type_parameter_list* en un *class_declaration* ([declaraciones de clase](classes.md#class-declarations)) es el *class_base*, *type_parameter_constraints_clause*s y *class_body* de ese *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-393">El ámbito de un parámetro de tipo declarado por un *type_parameter_list* en una *struct_declaration* ([declaraciones de struct](structs.md#struct-declarations)) es el *struct_interfaces*, *type_parameter_constraints_clause*s y *struct_body* de ese *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-394">El ámbito de un parámetro de tipo declarado por un *type_parameter_list* en una *interface_declaration* ([declaraciones de interfaz](interfaces.md#interface-declarations)) es el *interface_base*, *type_parameter_constraints_clause*s y *interface_body* de ese *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-395">El ámbito de un parámetro de tipo declarado por un *type_parameter_list* en una *delegate_declaration* ([declaraciones de delegado](delegates.md#delegate-declarations)) es el *return_type*, *formal_parameter_list*y *type_parameter_constraints_clause*s de ese *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-396">El ámbito de un miembro declarado por un *class_member_declaration* ([cuerpo de clase](classes.md#class-body)) es el *class_body* en el que se produce la declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="c7b0f-397">Además, el ámbito de un miembro de clase se extiende al *class_body* de las clases derivadas que se incluyen en el dominio de accesibilidad ([dominios de accesibilidad](basic-concepts.md#accessibility-domains)) del miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="c7b0f-398">El ámbito de un miembro declarado por un *struct_member_declaration* ([miembros de struct](structs.md#struct-members)) es el *struct_body* en el que se produce la declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="c7b0f-399">El ámbito de un miembro declarado por un *enum_member_declaration* ([enumerar miembros](enums.md#enum-members)) es el *enum_body* en el que se produce la declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="c7b0f-400">El ámbito de un parámetro declarado en una *method_declaration* ([métodos](classes.md#methods)) es el *method_body* de ese *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-401">El ámbito de un parámetro declarado en una *indexer_declaration* ([indizadores](classes.md#indexers)) es el *accessor_declarations* de ese *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-402">El ámbito de un parámetro declarado en una *operator_declaration* ([operadores](classes.md#operators)) es el *bloque* de ese *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-403">El ámbito de un parámetro declarado en una *constructor_declaration* ([constructores de instancia](classes.md#instance-constructors)) es el *constructor_initializer* y el *bloque* de ese *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="c7b0f-404">El ámbito de un parámetro declarado en una *lambda_expression* ([expresiones de función anónimas](expressions.md#anonymous-function-expressions)) es el *anonymous_function_body* de ese *lambda_expression*</span><span class="sxs-lookup"><span data-stu-id="c7b0f-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="c7b0f-405">El ámbito de un parámetro declarado en una *anonymous_method_expression* ([expresiones de función anónimas](expressions.md#anonymous-function-expressions)) es el *bloque* de ese *anonymous_method_expression*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="c7b0f-406">El ámbito de una etiqueta declarada en un *labeled_statement* ([instrucciones con etiqueta](statements.md#labeled-statements)) es el *bloque* en el que se produce la declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="c7b0f-407">El ámbito de una variable local declarada en un *local_variable_declaration* ([declaraciones de variables locales](statements.md#local-variable-declarations)) es el bloque en el que se produce la declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="c7b0f-408">El ámbito de una variable local declarada en una *switch_block* de una instrucción de `switch` ([la instrucción switch](statements.md#the-switch-statement)) es el *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="c7b0f-409">El ámbito de una variable local declarada en una *for_initializer* de una instrucción de `for` ([la instrucción for](statements.md#the-for-statement)) es el *for_initializer*, *for_condition*, *for_iterator*y la *instrucción* incluida de la instrucción `for`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="c7b0f-410">El ámbito de una constante local declarada en un *local_constant_declaration* ([declaraciones de constantes locales](statements.md#local-constant-declarations)) es el bloque en el que se produce la declaración.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="c7b0f-411">Es un error en tiempo de compilación hacer referencia a una constante local en una posición textual que precede a su *constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="c7b0f-412">El ámbito de una variable declarada como parte de un *foreach_statement*, *using_statement*, *lock_statement* o *query_expression* viene determinado por la expansión de la construcción especificada.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="c7b0f-413">Dentro del ámbito de un espacio de nombres, una clase, un struct o un miembro de enumeración, es posible hacer referencia al miembro en una posición textual que preceda a la declaración del miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="c7b0f-414">Por ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="c7b0f-415">Aquí, es válido para que `F` haga referencia a `i` antes de que se declare.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="c7b0f-416">Dentro del ámbito de una variable local, se trata de un error en tiempo de compilación para hacer referencia a la variable local en una posición textual que precede al *local_variable_declarator* de la variable local.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="c7b0f-417">Por ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="c7b0f-418">En el método `F` anterior, la primera asignación a `i` específicamente no hace referencia al campo declarado en el ámbito externo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="c7b0f-419">En su lugar, hace referencia a la variable local y produce un error en tiempo de compilación porque precede textualmente a la declaración de la variable.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="c7b0f-420">En el método `G`, el uso de `j` en el inicializador para la declaración de `j` es válido porque el uso no precede al *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="c7b0f-421">En el método `H`, un *local_variable_declarator* subsiguiente hace referencia correctamente a una variable local declarada en una *local_variable_declarator* anterior dentro de la misma *local_variable_declaration*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="c7b0f-422">Las reglas de ámbito de las variables locales están diseñadas para garantizar que el significado de un nombre usado en un contexto de expresión siempre es el mismo dentro de un bloque.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="c7b0f-423">Si el ámbito de una variable local solo se extiende desde su declaración hasta el final del bloque, en el ejemplo anterior, la primera asignación se asignaría a la variable de instancia y la segunda asignación asignaría a la variable local, lo que posiblemente provocaría errores en tiempo de compilación si las instrucciones del bloque se van a reorganizar posteriormente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="c7b0f-424">El significado de un nombre dentro de un bloque puede variar en función del contexto en el que se usa el nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="c7b0f-425">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="c7b0f-426">el nombre `A` se usa en un contexto de expresión para hacer referencia a la variable local `A` y en un contexto de tipo para hacer referencia a la clase `A`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="c7b0f-427">Ocultación de nombres</span><span class="sxs-lookup"><span data-stu-id="c7b0f-427">Name hiding</span></span>

<span data-ttu-id="c7b0f-428">El ámbito de una entidad suele abarcar más texto del programa que el espacio de declaración de la entidad.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="c7b0f-429">En concreto, el ámbito de una entidad puede incluir declaraciones que introducen nuevos espacios de declaración que contienen entidades con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="c7b0f-430">Dichas declaraciones hacen que la entidad original se ***oculte***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="c7b0f-431">Por el contrario, se dice que una entidad es ***visible*** cuando no está oculta.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="c7b0f-432">La ocultación de nombres se produce cuando los ámbitos se superponen mediante anidamiento y cuando los ámbitos se superponen a través de la herencia.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="c7b0f-433">En las secciones siguientes se describen las características de los dos tipos de ocultación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="c7b0f-434">Ocultar mediante anidamiento</span><span class="sxs-lookup"><span data-stu-id="c7b0f-434">Hiding through nesting</span></span>

<span data-ttu-id="c7b0f-435">La ocultación de nombres mediante el anidamiento puede producirse como resultado de anidar espacios de nombres o tipos dentro de los espacios de nombres, como resultado de anidar tipos dentro de clases o Structs, y como resultado de parámetros y declaraciones de variables locales.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="c7b0f-436">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="c7b0f-437">en el método `F`, la variable local `i` oculta la variable de instancia `i`, pero dentro del método `G`, `i` todavía hace referencia a la variable de instancia.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="c7b0f-438">Cuando un nombre de un ámbito interno oculta un nombre en un ámbito externo, oculta todas las apariciones sobrecargadas de ese nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="c7b0f-439">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="c7b0f-440">la `F(1)` de llamada invoca el `F` declarado en `Inner` porque todas las repeticiones externas de `F` están ocultas por la declaración interna.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="c7b0f-441">Por la misma razón, la llamada `F("Hello")` produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="c7b0f-442">Ocultar a través de la herencia</span><span class="sxs-lookup"><span data-stu-id="c7b0f-442">Hiding through inheritance</span></span>

<span data-ttu-id="c7b0f-443">La ocultación de nombres a través de la herencia se produce cuando las clases o Structs declaran nombres que se heredaron de clases base.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="c7b0f-444">Este tipo de ocultación de nombres adopta uno de los siguientes formatos:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="c7b0f-445">Una constante, un campo, una propiedad, un evento o un tipo introducidos en una clase o struct oculta todos los miembros de clase base con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="c7b0f-446">Un método introducido en una clase o struct oculta todos los miembros de clase base que no son de método con el mismo nombre y todos los métodos de clase base con la misma firma (nombre de método y número de parámetros, modificadores y tipos).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="c7b0f-447">Un indizador introducido en una clase o struct oculta todos los indizadores de clase base con la misma firma (número de parámetros y tipos).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="c7b0f-448">Las reglas que rigen las declaraciones de operador ([operadores](classes.md#operators)) hacen imposible que una clase derivada declare un operador con la misma signatura que un operador en una clase base.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="c7b0f-449">Por lo tanto, los operadores nunca se ocultan entre sí.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="c7b0f-450">Al contrario que ocultar un nombre de un ámbito externo, si se oculta un nombre accesible desde un ámbito heredado, se genera una advertencia.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="c7b0f-451">en el ejemplo</span><span class="sxs-lookup"><span data-stu-id="c7b0f-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="c7b0f-452">la declaración de `F` en `Derived` provoca la notificación de una advertencia.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="c7b0f-453">Ocultar un nombre heredado no es específicamente un error, ya que esto impedirá la evolución independiente de las clases base.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="c7b0f-454">Por ejemplo, la situación anterior podría haber surgido debido a que una versión posterior de `Base` presentó un `F` método que no estaba presente en una versión anterior de la clase.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="c7b0f-455">Si la situación anterior hubiera sido un error, cualquier cambio realizado en una clase base en una biblioteca de clases con versiones independientes podría provocar que las clases derivadas dejen de ser válidas.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="c7b0f-456">La advertencia causada por ocultar un nombre heredado puede eliminarse mediante el uso del modificador `new`:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="c7b0f-457">El modificador `new` indica que el `F` de `Derived` es "New" y que, en realidad, está pensado para ocultar el miembro heredado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="c7b0f-458">Una declaración de un nuevo miembro oculta un miembro heredado solo dentro del ámbito del nuevo miembro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="c7b0f-459">En el ejemplo anterior, la declaración de `F` en `Derived` oculta la `F` que se heredó de `Base`, pero como el nuevo `F` de `Derived` tiene acceso privado, su ámbito no se extiende a `MoreDerived`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="c7b0f-460">Por lo tanto, la llamada `F()` en `MoreDerived.G` es válida y invocará a `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="c7b0f-461">Nombres de espacios de nombres y tipos</span><span class="sxs-lookup"><span data-stu-id="c7b0f-461">Namespace and type names</span></span>

<span data-ttu-id="c7b0f-462">Varios contextos de un C# programa requieren que se especifique un *namespace_name* o un *type_name* .</span><span class="sxs-lookup"><span data-stu-id="c7b0f-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="c7b0f-463">Un *namespace_name* es un *namespace_or_type_name* que hace referencia a un espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="c7b0f-464">Después de la resolución tal y como se describe a continuación, el *namespace_or_type_name* de una *namespace_name* debe hacer referencia a un espacio de nombres o, de lo contrario, se producirá un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="c7b0f-465">Ningún argumento de tipo ([argumentos de tipo](types.md#type-arguments)) puede estar presente en un *namespace_name* (solo los tipos pueden tener argumentos de tipo).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="c7b0f-466">Un *type_name* es un *namespace_or_type_name* que hace referencia a un tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="c7b0f-467">Después de la resolución tal y como se describe a continuación, el *namespace_or_type_name* de una *type_name* debe hacer referencia a un tipo o, de lo contrario, se producirá un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="c7b0f-468">Si el *namespace_or_type_name* es un miembro de alias calificado, su significado es como se describe en [calificadores de alias de espacios de nombres](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="c7b0f-469">De lo contrario, una *namespace_or_type_name* tiene una de las cuatro formas siguientes:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="c7b0f-470">donde `I` es un identificador único, `N` es un *namespace_or_type_name* y `<A1, ..., Ak>` es un *type_argument_list*opcional.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="c7b0f-471">Cuando no se especifica ningún *type_argument_list* , considere la posibilidad de que `k` sea cero.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="c7b0f-472">El significado de un *namespace_or_type_name* se determina de la manera siguiente:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="c7b0f-473">Si el *namespace_or_type_name* tiene el formato `I` o con el formato `I<A1, ..., Ak>`:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="c7b0f-474">Si `K` es cero y el *namespace_or_type_name* aparece dentro de una declaración de método genérico ([métodos](classes.md#methods)) y la Declaración incluye un parámetro de tipo ([parámetros de tipo](classes.md#type-parameters)) con el nombre `I`, el *namespace_or_type_name* hace referencia a ese parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="c7b0f-475">De lo contrario, si el *namespace_or_type_name* aparece dentro de una declaración de tipos, para cada tipo de instancia `T` ([el tipo de instancia](classes.md#the-instance-type)), empezando por el tipo de instancia de esa declaración de tipos y continuando con el tipo de instancia de cada declaración de clase o estructura envolvente (si existe):</span><span class="sxs-lookup"><span data-stu-id="c7b0f-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="c7b0f-476">Si `K` es cero y la declaración de `T` incluye un parámetro de tipo con el nombre `I`, el *namespace_or_type_name* hace referencia a ese parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="c7b0f-477">De lo contrario, si el *namespace_or_type_name* aparece dentro del cuerpo de la declaración de tipos y `T` o cualquiera de sus tipos base contienen un tipo accesible anidado con el nombre `I` y `K` parámetros de tipo, el *namespace_or_type_name* hace referencia a ese tipo construido con los argumentos de tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="c7b0f-478">Si hay más de un tipo de este tipo, se selecciona el tipo declarado en el tipo más derivado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="c7b0f-479">Tenga en cuenta que los miembros que no son de tipo (constantes, campos, métodos, propiedades, indizadores, operadores, constructores de instancias, destructores y constructores estáticos) y miembros de tipo con un número diferente de parámetros de tipo se omiten al determinar el significado del *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="c7b0f-480">Si los pasos anteriores no se realizaron correctamente, para cada espacio de nombres `N`, empezando por el espacio de nombres en el que se produce el *namespace_or_type_name* , continuando con cada espacio de nombres envolvente (si existe) y finalizando con el espacio de nombres global, los siguientes pasos se evalúan hasta que se encuentra una entidad:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="c7b0f-481">Si `K` es cero y `I` es el nombre de un espacio de nombres en `N`, entonces:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="c7b0f-482">Si la ubicación donde se produce el *namespace_or_type_name* se incluye en una declaración de espacio de nombres para `N` y la declaración del espacio de nombres contiene un *extern_alias_directive* o *using_alias_directive* que asocia el nombre `I` con un espacio de nombres o un tipo, el *namespace_or_type_name* es ambiguo y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="c7b0f-483">De lo contrario, el *namespace_or_type_name* hace referencia al espacio de nombres denominado `I` en `N`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="c7b0f-484">De lo contrario, si `N` contiene un tipo accesible que tiene el nombre `I` y `K` parámetros de tipo, entonces:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="c7b0f-485">Si `K` es cero y la ubicación donde se produce la *namespace_or_type_name* se incluye en una declaración de espacio de nombres para `N` y la declaración del espacio de nombres contiene una *extern_alias_directive* o *using_alias_directive* que asocia el nombre `I` con un espacio de nombres o un tipo, el *namespace_or_type_name* es ambiguo y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="c7b0f-486">De lo contrario, el *namespace_or_type_name* hace referencia al tipo construido con los argumentos de tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="c7b0f-487">De lo contrario, si la ubicación donde se produce el *namespace_or_type_name* se incluye en una declaración de espacio de nombres para `N`:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="c7b0f-488">Si `K` es cero y la declaración del espacio de nombres contiene un *extern_alias_directive* o *using_alias_directive* que asocia el nombre `I` con un espacio de nombres o tipo importado, el *namespace_or_type_name* hace referencia a ese espacio de nombres o tipo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="c7b0f-489">De lo contrario, si los espacios de nombres y las declaraciones de tipos importados por *using_namespace_directive*s y *using_alias_directive*s de la declaración del espacio de nombres contienen exactamente un tipo accesible con el nombre `I` y `K` parámetros de tipo, el *namespace_or_type_name* hace referencia a ese tipo construido con los argumentos de tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="c7b0f-490">De lo contrario, si los espacios de nombres y las declaraciones de tipos importados por *using_namespace_directive*s y *using_alias_directive*s de la declaración del espacio de nombres contienen más de un tipo accesible con el nombre `I` y `K` parámetros de tipo, el *namespace_or_type_name* es ambiguo y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="c7b0f-491">De lo contrario, el *namespace_or_type_name* es indefinido y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c7b0f-492">De lo contrario, el *namespace_or_type_name* tiene el formato `N.I` o con el formato `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="c7b0f-493">`N` se resuelve primero como un *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="c7b0f-494">Si la resolución de `N` no se realiza correctamente, se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="c7b0f-495">De lo contrario, `N.I` o `N.I<A1, ..., Ak>` se resuelve de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="c7b0f-496">Si `K` es cero y `N` hace referencia a un espacio de nombres y `N` contiene un espacio de nombres anidado con el nombre `I`, el *namespace_or_type_name* hace referencia a ese espacio de nombres anidado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="c7b0f-497">De lo contrario, si `N` hace referencia a un espacio de nombres y `N` contiene un tipo accesible con el nombre `I` y `K` parámetros de tipo, el *namespace_or_type_name* hace referencia a ese tipo construido con los argumentos de tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="c7b0f-498">De lo contrario, si `N` hace referencia a un tipo de clase o struct (posiblemente construido) y `N` o cualquiera de sus clases base contienen un tipo accesible anidado con el nombre `I` y `K` parámetros de tipo, el *namespace_or_type_name* hace referencia a ese tipo construido con los argumentos de tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="c7b0f-499">Si hay más de un tipo de este tipo, se selecciona el tipo declarado en el tipo más derivado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="c7b0f-500">Tenga en cuenta que si se está determinando el significado de `N.I` como parte de la resolución de la especificación de clase base de `N`, se considera que la clase base directa de `N` es Object ([clases base](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="c7b0f-501">De lo contrario, `N.I` es un *namespace_or_type_name*no válido y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="c7b0f-502">Solo se permite que un *namespace_or_type_name* haga referencia a una clase estática ([clases estáticas](classes.md#static-classes)) si</span><span class="sxs-lookup"><span data-stu-id="c7b0f-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="c7b0f-503">El *namespace_or_type_name* es el `T` en un *namespace_or_type_name* del formulario `T.I`, o</span><span class="sxs-lookup"><span data-stu-id="c7b0f-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="c7b0f-504">El *namespace_or_type_name* es el `T` en un *typeof_expression* ([listas de argumentos](expressions.md#argument-lists)1) del formulario `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="c7b0f-505">Nombres completos</span><span class="sxs-lookup"><span data-stu-id="c7b0f-505">Fully qualified names</span></span>

<span data-ttu-id="c7b0f-506">Cada espacio de nombres y tipo tiene un ***nombre completo***, que identifica de forma única el espacio de nombres o el tipo entre todos los demás.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="c7b0f-507">El nombre completo de un espacio de nombres o tipo `N` se determina de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="c7b0f-508">Si `N` es un miembro del espacio de nombres global, su nombre completo es `N`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="c7b0f-509">De lo contrario, su nombre completo es `S.N`, donde `S` es el nombre completo del espacio de nombres o tipo en el que se declara `N`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="c7b0f-510">En otras palabras, el nombre completo de `N` es la ruta de acceso jerárquica completa de los identificadores que conducen a `N`, comenzando por el espacio de nombres global.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="c7b0f-511">Dado que cada miembro de un espacio de nombres o tipo debe tener un nombre único, sigue que el nombre completo de un espacio de nombres o tipo es siempre único.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="c7b0f-512">En el ejemplo siguiente se muestran varias declaraciones de espacio de nombres y tipo junto con sus nombres completos asociados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="c7b0f-513">Administración de memoria automática</span><span class="sxs-lookup"><span data-stu-id="c7b0f-513">Automatic memory management</span></span>

<span data-ttu-id="c7b0f-514">C#emplea la administración de memoria automática, que libera a los desarrolladores de la asignación y liberación manuales de la memoria ocupada por los objetos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="c7b0f-515">Las directivas de administración de memoria automática se implementan mediante un ***recolector de elementos no utilizados***.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="c7b0f-516">El ciclo de vida de la administración de memoria de un objeto es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="c7b0f-517">Cuando se crea el objeto, se le asigna memoria, se ejecuta el constructor y el objeto se considera activo.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="c7b0f-518">Si no se puede tener acceso al objeto, o a cualquier parte del mismo, por cualquier continuación posible de ejecución, que no sea la ejecución de destructores, el objeto se considera que ya no está en uso y se puede elegir para su destrucción.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="c7b0f-519">El C# compilador y el recolector de elementos no utilizados pueden optar por analizar el código para determinar qué referencias a un objeto se pueden usar en el futuro.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="c7b0f-520">Por ejemplo, si una variable local que se encuentra en el ámbito es la única referencia existente a un objeto, pero nunca se hace referencia a esa variable local en ninguna continuación posible de ejecución del punto de ejecución actual del procedimiento, el recolector de elementos no utilizados puede (pero no es obligatorio para) tratar el objeto como ya no está en uso.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="c7b0f-521">Una vez que el objeto es válido para la destrucción, en algún momento posterior no especificado, se ejecuta el destructor[(destructores) (](classes.md#destructors)si existe) para el objeto.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="c7b0f-522">En circunstancias normales, el destructor del objeto solo se ejecuta una vez, aunque las API específicas de la implementación pueden permitir que se invalide este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="c7b0f-523">Una vez que se ejecuta el destructor de un objeto, si no se puede tener acceso a ese objeto o a cualquier parte del mismo, cualquier continuación posible de ejecución, incluida la ejecución de destructores, el objeto se considera inaccesible y el objeto pasa a ser válido para la colección.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="c7b0f-524">Por último, en algún momento después de que el objeto sea válido para la recolección, el recolector de elementos no utilizados libera la memoria asociada a ese objeto.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="c7b0f-525">El recolector de elementos no utilizados mantiene información sobre el uso de los objetos y usa esta información para tomar decisiones de administración de memoria, como la ubicación de la memoria para buscar un objeto recién creado, Cuándo se debe reubicar un objeto y cuándo un objeto ya no está en uso o es inaccesible.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="c7b0f-526">Al igual que otros lenguajes que suponen la existencia C# de un recolector de elementos no utilizados, está diseñado de modo que el recolector de elementos no utilizados pueda implementar una amplia gama de directivas de administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="c7b0f-527">Por ejemplo, C# no requiere que se ejecuten destructores o que los objetos se recopilen tan pronto como sean válidos, o que los destructores se ejecuten en un orden determinado o en un subproceso determinado.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="c7b0f-528">El comportamiento del recolector de elementos no utilizados puede controlarse, hasta cierto punto, a través de métodos estáticos en la clase `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="c7b0f-529">Esta clase se puede usar para solicitar que se produzca una colección, destructores que se van a ejecutar (o no ejecutar), etc.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="c7b0f-530">Dado que el recolector de elementos no utilizados tiene una latitud ancha a la hora de decidir cuándo recopilar objetos y ejecutar destructores, una implementación compatible puede generar resultados que sean diferentes de los que se muestran en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="c7b0f-531">El programa</span><span class="sxs-lookup"><span data-stu-id="c7b0f-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="c7b0f-532">crea una instancia de la clase `A` y una instancia de la clase `B`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="c7b0f-533">Estos objetos son válidos para la recolección de elementos no utilizados cuando la variable `b` tiene asignado el valor `null`, ya que, después de este tiempo, no es posible que ningún código escrito por el usuario tenga acceso a ellos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="c7b0f-534">El resultado puede ser</span><span class="sxs-lookup"><span data-stu-id="c7b0f-534">The output could be either</span></span>

```console
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="c7b0f-535">o</span><span class="sxs-lookup"><span data-stu-id="c7b0f-535">or</span></span>
```console
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="c7b0f-536">Dado que el lenguaje no impone ninguna restricción en el orden en el que los objetos se recolectan como elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="c7b0f-537">En casos sutiles, la distinción entre "candidato a la destrucción" y "puede ser válida para la recopilación" puede ser importante.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="c7b0f-538">Por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="c7b0f-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="c7b0f-539">En el programa anterior, si el recolector de elementos no utilizados elige ejecutar el destructor de `A` antes del destructor de `B`, el resultado de este programa podría ser:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```console
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="c7b0f-540">Tenga en cuenta que aunque la instancia de `A` no estaba en uso y el destructor de `A`se ejecutó, todavía es posible llamar a los métodos de `A` (en este caso, `F`) desde otro destructor.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="c7b0f-541">Además, tenga en cuenta que la ejecución de un destructor puede hacer que un objeto se pueda utilizar de nuevo desde el programa principal.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="c7b0f-542">En este caso, la ejecución del destructor de `B`produjo una instancia de `A` que antes no estaba en uso para ser accesible desde la `Test.RefA`de referencia activa.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="c7b0f-543">Después de la llamada a `WaitForPendingFinalizers`, la instancia de `B` es válida para la recolección, pero la instancia de `A` no es, debido a la `Test.RefA`de referencia.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="c7b0f-544">Para evitar la confusión y el comportamiento inesperado, suele ser una buena idea que los destructores solo realicen la limpieza en los datos almacenados en sus propios campos del objeto y no realicen ninguna acción en los objetos a los que se hace referencia ni en los campos estáticos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="c7b0f-545">Una alternativa al uso de destructores es dejar que una clase implemente la interfaz `System.IDisposable`.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="c7b0f-546">Esto permite al cliente del objeto determinar cuándo liberar los recursos del objeto, normalmente mediante el acceso al objeto como un recurso en una instrucción `using` ([la instrucción using](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="c7b0f-547">Orden de ejecución</span><span class="sxs-lookup"><span data-stu-id="c7b0f-547">Execution order</span></span>

<span data-ttu-id="c7b0f-548">La ejecución de C# un programa continúa de tal forma que los efectos secundarios de cada subproceso en ejecución se conserven en puntos de ejecución críticos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="c7b0f-549">Un ***efecto secundario*** se define como una lectura o escritura de un campo volátil, una escritura en una variable no volátil, una escritura en un recurso externo y el inicio de una excepción.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="c7b0f-550">Los puntos de ejecución críticos en los que se debe conservar el orden de estos efectos secundarios son las referencias a campos volátiles ([campos volátiles](classes.md#volatile-fields)), `lock` instrucciones ([la instrucción lock](statements.md#the-lock-statement)) y la creación y terminación de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="c7b0f-551">El entorno de ejecución es gratuito para cambiar el orden de ejecución de C# un programa, sujeto a las siguientes restricciones:</span><span class="sxs-lookup"><span data-stu-id="c7b0f-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="c7b0f-552">La dependencia de los datos se conserva dentro de un subproceso de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="c7b0f-553">Es decir, el valor de cada variable se calcula como si todas las instrucciones del subproceso se ejecutaran en el orden del programa original.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="c7b0f-554">Se conservan las reglas de ordenación de inicialización ([inicialización de campos](classes.md#field-initialization) e [inicializadores de variables](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="c7b0f-555">El orden de los efectos secundarios se conserva con respecto a las lecturas y escrituras volátiles ([campos volátiles](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="c7b0f-556">Además, el entorno de ejecución no necesita evaluar parte de una expresión si puede deducir que el valor de esa expresión no se usa y que no se producen efectos secundarios necesarios (incluidos los causados por una llamada a un método o el acceso a un campo volátil).</span><span class="sxs-lookup"><span data-stu-id="c7b0f-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="c7b0f-557">Cuando se interrumpe la ejecución del programa mediante un evento asincrónico (como una excepción iniciada por otro subproceso), no se garantiza que los efectos secundarios observables estén visibles en el orden del programa original.</span><span class="sxs-lookup"><span data-stu-id="c7b0f-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
