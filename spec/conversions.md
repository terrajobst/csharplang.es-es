---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/05/2019
ms.locfileid: "74868009"
---
# <a name="conversions"></a><span data-ttu-id="fb09f-101">Conversiones</span><span class="sxs-lookup"><span data-stu-id="fb09f-101">Conversions</span></span>

<span data-ttu-id="fb09f-102">Una ***conversión*** permite que una expresión se trate de un tipo determinado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="fb09f-103">Una conversión puede hacer que una expresión de un tipo determinado se trate como si tuviera un tipo diferente o que una expresión sin un tipo obtenga un tipo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="fb09f-104">Las conversiones pueden ser ***implícitas*** o ***explícitas***, y esto determina si se requiere una conversión explícita.</span><span class="sxs-lookup"><span data-stu-id="fb09f-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="fb09f-105">Por ejemplo, la conversión del tipo `int` al tipo `long` es implícita, por lo que las expresiones de tipo `int` se pueden tratar implícitamente como `long`de tipo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="fb09f-106">La conversión opuesta, del tipo `long` al tipo `int`, es explícita y, por tanto, se requiere una conversión explícita.</span><span class="sxs-lookup"><span data-stu-id="fb09f-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="fb09f-107">Algunas conversiones están definidas por el lenguaje.</span><span class="sxs-lookup"><span data-stu-id="fb09f-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="fb09f-108">Los programas también pueden definir sus propias conversiones ([conversiones definidas por el usuario](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="fb09f-109">Conversiones implícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-109">Implicit conversions</span></span>

<span data-ttu-id="fb09f-110">Las conversiones siguientes se clasifican como conversiones implícitas:</span><span class="sxs-lookup"><span data-stu-id="fb09f-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="fb09f-111">Conversiones de identidad</span><span class="sxs-lookup"><span data-stu-id="fb09f-111">Identity conversions</span></span>
*  <span data-ttu-id="fb09f-112">Conversiones numéricas implícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="fb09f-113">Conversiones de enumeración IMPLÍCITAS</span><span class="sxs-lookup"><span data-stu-id="fb09f-113">Implicit enumeration conversions</span></span>
*  <span data-ttu-id="fb09f-114">Conversiones de cadenas interpoladas IMPLÍCITAS</span><span class="sxs-lookup"><span data-stu-id="fb09f-114">Implicit interpolated string conversions</span></span>
*  <span data-ttu-id="fb09f-115">Conversiones implícitas que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="fb09f-115">Implicit nullable conversions</span></span>
*  <span data-ttu-id="fb09f-116">Conversiones de literales null</span><span class="sxs-lookup"><span data-stu-id="fb09f-116">Null literal conversions</span></span>
*  <span data-ttu-id="fb09f-117">Conversiones de referencias implícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-117">Implicit reference conversions</span></span>
*  <span data-ttu-id="fb09f-118">Conversiones Boxing</span><span class="sxs-lookup"><span data-stu-id="fb09f-118">Boxing conversions</span></span>
*  <span data-ttu-id="fb09f-119">Conversiones dinámicas IMPLÍCITAS</span><span class="sxs-lookup"><span data-stu-id="fb09f-119">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="fb09f-120">Conversiones implícitas de expresiones constantes</span><span class="sxs-lookup"><span data-stu-id="fb09f-120">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="fb09f-121">Conversiones implícitas definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-121">User-defined implicit conversions</span></span>
*  <span data-ttu-id="fb09f-122">Conversiones de funciones anónimas</span><span class="sxs-lookup"><span data-stu-id="fb09f-122">Anonymous function conversions</span></span>
*  <span data-ttu-id="fb09f-123">Conversiones de grupos de métodos</span><span class="sxs-lookup"><span data-stu-id="fb09f-123">Method group conversions</span></span>

<span data-ttu-id="fb09f-124">Las conversiones implícitas pueden producirse en diversas situaciones, incluidas las invocaciones de miembros de función ([comprobación en tiempo de compilación de la resolución dinámica de sobrecarga](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), las expresiones de conversión ([expresiones de conversión](expressions.md#cast-expressions)) y las asignaciones (operadores de[asignación](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-124">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="fb09f-125">Las conversiones implícitas predefinidas siempre se realizan correctamente y nunca provocan que se inicien excepciones.</span><span class="sxs-lookup"><span data-stu-id="fb09f-125">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="fb09f-126">Las conversiones implícitas definidas por el usuario diseñadas correctamente deberían presentar también estas características.</span><span class="sxs-lookup"><span data-stu-id="fb09f-126">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="fb09f-127">En lo que respecta a la conversión, los tipos `object` y `dynamic` se consideran equivalentes.</span><span class="sxs-lookup"><span data-stu-id="fb09f-127">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="fb09f-128">Sin embargo, las conversiones dinámicas (conversiones dinámicas[implícitas](conversions.md#implicit-dynamic-conversions) y [conversiones dinámicas explícitas](conversions.md#explicit-dynamic-conversions)) solo se aplican a las expresiones de tipo `dynamic` ([el tipo dinámico](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-128">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="fb09f-129">Conversión de identidad</span><span class="sxs-lookup"><span data-stu-id="fb09f-129">Identity conversion</span></span>

<span data-ttu-id="fb09f-130">Una conversión de identidad convierte de cualquier tipo al mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-130">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="fb09f-131">Esta conversión existe de manera que se puede decir que una entidad que ya tiene un tipo necesario se puede convertir en ese tipo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-131">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="fb09f-132">Dado que `object` y `dynamic` se consideran equivalentes, hay una conversión de identidad entre `object` y `dynamic`, y entre los tipos construidos que son iguales al reemplazar todas las apariciones de `dynamic` por `object`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-132">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="fb09f-133">Conversiones numéricas implícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-133">Implicit numeric conversions</span></span>

<span data-ttu-id="fb09f-134">Las conversiones numéricas implícitas son:</span><span class="sxs-lookup"><span data-stu-id="fb09f-134">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="fb09f-135">De `sbyte` a `short`, `int`, `long`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-135">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-136">De `byte` a `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-136">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-137">De `short` a `int`, `long`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-137">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-138">De `ushort` a `int`, `uint`, `long`, `ulong`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-138">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-139">De `int` a `long`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-139">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-140">De `uint` a `long`, `ulong`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-140">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-141">De `long` a `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-141">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-142">De `ulong` a `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-142">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-143">De `char` a `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-143">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-144">De `float` a `double`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-144">From `float` to `double`.</span></span>

<span data-ttu-id="fb09f-145">Las conversiones de `int`, `uint`, `long`o `ulong` a `float` y desde `long` o `ulong` a `double` pueden provocar una pérdida de precisión, pero nunca producirán una pérdida de magnitud.</span><span class="sxs-lookup"><span data-stu-id="fb09f-145">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="fb09f-146">El resto de conversiones numéricas implícitas nunca pierden información.</span><span class="sxs-lookup"><span data-stu-id="fb09f-146">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="fb09f-147">No hay conversiones implícitas al tipo de `char`, por lo que los valores de los otros tipos enteros no se convierten automáticamente al tipo de `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-147">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="fb09f-148">Conversiones de enumeración IMPLÍCITAS</span><span class="sxs-lookup"><span data-stu-id="fb09f-148">Implicit enumeration conversions</span></span>

<span data-ttu-id="fb09f-149">Una conversión de enumeración implícita permite convertir el `0` de *decimal_integer_literal* en cualquier *enum_type* y en cualquier *nullable_type* cuyo tipo subyacente sea una *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-149">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="fb09f-150">En el último caso, la conversión se evalúa convirtiendo en el *enum_type* subyacente y ajustando el resultado ([tipos que aceptan valores NULL](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-150">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="fb09f-151">Conversiones de cadenas interpoladas IMPLÍCITAS</span><span class="sxs-lookup"><span data-stu-id="fb09f-151">Implicit interpolated string conversions</span></span>

<span data-ttu-id="fb09f-152">Una conversión de cadena interpolada implícita permite convertir un *interpolated_string_expression* ([cadenas interpoladas](expressions.md#interpolated-strings)) en `System.IFormattable` o `System.FormattableString` (que implementa `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="fb09f-152">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="fb09f-153">Cuando se aplica esta conversión, un valor de cadena no se compone de la cadena interpolada.</span><span class="sxs-lookup"><span data-stu-id="fb09f-153">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="fb09f-154">En su lugar, se crea una instancia de `System.FormattableString`, como se describe en [cadenas interpoladas](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="fb09f-154">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="fb09f-155">Conversiones implícitas que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="fb09f-155">Implicit nullable conversions</span></span>

<span data-ttu-id="fb09f-156">Las conversiones implícitas predefinidas que operan en tipos de valor que no aceptan valores null también se pueden usar con formas que aceptan valores NULL de esos tipos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-156">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="fb09f-157">Para cada una de las conversiones implícitas y numéricas predefinidas que convierten de un tipo de valor que no acepta valores NULL `S` a un `T`tipo de valor que no acepta valores NULL, existen las siguientes conversiones implícitas que aceptan valores NULL:</span><span class="sxs-lookup"><span data-stu-id="fb09f-157">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="fb09f-158">Conversión implícita de `S?` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-158">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="fb09f-159">Conversión implícita de `S` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-159">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="fb09f-160">La evaluación de una conversión implícita que acepta valores NULL en función de una conversión subyacente de `S` a `T` continúa de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="fb09f-160">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="fb09f-161">Si la conversión que acepta valores NULL es de `S?` a `T?`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-161">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="fb09f-162">Si el valor de origen es null (`HasValue` propiedad es false), el resultado es el valor null de tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-162">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="fb09f-163">De lo contrario, la conversión se evalúa como un desencapsulado de `S?` a `S`, seguido de la conversión subyacente de `S` a `T`, seguido de un ajuste ([tipos que aceptan valores NULL](types.md#nullable-types)) de `T` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-163">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="fb09f-164">Si la conversión que acepta valores NULL es de `S` a `T?`, la conversión se evalúa como la conversión subyacente de `S` a `T` seguido de un ajuste de `T` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-164">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="fb09f-165">Conversiones de literales null</span><span class="sxs-lookup"><span data-stu-id="fb09f-165">Null literal conversions</span></span>

<span data-ttu-id="fb09f-166">Existe una conversión implícita del literal `null` a cualquier tipo que acepte valores NULL.</span><span class="sxs-lookup"><span data-stu-id="fb09f-166">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="fb09f-167">Esta conversión genera el valor null ([tipos que aceptan valores NULL](types.md#nullable-types)) del tipo que acepta valores NULL dado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-167">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="fb09f-168">Conversiones de referencias implícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-168">Implicit reference conversions</span></span>

<span data-ttu-id="fb09f-169">Las conversiones de referencia implícitas son:</span><span class="sxs-lookup"><span data-stu-id="fb09f-169">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="fb09f-170">Desde cualquier *reference_type* a `object` y `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-170">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="fb09f-171">Desde cualquier *class_type* `S` a cualquier `T`de *class_type* , proporcionado `S` se deriva de `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-171">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="fb09f-172">Desde cualquier *class_type* `S` a cualquier `T`de *interface_type* , proporcionado `S` implementa `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-172">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="fb09f-173">Desde cualquier *interface_type* `S` a cualquier `T`de *interface_type* , proporcionado `S` se deriva de `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-173">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="fb09f-174">A partir de un `S` de *array_type* con un tipo de elemento `SE` a un `T` de *array_type* con un tipo de elemento `TE`, siempre que se cumplan todas las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="fb09f-174">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="fb09f-175">`S` y `T` solo difieren en el tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="fb09f-175">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="fb09f-176">En otras palabras, `S` y `T` tienen el mismo número de dimensiones.</span><span class="sxs-lookup"><span data-stu-id="fb09f-176">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="fb09f-177">Tanto `SE` como `TE` son *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="fb09f-177">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="fb09f-178">Existe una conversión de referencia implícita de `SE` a `TE`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-178">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="fb09f-179">Desde cualquier *array_type* a `System.Array` y las interfaces que implementa.</span><span class="sxs-lookup"><span data-stu-id="fb09f-179">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="fb09f-180">Desde un tipo de matriz unidimensional `S[]` a `System.Collections.Generic.IList<T>` y sus interfaces base, siempre que haya una conversión implícita de identidad o de referencia de `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-180">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="fb09f-181">Desde cualquier *delegate_type* a `System.Delegate` y las interfaces que implementa.</span><span class="sxs-lookup"><span data-stu-id="fb09f-181">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="fb09f-182">Del literal null a cualquier *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-182">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="fb09f-183">Desde cualquier *reference_type* a un *reference_type* `T` si tiene una conversión implícita de identidad o de referencia a una *reference_type* `T0` y `T0` tiene una conversión de identidad en `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-183">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="fb09f-184">Desde cualquier *reference_type* a un tipo de interfaz o delegado `T` si tiene una conversión implícita o de referencia a una interfaz o un tipo de delegado `T0` y `T0` es de varianza ([conversión de varianza](interfaces.md#variance-conversion)) para `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-184">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="fb09f-185">Conversiones implícitas que implican parámetros de tipo que se sabe que son tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-185">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="fb09f-186">Vea [conversiones implícitas que implican parámetros de tipo](conversions.md#implicit-conversions-involving-type-parameters) para obtener más información sobre las conversiones implícitas que implican parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-186">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="fb09f-187">Las conversiones de referencia implícitas son las conversiones entre *reference_type*s que se pueden demostrar que siempre se realizan correctamente y, por tanto, no requieren comprobaciones en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="fb09f-187">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="fb09f-188">Las conversiones de referencia, implícitas o explícitas, nunca cambian la identidad referencial del objeto que se va a convertir.</span><span class="sxs-lookup"><span data-stu-id="fb09f-188">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="fb09f-189">En otras palabras, aunque una conversión de referencia puede cambiar el tipo de la referencia, nunca cambia el tipo o valor del objeto al que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-189">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="fb09f-190">Conversiones Boxing</span><span class="sxs-lookup"><span data-stu-id="fb09f-190">Boxing conversions</span></span>

<span data-ttu-id="fb09f-191">Una conversión boxing permite que un *value_type* se convierta implícitamente en un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-191">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="fb09f-192">Existe una conversión boxing de cualquier *non_nullable_value_type* a `object` y `dynamic`, a `System.ValueType` y a cualquier *interface_type* implementado por el *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-192">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="fb09f-193">Además, un *enum_type* se puede convertir al tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-193">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="fb09f-194">Existe una conversión boxing de una *nullable_type* a un tipo de referencia, solo si existe una conversión boxing del *non_nullable_value_type* subyacente al tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-194">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="fb09f-195">Un tipo de valor tiene una conversión boxing a un tipo de interfaz `I` si tiene una conversión boxing a un tipo de interfaz `I0` y `I0` tiene una conversión de identidad en `I`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="fb09f-196">Un tipo de valor tiene una conversión boxing a un tipo de interfaz `I` si tiene una conversión boxing a un tipo de interfaz o delegado `I0` y `I0` es convertible por varianza ([conversión de varianza](interfaces.md#variance-conversion)) en `I`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-196">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="fb09f-197">La conversión boxing de un valor de una *non_nullable_value_type* consiste en asignar una instancia de objeto y copiar el valor de *value_type* en esa instancia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-197">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="fb09f-198">Se puede aplicar la conversión boxing a un struct al `System.ValueType`de tipos, ya que es una clase base para todos los Structs ([herencia](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-198">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="fb09f-199">La conversión boxing de un valor de una *nullable_type* procede de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="fb09f-199">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="fb09f-200">Si el valor de origen es null (`HasValue` propiedad es false), el resultado es una referencia nula del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-200">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="fb09f-201">De lo contrario, el resultado es una referencia a una `T` con conversión boxing generada al desempaquetar y aplicar la conversión boxing al valor de origen.</span><span class="sxs-lookup"><span data-stu-id="fb09f-201">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="fb09f-202">Las conversiones Boxing se describen con más detalle en [conversiones boxing](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="fb09f-202">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="fb09f-203">Conversiones dinámicas IMPLÍCITAS</span><span class="sxs-lookup"><span data-stu-id="fb09f-203">Implicit dynamic conversions</span></span>

<span data-ttu-id="fb09f-204">Existe una conversión dinámica implícita de una expresión de tipo `dynamic` a cualquier tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-204">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="fb09f-205">La conversión está enlazada dinámicamente ([enlace dinámico](expressions.md#dynamic-binding)), lo que significa que se buscará una conversión implícita en tiempo de ejecución desde el tipo en tiempo de ejecución de la expresión que se va a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-205">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="fb09f-206">Si no se encuentra ninguna conversión, se produce una excepción en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="fb09f-206">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="fb09f-207">Tenga en cuenta que esta conversión implícita aparentemente infringe el Consejo en el principio de las [conversiones implícitas](conversions.md#implicit-conversions) que una conversión implícita nunca debe producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="fb09f-207">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="fb09f-208">Sin embargo, no es la propia conversión, sino la *búsqueda* de la conversión que produce la excepción.</span><span class="sxs-lookup"><span data-stu-id="fb09f-208">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="fb09f-209">El riesgo de que se produzcan excepciones en tiempo de ejecución es inherente al uso del enlace dinámico.</span><span class="sxs-lookup"><span data-stu-id="fb09f-209">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="fb09f-210">Si no se desea el enlace dinámico de la conversión, la expresión se puede convertir primero en `object`y, a continuación, en el tipo deseado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-210">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="fb09f-211">En el ejemplo siguiente se muestran las conversiones dinámicas implícitas:</span><span class="sxs-lookup"><span data-stu-id="fb09f-211">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="fb09f-212">Las asignaciones a `s2` y `i` emplean conversiones dinámicas IMPLÍCITAS, donde el enlace de las operaciones se suspende hasta el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="fb09f-212">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="fb09f-213">En tiempo de ejecución, se buscan conversiones implícitas desde el tipo en tiempo de ejecución de `d` -- `string` al tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-213">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="fb09f-214">Se ha encontrado una conversión en `string` pero no `int`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-214">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="fb09f-215">Conversiones implícitas de expresiones constantes</span><span class="sxs-lookup"><span data-stu-id="fb09f-215">Implicit constant expression conversions</span></span>

<span data-ttu-id="fb09f-216">Una conversión de expresión constante implícita permite las siguientes conversiones:</span><span class="sxs-lookup"><span data-stu-id="fb09f-216">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="fb09f-217">Un *constant_expression* ([expresiones constantes](expressions.md#constant-expressions)) de tipo `int` se puede convertir al tipo `sbyte`, `byte`, `short`, `ushort`, `uint`o `ulong`, siempre que el valor de la *constant_expression* esté dentro del intervalo del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-217">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="fb09f-218">Un *constant_expression* de tipo `long` se puede convertir al tipo `ulong`, siempre que el valor de la *constant_expression* no sea negativo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-218">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="fb09f-219">Conversiones implícitas que implican parámetros de tipo</span><span class="sxs-lookup"><span data-stu-id="fb09f-219">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="fb09f-220">Existen las siguientes conversiones implícitas para un parámetro de tipo determinado `T`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-220">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="fb09f-221">Desde `T` a su clase base efectiva `C`, desde `T` a cualquier clase base de `C`y desde `T` a cualquier interfaz implementada por `C`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-221">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="fb09f-222">En tiempo de ejecución, si `T` es un tipo de valor, la conversión se ejecuta como conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-222">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="fb09f-223">De lo contrario, la conversión se ejecuta como una conversión de referencia implícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-223">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="fb09f-224">Desde `T` a un tipo de interfaz `I` en el conjunto de interfaz efectivo de `T`y de `T` a cualquier interfaz base de `I`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-224">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="fb09f-225">En tiempo de ejecución, si `T` es un tipo de valor, la conversión se ejecuta como conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-225">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="fb09f-226">De lo contrario, la conversión se ejecuta como una conversión de referencia implícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-226">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="fb09f-227">De `T` a un `U`de parámetro de tipo, proporcionado `T` depende de `U` ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-227">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="fb09f-228">En tiempo de ejecución, si `U` es un tipo de valor, `T` y `U` son necesariamente el mismo tipo y no se realiza ninguna conversión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-228">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="fb09f-229">De lo contrario, si `T` es un tipo de valor, la conversión se ejecuta como conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-229">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="fb09f-230">De lo contrario, la conversión se ejecuta como una conversión de referencia implícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-230">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="fb09f-231">Desde el literal null hasta `T`, se sabe que el `T` proporcionado es un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-231">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="fb09f-232">De `T` a un tipo de referencia `I` si tiene una conversión implícita a un tipo de referencia `S0` y `S0` tiene una conversión de identidad a `S`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-232">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="fb09f-233">En tiempo de ejecución, la conversión se ejecuta de la misma forma que la conversión en `S0`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-233">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="fb09f-234">De `T` a un tipo de interfaz `I` si tiene una conversión implícita a una interfaz o un tipo de delegado `I0` y `I0` se pueden convertir en `I` ([conversión de varianza](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-234">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="fb09f-235">En tiempo de ejecución, si `T` es un tipo de valor, la conversión se ejecuta como conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-235">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="fb09f-236">De lo contrario, la conversión se ejecuta como una conversión de referencia implícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-236">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="fb09f-237">Si se sabe que `T` es un tipo de referencia ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)), las conversiones anteriores se clasifican como conversiones de referencia IMPLÍCITAS ([conversiones de referencia implícita](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-237">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="fb09f-238">Si no se sabe que `T` es un tipo de referencia, las conversiones anteriores se clasifican como conversiones Boxing (conversiones[Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-238">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="fb09f-239">Conversiones implícitas definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-239">User-defined implicit conversions</span></span>

<span data-ttu-id="fb09f-240">Una conversión implícita definida por el usuario se compone de una conversión implícita estándar opcional, seguida de una ejecución de un operador de conversión implícita definido por el usuario, seguida de otra conversión implícita estándar opcional.</span><span class="sxs-lookup"><span data-stu-id="fb09f-240">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="fb09f-241">Las reglas exactas para evaluar las conversiones implícitas definidas por el usuario se describen en [procesamiento de conversiones implícitas definidas por el usuario](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="fb09f-241">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="fb09f-242">Conversiones de funciones anónimas y conversiones de grupos de métodos</span><span class="sxs-lookup"><span data-stu-id="fb09f-242">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="fb09f-243">Las funciones anónimas y los grupos de métodos no tienen tipos en y, pero se pueden convertir implícitamente en tipos de delegado o tipos de árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-243">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="fb09f-244">Las conversiones de función anónima se describen con más detalle en conversiones de [funciones anónimas](conversions.md#anonymous-function-conversions) y conversiones de grupos de métodos en [conversiones de grupos de métodos](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="fb09f-244">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="fb09f-245">Conversiones explícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-245">Explicit conversions</span></span>

<span data-ttu-id="fb09f-246">Las conversiones siguientes se clasifican como conversiones explícitas:</span><span class="sxs-lookup"><span data-stu-id="fb09f-246">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="fb09f-247">Todas las conversiones implícitas.</span><span class="sxs-lookup"><span data-stu-id="fb09f-247">All implicit conversions.</span></span>
*  <span data-ttu-id="fb09f-248">Conversiones numéricas explícitas.</span><span class="sxs-lookup"><span data-stu-id="fb09f-248">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="fb09f-249">Conversiones de enumeración explícitas.</span><span class="sxs-lookup"><span data-stu-id="fb09f-249">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="fb09f-250">Conversiones explícitas que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="fb09f-250">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="fb09f-251">Conversiones de referencia explícitas.</span><span class="sxs-lookup"><span data-stu-id="fb09f-251">Explicit reference conversions.</span></span>
*  <span data-ttu-id="fb09f-252">Conversiones explícitas de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="fb09f-252">Explicit interface conversions.</span></span>
*  <span data-ttu-id="fb09f-253">Conversiones unboxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-253">Unboxing conversions.</span></span>
*  <span data-ttu-id="fb09f-254">Conversiones dinámicas explícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-254">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="fb09f-255">Conversiones explícitas definidas por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-255">User-defined explicit conversions.</span></span>

<span data-ttu-id="fb09f-256">Las conversiones explícitas pueden producirse en expresiones de conversión ([expresiones de conversión](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-256">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="fb09f-257">El conjunto de conversiones explícitas incluye todas las conversiones implícitas.</span><span class="sxs-lookup"><span data-stu-id="fb09f-257">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="fb09f-258">Esto significa que se permiten expresiones de conversión redundantes.</span><span class="sxs-lookup"><span data-stu-id="fb09f-258">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="fb09f-259">Las conversiones explícitas que no son conversiones implícitas son conversiones que no se pueden demostrar que siempre se realizan correctamente, conversiones en las que se sabe que podrían perder información y conversiones entre dominios de tipos lo suficientemente diferentes como para méritos explícitos. notación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-259">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="fb09f-260">Conversiones numéricas explícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-260">Explicit numeric conversions</span></span>

<span data-ttu-id="fb09f-261">Las conversiones numéricas explícitas son las conversiones de un *numeric_type* a otro *numeric_type* para el que no existe una conversión numérica implícita ([Conversiones numéricas implícitas](conversions.md#implicit-numeric-conversions)):</span><span class="sxs-lookup"><span data-stu-id="fb09f-261">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="fb09f-262">De `sbyte` a `byte`, `ushort`, `uint`, `ulong`o `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-262">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="fb09f-263">De `byte` a `sbyte` y `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-263">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="fb09f-264">De `short` a `sbyte`, `byte`, `ushort`, `uint`, `ulong`o `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-264">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="fb09f-265">De `ushort` a `sbyte`, `byte`, `short`o `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-265">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="fb09f-266">De `int` a `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`o `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-266">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="fb09f-267">De `uint` a `sbyte`, `byte`, `short`, `ushort`, `int`o `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-267">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="fb09f-268">De `long` a `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`o `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-268">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="fb09f-269">De `ulong` a `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`o `char`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-269">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="fb09f-270">De `char` a `sbyte`, `byte`o `short`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-270">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="fb09f-271">De `float` a `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-271">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-272">De `double` a `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-272">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-273">De `decimal` a `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`o `double`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-273">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="fb09f-274">Dado que las conversiones explícitas incluyen todas las conversiones numéricas implícitas y explícitas, siempre es posible convertir de cualquier *numeric_type* a cualquier otra *numeric_type* mediante una expresión de conversión ([expresiones de conversión](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-274">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="fb09f-275">Las conversiones numéricas explícitas podrían perder información o provocar que se produzcan excepciones.</span><span class="sxs-lookup"><span data-stu-id="fb09f-275">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="fb09f-276">Una conversión numérica explícita se procesa de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="fb09f-276">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="fb09f-277">En el caso de una conversión de un tipo entero a otro tipo entero, el procesamiento depende del contexto de comprobación de desbordamiento ([los operadores comprobados y sin comprobar](expressions.md#the-checked-and-unchecked-operators)) en el que tiene lugar la conversión:</span><span class="sxs-lookup"><span data-stu-id="fb09f-277">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="fb09f-278">En un contexto de `checked`, la conversión se realiza correctamente si el valor del operando de origen está dentro del intervalo del tipo de destino, pero produce una `System.OverflowException` si el valor del operando de origen está fuera del intervalo del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-278">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="fb09f-279">En un contexto de `unchecked`, la conversión siempre se realiza correctamente y continúa como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-279">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="fb09f-280">Si el tipo de origen es mayor que el tipo de destino, el valor de origen se trunca al descartar sus bits "extra" más significativos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-280">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="fb09f-281">El resultado se trata como un valor del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-281">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="fb09f-282">Si el tipo de origen es menor que el tipo de destino, el valor de origen se amplía mediante signos o ceros para que tenga el mismo tamaño que el tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-282">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="fb09f-283">La ampliación mediante signos se usa si el tipo de origen tiene signo; se emplea ampliación mediante ceros si el tipo de origen no tiene signo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-283">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="fb09f-284">El resultado se trata como un valor del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-284">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="fb09f-285">Si el tipo de origen es del mismo tamaño que el tipo de destino, el valor de origen se trata como un valor del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-285">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="fb09f-286">Para una conversión de `decimal` a un tipo entero, el valor de origen se redondea hacia cero al valor entero más cercano, y este valor entero se convierte en el resultado de la conversión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-286">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="fb09f-287">Si el valor entero resultante está fuera del intervalo del tipo de destino, se produce una `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-287">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="fb09f-288">Para una conversión desde `float` o `double` a un tipo entero, el procesamiento depende del contexto de comprobación de desbordamiento ([los operadores comprobados y sin comprobar](expressions.md#the-checked-and-unchecked-operators)) en el que tiene lugar la conversión:</span><span class="sxs-lookup"><span data-stu-id="fb09f-288">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="fb09f-289">En un contexto de `checked`, la conversión se realiza de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="fb09f-289">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="fb09f-290">Si el valor del operando es NaN o infinito, se produce una `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-290">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="fb09f-291">De lo contrario, el operando de origen se redondea hacia cero al valor entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="fb09f-291">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="fb09f-292">Si este valor entero está dentro del intervalo del tipo de destino, este valor es el resultado de la conversión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-292">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="fb09f-293">De lo contrario, se produce una excepción `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-293">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="fb09f-294">En un contexto de `unchecked`, la conversión siempre se realiza correctamente y continúa como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-294">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="fb09f-295">Si el valor del operando es NaN o infinito, el resultado de la conversión es un valor no especificado del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-295">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="fb09f-296">De lo contrario, el operando de origen se redondea hacia cero al valor entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="fb09f-296">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="fb09f-297">Si este valor entero está dentro del intervalo del tipo de destino, este valor es el resultado de la conversión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-297">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="fb09f-298">De lo contrario, el resultado de la conversión es un valor no especificado del tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-298">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="fb09f-299">Para una conversión desde `double` a `float`, el valor de `double` se redondea al valor de `float` más próximo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-299">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="fb09f-300">Si el valor de `double` es demasiado pequeño para representarlo como un `float`, el resultado es cero positivo o cero negativo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-300">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="fb09f-301">Si el valor de `double` es demasiado grande para representarlo como un `float`, el resultado se convierte en infinito positivo o infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-301">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="fb09f-302">Si el valor de `double` es NaN, el resultado es también NaN.</span><span class="sxs-lookup"><span data-stu-id="fb09f-302">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="fb09f-303">Para una conversión desde `float` o `double` a `decimal`, el valor de origen se convierte en `decimal` representación y se redondea al número más cercano después de la posición decimal 28 si es necesario ([el tipo decimal](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-303">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="fb09f-304">Si el valor de origen es demasiado pequeño para representarlo como `decimal`, el resultado es cero.</span><span class="sxs-lookup"><span data-stu-id="fb09f-304">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="fb09f-305">Si el valor de origen es NaN, infinito o demasiado grande para representarse como `decimal`, se produce una `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-305">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="fb09f-306">Para realizar una conversión de `decimal` a `float` o `double`, el valor `decimal` se redondea al valor `double` o `float` más próximo.</span><span class="sxs-lookup"><span data-stu-id="fb09f-306">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="fb09f-307">Aunque esta conversión puede perder precisión, nunca provoca que se produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="fb09f-307">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="fb09f-308">Conversiones explícitas de enumeración</span><span class="sxs-lookup"><span data-stu-id="fb09f-308">Explicit enumeration conversions</span></span>

<span data-ttu-id="fb09f-309">Las conversiones de enumeración explícitas son:</span><span class="sxs-lookup"><span data-stu-id="fb09f-309">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="fb09f-310">Desde `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`o `decimal` a cualquier *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-310">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="fb09f-311">Desde cualquier *enum_type* a `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-311">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="fb09f-312">Desde cualquier *enum_type* a cualquier otro *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-312">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="fb09f-313">Una conversión de enumeración explícita entre dos tipos se procesa tratando cualquier *enum_type* participante como el tipo subyacente de ese *enum_type*y, a continuación, realizando una conversión numérica implícita o explícita entre los tipos resultantes.</span><span class="sxs-lookup"><span data-stu-id="fb09f-313">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="fb09f-314">Por ejemplo, dado un *enum_type* `E` con y el tipo subyacente de `int`, una conversión de `E` a `byte` se procesa como una conversión numérica explícita ([Conversiones numéricas explícitas](conversions.md#explicit-numeric-conversions)) de `int` a `byte`, y una conversión de `byte` a `E` se procesa como una conversión numérica implícita ([Conversiones numéricas implícitas](conversions.md#implicit-numeric-conversions)) de `byte` a `int`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-314">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="fb09f-315">Conversiones explícitas que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="fb09f-315">Explicit nullable conversions</span></span>

<span data-ttu-id="fb09f-316">Las ***conversiones explícitas que aceptan valores NULL*** permiten conversiones explícitas explícitas que operan en tipos de valor que no aceptan valores NULL para usarse también con formas que aceptan valores NULL de esos tipos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-316">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="fb09f-317">Para cada una de las conversiones explícitas predefinidas que convierten de un tipo de valor que no acepta valores NULL `S` a un tipo de valor que no acepta valores NULL `T` ([conversión de identidad](conversions.md#identity-conversion), [Conversiones numéricas implícitas](conversions.md#implicit-numeric-conversions), conversiones de [enumeración implícita](conversions.md#implicit-enumeration-conversions), [Conversiones numéricas explícitas](conversions.md#explicit-numeric-conversions)y [conversiones de enumeración explícita](conversions.md#explicit-enumeration-conversions)), existen las siguientes conversiones que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="fb09f-317">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="fb09f-318">Conversión explícita de `S?` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-318">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="fb09f-319">Conversión explícita de `S` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-319">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="fb09f-320">Conversión explícita de `S?` en `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-320">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="fb09f-321">La evaluación de una conversión que acepta valores NULL en función de una conversión subyacente de `S` a `T` continúa de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="fb09f-321">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="fb09f-322">Si la conversión que acepta valores NULL es de `S?` a `T?`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-322">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="fb09f-323">Si el valor de origen es null (`HasValue` propiedad es false), el resultado es el valor null de tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-323">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="fb09f-324">De lo contrario, la conversión se evalúa como un desencapsulado de `S?` a `S`, seguido de la conversión subyacente de `S` a `T`, seguido de un ajuste de `T` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-324">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="fb09f-325">Si la conversión que acepta valores NULL es de `S` a `T?`, la conversión se evalúa como la conversión subyacente de `S` a `T` seguido de un ajuste de `T` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-325">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="fb09f-326">Si la conversión que acepta valores NULL es de `S?` a `T`, la conversión se evalúa como un desencapsulado de `S?` a `S` seguido de la conversión subyacente de `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-326">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="fb09f-327">Tenga en cuenta que un intento de desencapsular un valor que acepta valores null producirá una excepción si el valor es `null`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-327">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="fb09f-328">Conversiones de referencia explícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-328">Explicit reference conversions</span></span>

<span data-ttu-id="fb09f-329">Las conversiones de referencia explícitas son:</span><span class="sxs-lookup"><span data-stu-id="fb09f-329">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="fb09f-330">Desde `object` y `dynamic` a cualquier otro *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-330">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="fb09f-331">Desde cualquier *class_type* `S` a cualquier `T`de *class_type* , proporcionado `S` es una clase base de `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-331">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="fb09f-332">De cualquier *class_type* `S` a cualquier `T`de *interface_type* , se proporciona `S` no se sella y se proporciona `S` no implementa `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-332">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="fb09f-333">Desde cualquier `S` de *interface_type* a cualquier `T`de *class_type* , se proporciona `T` que no está sellada ni se proporciona `T` implementa `S`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-333">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="fb09f-334">Desde cualquier *interface_type* `S` a cualquier `T`de *interface_type* , proporcionado `S` no se deriva de `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-334">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="fb09f-335">A partir de un `S` de *array_type* con un tipo de elemento `SE` a un `T` de *array_type* con un tipo de elemento `TE`, siempre que se cumplan todas las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="fb09f-335">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="fb09f-336">`S` y `T` solo difieren en el tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="fb09f-336">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="fb09f-337">En otras palabras, `S` y `T` tienen el mismo número de dimensiones.</span><span class="sxs-lookup"><span data-stu-id="fb09f-337">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="fb09f-338">Tanto `SE` como `TE` son *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="fb09f-338">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="fb09f-339">Existe una conversión de referencia explícita de `SE` a `TE`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-339">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="fb09f-340">Desde `System.Array` y las interfaces que implementa en cualquier *array_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-340">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="fb09f-341">Desde un tipo de matriz unidimensional `S[]` a `System.Collections.Generic.IList<T>` y sus interfaces base, siempre que haya una conversión de referencia explícita de `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-341">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="fb09f-342">Desde `System.Collections.Generic.IList<S>` y sus interfaces base a un tipo de matriz unidimensional `T[]`, siempre que haya una conversión explícita de identidad o de referencia de `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-342">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="fb09f-343">Desde `System.Delegate` y las interfaces que implementa en cualquier *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-343">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="fb09f-344">Desde un tipo de referencia a un tipo de referencia `T` si tiene una conversión de referencia explícita a un tipo de referencia `T0` y `T0` tiene un `T`de conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-344">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="fb09f-345">Desde un tipo de referencia a un tipo de interfaz o delegado `T` si tiene una conversión de referencia explícita a una interfaz o un tipo de delegado `T0` y `T0` se puede convertir en `T` o `T` de varianza a `T0` ([conversión de varianza](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-345">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="fb09f-346">De `D<S1...Sn>` a `D<T1...Tn>` donde `D<X1...Xn>` es un tipo de delegado genérico, `D<S1...Sn>` no es compatible con o es idéntico a `D<T1...Tn>`, y para cada parámetro de tipo `Xi` de `D` las siguientes:</span><span class="sxs-lookup"><span data-stu-id="fb09f-346">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="fb09f-347">Si `Xi` es invariable, `Si` es idéntica a `Ti`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-347">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="fb09f-348">Si `Xi` es covariante, hay una conversión implícita o explícita o una conversión de referencia de `Si` a `Ti`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-348">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="fb09f-349">Si `Xi` es contravariante, `Si` y `Ti` son idénticos o ambos tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-349">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="fb09f-350">Conversiones explícitas que implican parámetros de tipo que se sabe que son tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-350">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="fb09f-351">Para obtener más información sobre las conversiones explícitas que implican parámetros de tipo, vea [conversiones explícitas que implican parámetros de tipo](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="fb09f-351">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="fb09f-352">Las conversiones de referencia explícitas son esas conversiones entre los tipos de referencia que requieren comprobaciones en tiempo de ejecución para asegurarse de que son correctas.</span><span class="sxs-lookup"><span data-stu-id="fb09f-352">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="fb09f-353">Para que una conversión de referencia explícita se realice correctamente en tiempo de ejecución, el valor del operando de origen debe ser `null`, o el tipo real del objeto al que hace referencia el operando de origen debe ser un tipo que se pueda convertir al tipo de destino mediante una conversión de referencia implícita ([conversiones de referencia implícita](conversions.md#implicit-reference-conversions)) o una conversión boxing ([conversiones boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-353">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="fb09f-354">Si se produce un error en una conversión de referencia explícita, se produce una `System.InvalidCastException`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-354">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="fb09f-355">Las conversiones de referencia, implícitas o explícitas, nunca cambian la identidad referencial del objeto que se va a convertir.</span><span class="sxs-lookup"><span data-stu-id="fb09f-355">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="fb09f-356">En otras palabras, aunque una conversión de referencia puede cambiar el tipo de la referencia, nunca cambia el tipo o valor del objeto al que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-356">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="fb09f-357">Conversiones unboxing</span><span class="sxs-lookup"><span data-stu-id="fb09f-357">Unboxing conversions</span></span>

<span data-ttu-id="fb09f-358">Una conversión unboxing permite que un tipo de referencia se convierta explícitamente en un *value_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-358">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="fb09f-359">Existe una conversión unboxing de los tipos `object`, `dynamic` y `System.ValueType` a cualquier *non_nullable_value_type*y de cualquier *interface_type* a cualquier *non_nullable_value_type* que implemente el *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-359">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="fb09f-360">Además, se puede aplicar la conversión unboxing a `System.Enum` de tipos a cualquier *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-360">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="fb09f-361">Existe una conversión unboxing de un tipo de referencia a un *nullable_type* si existe una conversión unboxing del tipo de referencia al *non_nullable_value_type* subyacente de la *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-361">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="fb09f-362">Un tipo de valor `S` tiene una conversión unboxing de un tipo de interfaz `I` si tiene una conversión unboxing de un tipo de interfaz `I0` y `I0` tiene una conversión de identidad en `I`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="fb09f-363">Un tipo de valor `S` tiene una conversión unboxing de un tipo de interfaz `I` si tiene una conversión unboxing de una interfaz o de un tipo de delegado `I0` y `I0` es la varianza que se puede convertir en `I` o `I` es una varianza que se puede convertir en `I0` ([conversión de varianza](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-363">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="fb09f-364">Una operación de conversión unboxing consiste en comprobar primero que la instancia de objeto es un valor de conversión boxing del *value_type*especificado y, a continuación, copiar el valor fuera de la instancia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-364">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="fb09f-365">Al aplicar la conversión unboxing a una referencia nula a un *nullable_type* , se genera el valor null de la *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-365">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="fb09f-366">Se puede aplicar la conversión unboxing a un struct del tipo `System.ValueType`, ya que es una clase base para todos los Structs ([herencia](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-366">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="fb09f-367">Las conversiones unboxing se describen con más detalle en [conversiones unboxing](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="fb09f-367">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="fb09f-368">Conversiones dinámicas explícitas</span><span class="sxs-lookup"><span data-stu-id="fb09f-368">Explicit dynamic conversions</span></span>

<span data-ttu-id="fb09f-369">Existe una conversión dinámica explícita de una expresión de tipo `dynamic` a cualquier tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-369">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="fb09f-370">La conversión está enlazada dinámicamente ([enlace dinámico](expressions.md#dynamic-binding)), lo que significa que se buscará una conversión explícita en tiempo de ejecución desde el tipo en tiempo de ejecución de la expresión que se va a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-370">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="fb09f-371">Si no se encuentra ninguna conversión, se produce una excepción en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="fb09f-371">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="fb09f-372">Si no se desea el enlace dinámico de la conversión, la expresión se puede convertir primero en `object`y, a continuación, en el tipo deseado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-372">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="fb09f-373">Supongamos que se define la clase siguiente:</span><span class="sxs-lookup"><span data-stu-id="fb09f-373">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="fb09f-374">En el ejemplo siguiente se muestran las conversiones dinámicas explícitas:</span><span class="sxs-lookup"><span data-stu-id="fb09f-374">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="fb09f-375">La mejor conversión de `o` en `C` se encuentra en tiempo de compilación para que sea una conversión de referencia explícita.</span><span class="sxs-lookup"><span data-stu-id="fb09f-375">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="fb09f-376">Esto produce un error en tiempo de ejecución, porque `"1"` no es en realidad una `C`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-376">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="fb09f-377">La conversión de `d` en `C` sin embargo, como una conversión dinámica explícita, se suspende en tiempo de ejecución, donde se encuentra una conversión definida por el usuario del tipo en tiempo de ejecución de `d` -- `string`--hasta `C` y se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-377">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="fb09f-378">Conversiones explícitas que implican parámetros de tipo</span><span class="sxs-lookup"><span data-stu-id="fb09f-378">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="fb09f-379">Existen las siguientes conversiones explícitas para un parámetro de tipo determinado `T`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-379">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="fb09f-380">Desde la clase base efectiva `C` de `T` a `T` y de cualquier clase base de `C` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-380">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="fb09f-381">En tiempo de ejecución, si `T` es un tipo de valor, la conversión se ejecuta como conversión unboxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-381">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="fb09f-382">De lo contrario, la conversión se ejecuta como una conversión de referencia explícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-382">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="fb09f-383">De cualquier tipo de interfaz que se va a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-383">From any interface type to `T`.</span></span> <span data-ttu-id="fb09f-384">En tiempo de ejecución, si `T` es un tipo de valor, la conversión se ejecuta como conversión unboxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-384">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="fb09f-385">De lo contrario, la conversión se ejecuta como una conversión de referencia explícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-385">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="fb09f-386">De `T` a cualquier *interface_type* `I` siempre y cuando no haya una conversión implícita de `T` a `I`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-386">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="fb09f-387">En tiempo de ejecución, si `T` es un tipo de valor, la conversión se ejecuta como una conversión boxing seguida de una conversión de referencia explícita.</span><span class="sxs-lookup"><span data-stu-id="fb09f-387">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="fb09f-388">De lo contrario, la conversión se ejecuta como una conversión de referencia explícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-388">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="fb09f-389">De un parámetro de tipo `U` a `T`, siempre y cuando `T` dependa de `U` ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-389">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="fb09f-390">En tiempo de ejecución, si `U` es un tipo de valor, `T` y `U` son necesariamente el mismo tipo y no se realiza ninguna conversión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-390">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="fb09f-391">De lo contrario, si `T` es un tipo de valor, la conversión se ejecuta como conversión unboxing.</span><span class="sxs-lookup"><span data-stu-id="fb09f-391">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="fb09f-392">De lo contrario, la conversión se ejecuta como una conversión de referencia explícita o una conversión de identidad.</span><span class="sxs-lookup"><span data-stu-id="fb09f-392">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="fb09f-393">Si se sabe que `T` es un tipo de referencia, las conversiones anteriores se clasifican como conversiones de referencia explícitas ([conversiones de referencia explícita](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-393">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="fb09f-394">Si no se sabe que `T` es un tipo de referencia, las conversiones anteriores se clasifican como conversiones unboxing (conversiones[unboxing](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-394">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="fb09f-395">Las reglas anteriores no permiten una conversión explícita directa de un parámetro de tipo sin restricciones a un tipo que no sea de interfaz, lo que podría ser sorprendente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-395">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="fb09f-396">La razón de esta regla es evitar la confusión y hacer que la semántica de dichas conversiones sea clara.</span><span class="sxs-lookup"><span data-stu-id="fb09f-396">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="fb09f-397">Por ejemplo, consideremos la siguiente declaración:</span><span class="sxs-lookup"><span data-stu-id="fb09f-397">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="fb09f-398">Si se permitía la conversión directa explícita de `t` a `int`, es posible que se espere fácilmente que `X<int>.F(7)` devuelva `7L`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-398">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="fb09f-399">Sin embargo, no lo haría, porque las conversiones numéricas estándar solo se tienen en cuenta cuando se sabe que los tipos son numéricos en tiempo de enlace.</span><span class="sxs-lookup"><span data-stu-id="fb09f-399">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="fb09f-400">Para que la semántica esté clara, en su lugar se debe escribir en el ejemplo anterior:</span><span class="sxs-lookup"><span data-stu-id="fb09f-400">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="fb09f-401">Este código se compilará ahora, pero la ejecución de `X<int>.F(7)` producirá una excepción en tiempo de ejecución, ya que no se puede convertir directamente un `int` con conversión boxing en un `long`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-401">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="fb09f-402">Conversiones explícitas definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-402">User-defined explicit conversions</span></span>

<span data-ttu-id="fb09f-403">Una conversión explícita definida por el usuario se compone de una conversión explícita estándar opcional, seguida de una ejecución de un operador de conversión implícito o explícito definido por el usuario, seguida de otra conversión explícita estándar opcional.</span><span class="sxs-lookup"><span data-stu-id="fb09f-403">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="fb09f-404">Las reglas exactas para evaluar las conversiones explícitas definidas por el usuario se describen en [procesamiento de conversiones explícitas definidas por el usuario](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="fb09f-404">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="fb09f-405">Conversiones estándar</span><span class="sxs-lookup"><span data-stu-id="fb09f-405">Standard conversions</span></span>

<span data-ttu-id="fb09f-406">Las conversiones estándar son las conversiones predefinidas que pueden producirse como parte de una conversión definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-406">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="fb09f-407">Conversiones implícitas estándar</span><span class="sxs-lookup"><span data-stu-id="fb09f-407">Standard implicit conversions</span></span>

<span data-ttu-id="fb09f-408">Las siguientes conversiones implícitas se clasifican como conversiones implícitas estándar:</span><span class="sxs-lookup"><span data-stu-id="fb09f-408">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="fb09f-409">Conversiones de identidad ([conversión de identidad](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="fb09f-409">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="fb09f-410">Conversiones numéricas IMPLÍCITAS ([Conversiones numéricas implícitas](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="fb09f-410">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="fb09f-411">Conversiones implícitas que aceptan valores NULL ([conversiones implícitas que aceptan valores NULL](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="fb09f-411">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="fb09f-412">Conversiones de referencia IMPLÍCITAS ([conversiones de referencia implícitas](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="fb09f-412">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="fb09f-413">Conversiones Boxing ([conversiones boxing](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="fb09f-413">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="fb09f-414">Conversiones implícitas de expresiones constantes ([conversiones dinámicas implícitas](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="fb09f-414">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="fb09f-415">Conversiones implícitas que implican parámetros de tipo ([conversiones implícitas que implican parámetros de tipo](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="fb09f-415">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="fb09f-416">Las conversiones implícitas estándar excluyen específicamente las conversiones implícitas definidas por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-416">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="fb09f-417">Conversiones explícitas estándar</span><span class="sxs-lookup"><span data-stu-id="fb09f-417">Standard explicit conversions</span></span>

<span data-ttu-id="fb09f-418">Las conversiones explícitas estándar son todas las conversiones implícitas estándar más el subconjunto de las conversiones explícitas para las que existe una conversión implícita estándar opuesta.</span><span class="sxs-lookup"><span data-stu-id="fb09f-418">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="fb09f-419">En otras palabras, si existe una conversión implícita estándar de un tipo `A` a un tipo `B`, existe una conversión explícita estándar del tipo `A` al tipo `B` y del tipo `B` al tipo `A`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-419">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="fb09f-420">Conversiones definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-420">User-defined conversions</span></span>

<span data-ttu-id="fb09f-421">C#permite aumentar las conversiones implícitas y explícitas predefinidas mediante ***conversiones definidas por el usuario***.</span><span class="sxs-lookup"><span data-stu-id="fb09f-421">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="fb09f-422">Las conversiones definidas por el usuario se introducen mediante la declaración de operadores de conversión ([operadores de conversión](classes.md#conversion-operators)) en tipos de clase y estructura.</span><span class="sxs-lookup"><span data-stu-id="fb09f-422">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="fb09f-423">Conversiones permitidas definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-423">Permitted user-defined conversions</span></span>

<span data-ttu-id="fb09f-424">C#permite declarar solo determinadas conversiones definidas por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-424">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="fb09f-425">En concreto, no es posible volver a definir una conversión implícita o explícita ya existente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-425">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="fb09f-426">Para un tipo de origen determinado `S` y el tipo de destino `T`, si `S` o `T` son tipos que aceptan valores NULL, permita que `S0` y `T0` hagan referencia a sus tipos subyacentes; de lo contrario, `S0` y `T0` son iguales a `S` y `T` respectivamente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-426">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="fb09f-427">Una clase o struct puede declarar una conversión de un tipo de origen `S` a un tipo de destino `T` solo si se cumplen todas las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="fb09f-427">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="fb09f-428">`S0` y `T0` son tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="fb09f-428">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="fb09f-429">`S0` o `T0` es el tipo de clase o estructura en el que tiene lugar la declaración del operador.</span><span class="sxs-lookup"><span data-stu-id="fb09f-429">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="fb09f-430">Ni `S0` ni `T0` es una *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="fb09f-430">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="fb09f-431">Sin incluir las conversiones definidas por el usuario, no existe una conversión de `S` a `T` o de `T` a `S`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-431">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="fb09f-432">Las restricciones que se aplican a las conversiones definidas por el usuario se explican en los [operadores de conversión](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="fb09f-432">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="fb09f-433">Operadores de conversión de elevación</span><span class="sxs-lookup"><span data-stu-id="fb09f-433">Lifted conversion operators</span></span>

<span data-ttu-id="fb09f-434">Dado un operador de conversión definido por el usuario que convierte de un tipo de valor que no acepta valores NULL `S` a un tipo de valor que no acepta valores NULL `T`, existe un ***operador de conversión de elevación*** que convierte `S?` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-434">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="fb09f-435">Este operador de conversión de elevación realiza un desajuste de `S?` a `S` seguido de la conversión definida por el usuario de `S` a `T` seguido de un ajuste de `T` a `T?`, salvo que un valor null `S?` convierte directamente en una `T?`con valores NULL.</span><span class="sxs-lookup"><span data-stu-id="fb09f-435">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="fb09f-436">Un operador de conversión de elevación tiene la misma clasificación implícita o explícita que su operador de conversión definido por el usuario subyacente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-436">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="fb09f-437">El término "conversión definida por el usuario" se aplica al uso de operadores de conversión definidos por el usuario y de elevación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-437">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="fb09f-438">Evaluación de conversiones definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-438">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="fb09f-439">Una conversión definida por el usuario convierte un valor de su tipo, denominado ***tipo de origen***, a otro tipo, denominado ***tipo de destino***.</span><span class="sxs-lookup"><span data-stu-id="fb09f-439">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="fb09f-440">La evaluación de una conversión definida por el usuario se centra en buscar el operador de conversión definido por el usuario ***más específico*** para los tipos de origen y de destino determinados.</span><span class="sxs-lookup"><span data-stu-id="fb09f-440">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="fb09f-441">Esta determinación se divide en varios pasos:</span><span class="sxs-lookup"><span data-stu-id="fb09f-441">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="fb09f-442">Buscar el conjunto de clases y estructuras desde las que se considerarán los operadores de conversión definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-442">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="fb09f-443">Este conjunto está formado por el tipo de origen y sus clases base, así como el tipo de destino y sus clases base (con suposiciones implícitas de que solo las clases y los Structs pueden declarar operadores definidos por el usuario, y que los tipos que no son de clase no tienen clases base).</span><span class="sxs-lookup"><span data-stu-id="fb09f-443">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="fb09f-444">Para los fines de este paso, si el tipo de origen o de destino es un *nullable_type*, se utiliza en su lugar su tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-444">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="fb09f-445">A partir de ese conjunto de tipos, determinar qué operadores de conversión definidos por el usuario y de elevación son aplicables.</span><span class="sxs-lookup"><span data-stu-id="fb09f-445">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="fb09f-446">Para que un operador de conversión sea aplicable, debe ser posible realizar una conversión estándar ([conversiones estándar](conversions.md#standard-conversions)) del tipo de origen al tipo de operando del operador, y debe ser posible realizar una conversión estándar del tipo de resultado del operador al tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-446">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="fb09f-447">Del conjunto de operadores definidos por el usuario aplicables, que determinan qué operador es el más específico de forma inequívoca.</span><span class="sxs-lookup"><span data-stu-id="fb09f-447">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="fb09f-448">En términos generales, el operador más específico es el operador cuyo tipo de operando es "más cercano" al tipo de origen y cuyo tipo de resultado es "más cercano" al tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-448">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="fb09f-449">Los operadores de conversión definidos por el usuario son preferibles a los operadores de conversión de elevación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-449">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="fb09f-450">En las secciones siguientes se definen las reglas exactas para establecer el operador de conversión definido por el usuario más específico.</span><span class="sxs-lookup"><span data-stu-id="fb09f-450">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="fb09f-451">Una vez que se ha identificado un operador de conversión definido por el usuario más específico, la ejecución real de la conversión definida por el usuario implica hasta tres pasos:</span><span class="sxs-lookup"><span data-stu-id="fb09f-451">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="fb09f-452">En primer lugar, si es necesario, realizar una conversión estándar del tipo de origen al tipo de operando del operador de conversión definido por el usuario o de elevación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-452">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="fb09f-453">A continuación, se invoca el operador de conversión definido por el usuario o de elevación para realizar la conversión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-453">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="fb09f-454">Por último, si es necesario, realizar una conversión estándar del tipo de resultado del operador de conversión definido por el usuario o de elevación al tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-454">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="fb09f-455">La evaluación de una conversión definida por el usuario nunca implica más de un operador de conversión definido por el usuario o de elevación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-455">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="fb09f-456">En otras palabras, una conversión del tipo `S` al tipo `T` nunca ejecutará en primer lugar una conversión definida por el usuario de `S` a `X` y, a continuación, ejecutará una conversión definida por el usuario de `X` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-456">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="fb09f-457">En las secciones siguientes se proporcionan definiciones exactas de la evaluación de las conversiones implícitas o explícitas definidas por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-457">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="fb09f-458">Las definiciones hacen uso de los siguientes términos:</span><span class="sxs-lookup"><span data-stu-id="fb09f-458">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="fb09f-459">Si existe una conversión implícita estándar ([conversiones implícitas estándar](conversions.md#standard-implicit-conversions)) de un tipo `A` a un tipo `B`, y si ninguna `A` ni `B` se *interface_type*s, se dice que `A` se ***incluye*** en `B`y `B` se dice que ***abarca*** `A`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-459">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="fb09f-460">El ***tipo más abarcado*** en un conjunto de tipos es el que abarca todos los demás tipos del conjunto.</span><span class="sxs-lookup"><span data-stu-id="fb09f-460">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="fb09f-461">Si no hay ningún tipo único que abarque todos los demás tipos, el conjunto no tiene más tipo de englobado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-461">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="fb09f-462">En términos más intuitivos, el tipo más amplio es el tipo "mayor" del conjunto (el tipo al que se puede convertir cada uno de los demás tipos de forma implícita).</span><span class="sxs-lookup"><span data-stu-id="fb09f-462">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="fb09f-463">El ***tipo más abarcado*** en un conjunto de tipos es el que se incluye en todos los demás tipos del conjunto.</span><span class="sxs-lookup"><span data-stu-id="fb09f-463">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="fb09f-464">Si no hay ningún tipo único incluido en el resto de tipos, el conjunto no tiene el tipo más abarcado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-464">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="fb09f-465">En términos más intuitivos, el tipo más abarcado es el tipo "más pequeño" del conjunto (el tipo que se puede convertir implícitamente en cada uno de los demás tipos).</span><span class="sxs-lookup"><span data-stu-id="fb09f-465">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="fb09f-466">Procesamiento de conversiones implícitas definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-466">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="fb09f-467">Una conversión implícita definida por el usuario del tipo `S` al tipo `T` se procesa de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="fb09f-467">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="fb09f-468">Determine los tipos `S0` y `T0`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-468">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="fb09f-469">Si `S` o `T` son tipos que aceptan valores NULL, `S0` y `T0` son sus tipos subyacentes; de lo contrario, `S0` y `T0` son iguales a `S` y `T` respectivamente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-469">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="fb09f-470">Busque el conjunto de tipos, `D`, desde el que se tendrán en cuenta los operadores de conversión definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-470">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="fb09f-471">Este conjunto consta de `S0` (si `S0` es una clase o estructura), las clases base de `S0` (si `S0` es una clase) y `T0` (si `T0` es una clase o struct).</span><span class="sxs-lookup"><span data-stu-id="fb09f-471">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="fb09f-472">Busque el conjunto de operadores de conversión de elevación y definidos por el usuario aplicables `U`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-472">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="fb09f-473">Este conjunto consta de los operadores de conversión implícita definidos por el usuario y de elevación que se declaran en las clases o Structs de `D` que convierten de un tipo que abarca `S` a un tipo englobado por `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-473">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="fb09f-474">Si `U` está vacío, la conversión no está definida y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-474">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-475">Busque el tipo de origen más específico, `SX`, de los operadores en `U`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-475">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="fb09f-476">Si alguno de los operadores de `U` convierte de `S`, se `S``SX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-476">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="fb09f-477">De lo contrario, `SX` es el tipo más abarcado en el conjunto combinado de tipos de origen de los operadores de `U`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-477">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="fb09f-478">Si no se encuentra exactamente un tipo más abarcado, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-478">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-479">Busque el tipo de destino más específico, `TX`, de los operadores en `U`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-479">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="fb09f-480">Si alguno de los operadores de `U` convierte en `T`, se `T``TX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-480">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="fb09f-481">De lo contrario, `TX` es el tipo más abarcado en el conjunto combinado de tipos de destino de los operadores de `U`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-481">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="fb09f-482">Si no se encuentra exactamente un tipo más englobado, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-482">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-483">Busque el operador de conversión más específico:</span><span class="sxs-lookup"><span data-stu-id="fb09f-483">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="fb09f-484">Si `U` contiene exactamente un operador de conversión definido por el usuario que convierte de `SX` a `TX`, éste es el operador de conversión más específico.</span><span class="sxs-lookup"><span data-stu-id="fb09f-484">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="fb09f-485">De lo contrario, si `U` contiene exactamente un operador de conversión de elevación que convierte de `SX` a `TX`, éste es el operador de conversión más específico.</span><span class="sxs-lookup"><span data-stu-id="fb09f-485">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="fb09f-486">De lo contrario, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-486">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-487">Por último, aplique la conversión:</span><span class="sxs-lookup"><span data-stu-id="fb09f-487">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="fb09f-488">Si `S` no se `SX`, se realiza una conversión implícita estándar de `S` a `SX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-488">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="fb09f-489">Se invoca el operador de conversión más específico para convertir de `SX` a `TX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-489">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="fb09f-490">Si `TX` no se `T`, se realiza una conversión implícita estándar de `TX` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-490">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="fb09f-491">Procesamiento de conversiones explícitas definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="fb09f-491">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="fb09f-492">Una conversión explícita definida por el usuario del tipo `S` al tipo `T` se procesa de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="fb09f-492">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="fb09f-493">Determine los tipos `S0` y `T0`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-493">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="fb09f-494">Si `S` o `T` son tipos que aceptan valores NULL, `S0` y `T0` son sus tipos subyacentes; de lo contrario, `S0` y `T0` son iguales a `S` y `T` respectivamente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-494">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="fb09f-495">Busque el conjunto de tipos, `D`, desde el que se tendrán en cuenta los operadores de conversión definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fb09f-495">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="fb09f-496">Este conjunto consta de `S0` (si `S0` es una clase o estructura), las clases base de `S0` (si `S0` es una clase), `T0` (si `T0` es una clase o estructura) y las clases base de `T0` (si `T0` es una clase).</span><span class="sxs-lookup"><span data-stu-id="fb09f-496">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="fb09f-497">Busque el conjunto de operadores de conversión de elevación y definidos por el usuario aplicables `U`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-497">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="fb09f-498">Este conjunto consta de los operadores de conversión implícitos y de elevación definidos por el usuario declarados por las clases o Structs en `D` que se convierten de un tipo que abarca o engloba `S` a un tipo englobado o englobado por `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-498">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="fb09f-499">Si `U` está vacío, la conversión no está definida y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-499">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-500">Busque el tipo de origen más específico, `SX`, de los operadores en `U`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-500">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="fb09f-501">Si alguno de los operadores de `U` convierte de `S`, se `S``SX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-501">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="fb09f-502">De lo contrario, si cualquiera de los operadores de `U` convierte de tipos que abarcan `S`, `SX` es el tipo más abarcado en el conjunto combinado de tipos de origen de esos operadores.</span><span class="sxs-lookup"><span data-stu-id="fb09f-502">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="fb09f-503">Si no se puede encontrar ningún tipo más abarcado, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-503">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="fb09f-504">De lo contrario, `SX` es el tipo más abarcado en el conjunto combinado de tipos de origen de los operadores de `U`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-504">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="fb09f-505">Si no se encuentra exactamente un tipo más englobado, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-505">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-506">Busque el tipo de destino más específico, `TX`, de los operadores en `U`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-506">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="fb09f-507">Si alguno de los operadores de `U` convierte en `T`, se `T``TX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-507">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="fb09f-508">De lo contrario, si cualquiera de los operadores de `U` convierte en tipos que están englobados por `T`, `TX` es el tipo más abarcado en el conjunto combinado de tipos de destino de esos operadores.</span><span class="sxs-lookup"><span data-stu-id="fb09f-508">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="fb09f-509">Si no se encuentra exactamente un tipo más englobado, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-509">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="fb09f-510">De lo contrario, `TX` es el tipo más abarcado en el conjunto combinado de tipos de destino de los operadores de `U`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-510">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="fb09f-511">Si no se puede encontrar ningún tipo más abarcado, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-511">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-512">Busque el operador de conversión más específico:</span><span class="sxs-lookup"><span data-stu-id="fb09f-512">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="fb09f-513">Si `U` contiene exactamente un operador de conversión definido por el usuario que convierte de `SX` a `TX`, éste es el operador de conversión más específico.</span><span class="sxs-lookup"><span data-stu-id="fb09f-513">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="fb09f-514">De lo contrario, si `U` contiene exactamente un operador de conversión de elevación que convierte de `SX` a `TX`, éste es el operador de conversión más específico.</span><span class="sxs-lookup"><span data-stu-id="fb09f-514">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="fb09f-515">De lo contrario, la conversión es ambigua y se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-515">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-516">Por último, aplique la conversión:</span><span class="sxs-lookup"><span data-stu-id="fb09f-516">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="fb09f-517">Si `S` no se `SX`, se realiza una conversión explícita estándar de `S` a `SX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-517">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="fb09f-518">Se invoca el operador de conversión definido por el usuario más específico para convertir de `SX` a `TX`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-518">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="fb09f-519">Si `TX` no se `T`, se realiza una conversión explícita estándar de `TX` a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-519">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="fb09f-520">Conversiones de funciones anónimas</span><span class="sxs-lookup"><span data-stu-id="fb09f-520">Anonymous function conversions</span></span>

<span data-ttu-id="fb09f-521">Un *anonymous_method_expression* o *lambda_expression* se clasifica como una función anónima ([expresiones de función anónima](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-521">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="fb09f-522">La expresión no tiene un tipo, pero se puede convertir de forma implícita a un tipo de delegado o un tipo de árbol de expresión compatible.</span><span class="sxs-lookup"><span data-stu-id="fb09f-522">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="fb09f-523">En concreto, una función anónima `F` es compatible con un tipo de delegado `D` proporcionado:</span><span class="sxs-lookup"><span data-stu-id="fb09f-523">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="fb09f-524">Si `F` contiene un *anonymous_function_signature*, `D` y `F` tienen el mismo número de parámetros.</span><span class="sxs-lookup"><span data-stu-id="fb09f-524">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="fb09f-525">Si `F` no contiene un *anonymous_function_signature*, `D` puede tener cero o más parámetros de cualquier tipo, siempre que ningún parámetro de `D` tenga el modificador de parámetro `out`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-525">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="fb09f-526">Si `F` tiene una lista de parámetros con tipo explícito, cada parámetro de `D` tiene el mismo tipo y modificadores que el parámetro correspondiente en `F`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-526">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="fb09f-527">Si `F` tiene una lista de parámetros con tipo implícito, `D` no tiene ningún parámetro `ref` o `out`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-527">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="fb09f-528">Si el cuerpo de `F` es una expresión y `D` tiene un tipo de valor devuelto `void` o `F` es Async y `D` tiene el tipo de valor devuelto `Task`, cuando cada parámetro de `F` recibe el tipo del parámetro correspondiente en `D`, el cuerpo de `F` es una expresión válida (las [expresiones](expressions.md)WRT) que se permitiría como *statement_expression* ([instrucciones de expresión](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-528">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="fb09f-529">Si el cuerpo de `F` es un bloque de instrucciones y `D` tiene un tipo de valor devuelto `void` o `F` es Async y `D` tiene el tipo de valor devuelto `Task`, cuando cada parámetro de `F` recibe el tipo del parámetro correspondiente en `D`, el cuerpo de `F` es un bloque de instrucciones válido (WRT [bloques](statements.md#blocks)) en el que ninguna instrucción `return` especifica una expresión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-529">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="fb09f-530">Si el cuerpo de `F` es una expresión *y `F` no es Async y `D`* tiene un tipo de valor devuelto distinto de void `T`, *o* `F` es Async y `D` tiene un tipo de valor devuelto `Task<T>`, cuando cada parámetro de `F` recibe el tipo del parámetro correspondiente en `D`, el cuerpo de `F` es una expresión válida (WRT [expresiones](expressions.md)) que es implícitamente convertible a `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-530">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="fb09f-531">Si el cuerpo de `F` es un bloque de instrucciones y *`F` no es asincrónico y `D`* tiene un tipo de valor devuelto distinto de void `T`, *o* `F` es Async y `D` tiene un tipo de valor devuelto `Task<T>`, cuando cada parámetro de `F` recibe el tipo del parámetro correspondiente en `D`, el cuerpo de `F` es un bloque de instrucciones válido (WRT [bloques](statements.md#blocks)) con un punto final no accesible en el que cada instrucción `return` especifica una expresión que se puede convertir implícitamente en `T`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-531">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="fb09f-532">Por motivos de brevedad, en esta sección se usa la forma abreviada para los tipos de tarea `Task` y `Task<T>` ([funciones asincrónicas](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-532">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="fb09f-533">Una expresión lambda `F` es compatible con un tipo de árbol de expresión `Expression<D>` si `F` es compatible con el tipo de delegado `D`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-533">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="fb09f-534">Tenga en cuenta que esto no se aplica a los métodos anónimos, solo a las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="fb09f-534">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="fb09f-535">Ciertas expresiones lambda no se pueden convertir en tipos de árbol de expresión: aunque la conversión *existe*, se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-535">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="fb09f-536">Este es el caso si la expresión lambda:</span><span class="sxs-lookup"><span data-stu-id="fb09f-536">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="fb09f-537">Tiene un cuerpo de *bloque*</span><span class="sxs-lookup"><span data-stu-id="fb09f-537">Has a *block* body</span></span>
*  <span data-ttu-id="fb09f-538">Contiene operadores de asignación simples o compuestos</span><span class="sxs-lookup"><span data-stu-id="fb09f-538">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="fb09f-539">Contiene una expresión enlazada dinámicamente</span><span class="sxs-lookup"><span data-stu-id="fb09f-539">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="fb09f-540">Async</span><span class="sxs-lookup"><span data-stu-id="fb09f-540">Is async</span></span>

<span data-ttu-id="fb09f-541">En los ejemplos siguientes se usa un tipo de delegado genérico `Func<A,R>` que representa una función que toma un argumento de tipo `A` y devuelve un valor de tipo `R`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-541">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="fb09f-542">En las asignaciones</span><span class="sxs-lookup"><span data-stu-id="fb09f-542">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="fb09f-543">los tipos de valor devuelto y de parámetro de cada función anónima se determinan a partir del tipo de la variable a la que se asigna la función anónima.</span><span class="sxs-lookup"><span data-stu-id="fb09f-543">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="fb09f-544">La primera asignación convierte correctamente la función anónima en el tipo de delegado `Func<int,int>` porque, cuando `x` tiene el tipo `int`, `x+1` es una expresión válida que se pueda convertir implícitamente al tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-544">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="fb09f-545">Del mismo modo, la segunda asignación convierte correctamente la función anónima en el tipo de delegado `Func<int,double>` porque el resultado de `x+1` (de tipo `int`) es implícitamente convertible al tipo `double`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-545">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="fb09f-546">Sin embargo, la tercera asignación es un error en tiempo de compilación porque, cuando `x` tiene el tipo `double`, el resultado de `x+1` (de tipo `double`) no se pueden convertir implícitamente al tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-546">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="fb09f-547">La cuarta asignación convierte correctamente la función asincrónica anónima en el tipo de delegado `Func<int, Task<int>>` porque el resultado de `x+1` (de tipo `int`) es implícitamente convertible al tipo de resultado `int` del tipo de tarea `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-547">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="fb09f-548">Las funciones anónimas pueden influir en la resolución de sobrecarga y participar en la inferencia de tipos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-548">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="fb09f-549">Consulte [miembros de función](expressions.md#function-members) para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="fb09f-549">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="fb09f-550">Evaluación de conversiones de funciones anónimas a tipos de delegado</span><span class="sxs-lookup"><span data-stu-id="fb09f-550">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="fb09f-551">La conversión de una función anónima a un tipo de delegado genera una instancia de delegado que hace referencia a la función anónima y al conjunto (posiblemente vacío) de variables externas capturadas que están activas en el momento de la evaluación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-551">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="fb09f-552">Cuando se invoca el delegado, se ejecuta el cuerpo de la función anónima.</span><span class="sxs-lookup"><span data-stu-id="fb09f-552">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="fb09f-553">El código del cuerpo se ejecuta utilizando el conjunto de variables externas capturadas al que hace referencia el delegado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-553">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="fb09f-554">La lista de invocaciones de un delegado generado a partir de una función anónima contiene una sola entrada.</span><span class="sxs-lookup"><span data-stu-id="fb09f-554">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="fb09f-555">No se especifican el objeto de destino exacto y el método de destino del delegado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-555">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="fb09f-556">En concreto, no se especifica si el objeto de destino del delegado es `null`, el valor `this` del miembro de función envolvente o algún otro objeto.</span><span class="sxs-lookup"><span data-stu-id="fb09f-556">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="fb09f-557">Se permiten las conversiones de funciones anónimas semánticamente idénticas con el mismo conjunto (posiblemente vacío) de instancias de variables externas capturadas en los mismos tipos de delegado (aunque no es necesario) para devolver la misma instancia de delegado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-557">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="fb09f-558">El término semánticamente idéntico se usa aquí para indicar que la ejecución de las funciones anónimas, en todos los casos, produce los mismos efectos dados los mismos argumentos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-558">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="fb09f-559">Esta regla permite optimizar el código como el siguiente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-559">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="fb09f-560">Dado que los dos delegados de función anónimos tienen el mismo conjunto (vacío) de variables externas capturadas y como las funciones anónimas son idénticas semánticamente, el compilador puede hacer que los delegados hagan referencia al mismo método de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-560">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="fb09f-561">En realidad, el compilador puede devolver la misma instancia de delegado de ambas expresiones de función anónimas.</span><span class="sxs-lookup"><span data-stu-id="fb09f-561">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="fb09f-562">Evaluación de conversiones de funciones anónimas a tipos de árbol de expresión</span><span class="sxs-lookup"><span data-stu-id="fb09f-562">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="fb09f-563">La conversión de una función anónima en un tipo de árbol de expresión genera un árbol de expresión ([tipos de árbol de expresión](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-563">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="fb09f-564">Más concretamente, la evaluación de la conversión de funciones anónimas conduce a la construcción de una estructura de objeto que representa la estructura de la propia función anónima.</span><span class="sxs-lookup"><span data-stu-id="fb09f-564">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="fb09f-565">La estructura precisa del árbol de expresión, así como el proceso exacto para crearla, se definen en la implementación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-565">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="fb09f-566">Ejemplo de implementación</span><span class="sxs-lookup"><span data-stu-id="fb09f-566">Implementation example</span></span>

<span data-ttu-id="fb09f-567">En esta sección se describe una posible implementación de conversiones de funciones anónimas en C# términos de otras construcciones.</span><span class="sxs-lookup"><span data-stu-id="fb09f-567">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="fb09f-568">La implementación que se describe aquí se basa en los mismos principios utilizados por C# el compilador de Microsoft, pero no es una implementación asignada, ni es lo único posible.</span><span class="sxs-lookup"><span data-stu-id="fb09f-568">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="fb09f-569">Solo se mencionan brevemente las conversiones a los árboles de expresión, ya que su semántica exacta está fuera del ámbito de esta especificación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-569">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="fb09f-570">En el resto de esta sección se proporcionan varios ejemplos de código que contiene funciones anónimas con diferentes características.</span><span class="sxs-lookup"><span data-stu-id="fb09f-570">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="fb09f-571">En cada ejemplo, se proporciona una traducción correspondiente al código que usa C# solo otras construcciones.</span><span class="sxs-lookup"><span data-stu-id="fb09f-571">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="fb09f-572">En los ejemplos, se supone que el identificador `D` representa el siguiente tipo de delegado:</span><span class="sxs-lookup"><span data-stu-id="fb09f-572">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="fb09f-573">La forma más sencilla de una función anónima es aquella que no captura variables externas:</span><span class="sxs-lookup"><span data-stu-id="fb09f-573">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="fb09f-574">Esto se puede traducir a una creación de instancias de delegado que hace referencia a un método estático generado por el compilador en el que se coloca el código de la función anónima:</span><span class="sxs-lookup"><span data-stu-id="fb09f-574">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="fb09f-575">En el ejemplo siguiente, la función anónima hace referencia a los miembros de instancia de `this`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-575">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="fb09f-576">Esto puede traducirse a un método de instancia generado por el compilador que contenga el código de la función anónima:</span><span class="sxs-lookup"><span data-stu-id="fb09f-576">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="fb09f-577">En este ejemplo, la función anónima captura una variable local:</span><span class="sxs-lookup"><span data-stu-id="fb09f-577">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="fb09f-578">La duración de la variable local debe extenderse ahora a al menos la duración del delegado de función anónima.</span><span class="sxs-lookup"><span data-stu-id="fb09f-578">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="fb09f-579">Esto puede lograrse mediante la "activación" de la variable local en un campo de una clase generada por el compilador.</span><span class="sxs-lookup"><span data-stu-id="fb09f-579">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="fb09f-580">La creación de instancias de la variable local (creación[de instancias de variables locales](expressions.md#instantiation-of-local-variables)) corresponde entonces a la creación de una instancia de la clase generada por el compilador y el acceso a la variable local corresponde al acceso a un campo en la instancia de la clase generada por el compilador.</span><span class="sxs-lookup"><span data-stu-id="fb09f-580">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="fb09f-581">Además, la función anónima se convierte en un método de instancia de la clase generada por el compilador:</span><span class="sxs-lookup"><span data-stu-id="fb09f-581">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="fb09f-582">Por último, la función anónima siguiente captura `this` así como dos variables locales con distintas duraciones:</span><span class="sxs-lookup"><span data-stu-id="fb09f-582">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="fb09f-583">En este caso, se crea una clase generada por el compilador para cada bloque de instrucciones en el que se capturan las variables locales de forma que las variables locales de los diferentes bloques puedan tener duraciones independientes.</span><span class="sxs-lookup"><span data-stu-id="fb09f-583">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="fb09f-584">Una instancia de `__Locals2`, la clase generada por el compilador para el bloque de instrucciones interno, contiene la variable local `z` y un campo que hace referencia a una instancia de `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-584">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="fb09f-585">Una instancia de `__Locals1`, la clase generada por el compilador para el bloque de instrucciones exterior, contiene la variable local `y` y un campo que hace referencia a `this` del miembro de función envolvente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-585">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="fb09f-586">Con estas estructuras de datos es posible llegar a todas las variables externas capturadas a través de una instancia de `__Local2`, y el código de la función anónima se puede implementar como un método de instancia de esa clase.</span><span class="sxs-lookup"><span data-stu-id="fb09f-586">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="fb09f-587">También se puede usar la misma técnica que se aplica aquí para capturar variables locales al convertir funciones anónimas en árboles de expresión: las referencias a los objetos generados por el compilador se pueden almacenar en el árbol de expresión y el acceso a las variables locales puede ser se representa como accesos de campo en estos objetos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-587">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="fb09f-588">La ventaja de este enfoque es que permite compartir las variables locales "levantadas" entre los delegados y los árboles de expresión.</span><span class="sxs-lookup"><span data-stu-id="fb09f-588">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="fb09f-589">Conversiones de grupos de métodos</span><span class="sxs-lookup"><span data-stu-id="fb09f-589">Method group conversions</span></span>

<span data-ttu-id="fb09f-590">Existe una conversión implícita ([conversiones implícitas](conversions.md#implicit-conversions)) de un grupo de métodos ([clasificaciones de expresión](expressions.md#expression-classifications)) a un tipo de delegado compatible.</span><span class="sxs-lookup"><span data-stu-id="fb09f-590">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="fb09f-591">Dado un tipo de delegado `D` y una expresión `E` que se clasifica como un grupo de métodos, existe una conversión implícita de `E` a `D` si `E` contiene al menos un método que es aplicable en su forma normal ([miembro de función aplicable](expressions.md#applicable-function-member)) a una lista de argumentos construida mediante el uso de los tipos de parámetros y modificadores de `D`, como se describe en el siguiente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-591">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="fb09f-592">La aplicación en tiempo de compilación de una conversión de un grupo de métodos `E` a un tipo de delegado `D` se describe en lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-592">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="fb09f-593">Tenga en cuenta que la existencia de una conversión implícita de `E` a `D` no garantiza que la aplicación en tiempo de compilación de la conversión se realice correctamente sin errores.</span><span class="sxs-lookup"><span data-stu-id="fb09f-593">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="fb09f-594">Se selecciona un único método `M` que corresponde a una invocación de método ([invocaciones de método](expressions.md#method-invocations)) del formulario `E(A)`, con las siguientes modificaciones:</span><span class="sxs-lookup"><span data-stu-id="fb09f-594">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="fb09f-595">La lista de argumentos `A` es una lista de expresiones, cada una clasificada como una variable y con el tipo y el modificador (`ref` o `out`) del parámetro correspondiente en la *formal_parameter_list* de `D`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-595">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="fb09f-596">Los métodos candidatos considerados solo son aquellos que se aplican en su forma normal ([miembro de función aplicable](expressions.md#applicable-function-member)), no los que solo se aplican en su forma expandida.</span><span class="sxs-lookup"><span data-stu-id="fb09f-596">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="fb09f-597">Si el algoritmo de las [invocaciones de método](expressions.md#method-invocations) produce un error, se produce un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-597">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="fb09f-598">De lo contrario, el algoritmo genera un único método mejor `M` tener el mismo número de parámetros que `D` y se considera que la conversión existe.</span><span class="sxs-lookup"><span data-stu-id="fb09f-598">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="fb09f-599">El método seleccionado `M` debe ser compatible con el tipo[de delegado `D`](delegates.md#delegate-compatibility), o de lo contrario, se producirá un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="fb09f-599">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="fb09f-600">Si el método seleccionado `M` es un método de instancia, la expresión de instancia asociada a `E` determina el objeto de destino del delegado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-600">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="fb09f-601">Si el método seleccionado M es un método de extensión que se indica mediante un acceso a miembro en una expresión de instancia, esa expresión de instancia determina el objeto de destino del delegado.</span><span class="sxs-lookup"><span data-stu-id="fb09f-601">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="fb09f-602">El resultado de la conversión es un valor de tipo `D`, es decir, un delegado recién creado que hace referencia al método seleccionado y al objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-602">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="fb09f-603">Tenga en cuenta que este proceso puede dar lugar a la creación de un delegado a un método de extensión, si el algoritmo de las [invocaciones de método](expressions.md#method-invocations) no encuentra un método de instancia pero realiza correctamente el procesamiento de la invocación de `E(A)` como una invocación de método de extensión ([invocaciones de método de extensión](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="fb09f-603">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="fb09f-604">Por lo tanto, un delegado creado captura el método de extensión, así como su primer argumento.</span><span class="sxs-lookup"><span data-stu-id="fb09f-604">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="fb09f-605">En el ejemplo siguiente se muestran las conversiones de grupos de métodos:</span><span class="sxs-lookup"><span data-stu-id="fb09f-605">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="fb09f-606">La asignación a `d1` convierte implícitamente el grupo de métodos `F` en un valor de tipo `D1`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-606">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="fb09f-607">La asignación a `d2` muestra cómo se puede crear un delegado para un método que tiene tipos de parámetro menos derivados (contravariante) y un tipo de valor devuelto más derivado (covariante).</span><span class="sxs-lookup"><span data-stu-id="fb09f-607">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="fb09f-608">La asignación a `d3` muestra el modo en que no existe ninguna conversión si el método no es aplicable.</span><span class="sxs-lookup"><span data-stu-id="fb09f-608">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="fb09f-609">La asignación a `d4` muestra cómo el método debe ser aplicable en su forma normal.</span><span class="sxs-lookup"><span data-stu-id="fb09f-609">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="fb09f-610">La asignación a `d5` muestra cómo se permite que los tipos de parámetro y de valor devuelto del delegado y el método difieran solo para los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-610">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="fb09f-611">Como con todas las demás conversiones implícitas y explícitas, el operador de conversión se puede usar para realizar explícitamente una conversión de grupo de métodos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-611">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="fb09f-612">Por lo tanto, el ejemplo</span><span class="sxs-lookup"><span data-stu-id="fb09f-612">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="fb09f-613">en su lugar, se puede escribir</span><span class="sxs-lookup"><span data-stu-id="fb09f-613">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="fb09f-614">Los grupos de métodos pueden influir en la resolución de sobrecarga y participar en la inferencia de tipos.</span><span class="sxs-lookup"><span data-stu-id="fb09f-614">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="fb09f-615">Consulte [miembros de función](expressions.md#function-members) para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="fb09f-615">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="fb09f-616">La evaluación en tiempo de ejecución de una conversión de grupo de métodos continúa como sigue:</span><span class="sxs-lookup"><span data-stu-id="fb09f-616">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="fb09f-617">Si el método seleccionado en tiempo de compilación es un método de instancia, o es un método de extensión al que se tiene acceso como un método de instancia, el objeto de destino del delegado se determina a partir de la expresión de instancia asociada a `E`:</span><span class="sxs-lookup"><span data-stu-id="fb09f-617">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="fb09f-618">Se evalúa la expresión de instancia.</span><span class="sxs-lookup"><span data-stu-id="fb09f-618">The instance expression is evaluated.</span></span> <span data-ttu-id="fb09f-619">Si esta evaluación provoca una excepción, no se ejecuta ningún paso más.</span><span class="sxs-lookup"><span data-stu-id="fb09f-619">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="fb09f-620">Si la expresión de instancia es de un *reference_type*, el valor calculado por la expresión de instancia se convierte en el objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-620">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="fb09f-621">Si el método seleccionado es un método de instancia y el objeto de destino es `null`, se produce una `System.NullReferenceException` y no se ejecuta ningún otro paso.</span><span class="sxs-lookup"><span data-stu-id="fb09f-621">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="fb09f-622">Si la expresión de instancia es de un *value_type*, se realiza una operación de conversión boxing ([conversiones boxing](types.md#boxing-conversions)) para convertir el valor en un objeto y este objeto se convierte en el objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="fb09f-622">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="fb09f-623">De lo contrario, el método seleccionado forma parte de una llamada al método estático y el objeto de destino del delegado es `null`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-623">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="fb09f-624">Se asigna una nueva instancia del tipo de delegado `D`.</span><span class="sxs-lookup"><span data-stu-id="fb09f-624">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="fb09f-625">Si no hay suficiente memoria disponible para asignar la nueva instancia, se produce una `System.OutOfMemoryException` y no se ejecuta ningún otro paso.</span><span class="sxs-lookup"><span data-stu-id="fb09f-625">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="fb09f-626">La nueva instancia de delegado se inicializa con una referencia al método que se determinó en tiempo de compilación y una referencia al objeto de destino calculado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="fb09f-626">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
