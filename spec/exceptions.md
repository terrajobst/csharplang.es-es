---
ms.openlocfilehash: 75fcd5b00ea5cac218a9f7809c53b179df97825c
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/25/2019
ms.locfileid: "64488949"
---
# <a name="exceptions"></a><span data-ttu-id="7049a-101">Excepciones</span><span class="sxs-lookup"><span data-stu-id="7049a-101">Exceptions</span></span>

<span data-ttu-id="7049a-102">Las excepciones en C# proporcionan una forma estructurada, uniforme y con seguridad de tipos de control de nivel de sistema y nivel de aplicación las condiciones de error.</span><span class="sxs-lookup"><span data-stu-id="7049a-102">Exceptions in C# provide a structured, uniform, and type-safe way of handling both system level and application level error conditions.</span></span> <span data-ttu-id="7049a-103">El mecanismo de excepciones en C# es bastante similar a la de C++, con algunas diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="7049a-103">The exception mechanism in C# is quite similar to that of C++, with a few important differences:</span></span>

*  <span data-ttu-id="7049a-104">En C#, todas las excepciones deben representarse mediante una instancia de un tipo de clase derivado de `System.Exception`.</span><span class="sxs-lookup"><span data-stu-id="7049a-104">In C#, all exceptions must be represented by an instance of a class type derived from `System.Exception`.</span></span> <span data-ttu-id="7049a-105">En C++, cualquier valor de cualquier tipo puede utilizarse para representar una excepción.</span><span class="sxs-lookup"><span data-stu-id="7049a-105">In C++, any value of any type can be used to represent an exception.</span></span>
*  <span data-ttu-id="7049a-106">En C#, un bloque finally ([la instrucción try](statements.md#the-try-statement)) puede usarse para escribir código de terminación que se ejecute en una ejecución normal y condiciones excepcionales.</span><span class="sxs-lookup"><span data-stu-id="7049a-106">In C#, a finally block ([The try statement](statements.md#the-try-statement)) can be used to write termination code that executes in both normal execution and exceptional conditions.</span></span> <span data-ttu-id="7049a-107">Dicho código es difícil de escribir en C++ sin duplicar código.</span><span class="sxs-lookup"><span data-stu-id="7049a-107">Such code is difficult to write in C++ without duplicating code.</span></span>
*  <span data-ttu-id="7049a-108">En C#, las excepciones de nivel de sistema, como desbordamiento, división por cero y null desreferencia también han definido las clases de excepción y se encuentran en un mismo nivel que las condiciones de error de nivel de aplicación.</span><span class="sxs-lookup"><span data-stu-id="7049a-108">In C#, system-level exceptions such as overflow, divide-by-zero, and null dereferences have well defined exception classes and are on a par with application-level error conditions.</span></span>

## <a name="causes-of-exceptions"></a><span data-ttu-id="7049a-109">Causas de excepciones</span><span class="sxs-lookup"><span data-stu-id="7049a-109">Causes of exceptions</span></span>

<span data-ttu-id="7049a-110">Se puede producir la excepción de dos maneras diferentes.</span><span class="sxs-lookup"><span data-stu-id="7049a-110">Exception can be thrown in two different ways.</span></span>

*  <span data-ttu-id="7049a-111">Un `throw` instrucción ([la instrucción throw](statements.md#the-throw-statement)) produce una excepción inmediatamente y de forma incondicional.</span><span class="sxs-lookup"><span data-stu-id="7049a-111">A `throw` statement ([The throw statement](statements.md#the-throw-statement)) throws an exception immediately and unconditionally.</span></span> <span data-ttu-id="7049a-112">Control nunca llega a la instrucción inmediatamente posterior a la `throw`.</span><span class="sxs-lookup"><span data-stu-id="7049a-112">Control never reaches the statement immediately following the `throw`.</span></span>
*  <span data-ttu-id="7049a-113">Ciertas condiciones excepcionales que surgen durante el procesamiento de instrucciones de C# y expresión provocan una excepción en determinadas circunstancias, cuando la operación no se puede completar con normalidad.</span><span class="sxs-lookup"><span data-stu-id="7049a-113">Certain exceptional conditions that arise during the processing of C# statements and expression cause an exception in certain circumstances when the operation cannot be completed normally.</span></span> <span data-ttu-id="7049a-114">Por ejemplo, una operación de división de enteros ([operador de división](expressions.md#division-operator)) produce una `System.DivideByZeroException` si el denominador es cero.</span><span class="sxs-lookup"><span data-stu-id="7049a-114">For example, an integer division operation ([Division operator](expressions.md#division-operator)) throws a `System.DivideByZeroException` if the denominator is zero.</span></span> <span data-ttu-id="7049a-115">Consulte [clases de excepciones comunes](exceptions.md#common-exception-classes) para obtener una lista de las diferentes excepciones que pueden producirse en este modo.</span><span class="sxs-lookup"><span data-stu-id="7049a-115">See [Common Exception Classes](exceptions.md#common-exception-classes) for a list of the various exceptions that can occur in this way.</span></span>

## <a name="the-systemexception-class"></a><span data-ttu-id="7049a-116">La clase System.Exception</span><span class="sxs-lookup"><span data-stu-id="7049a-116">The System.Exception class</span></span>

<span data-ttu-id="7049a-117">La `System.Exception` clase es el tipo base de todas las excepciones.</span><span class="sxs-lookup"><span data-stu-id="7049a-117">The `System.Exception` class is the base type of all exceptions.</span></span> <span data-ttu-id="7049a-118">Esta clase tiene algunas propiedades importantes que comparten todas las excepciones:</span><span class="sxs-lookup"><span data-stu-id="7049a-118">This class has a few notable properties that all exceptions share:</span></span>

*  <span data-ttu-id="7049a-119">`Message` es una propiedad de solo lectura de tipo `string` que contiene una descripción legible de la causa de la excepción.</span><span class="sxs-lookup"><span data-stu-id="7049a-119">`Message` is a read-only property of type `string` that contains a human-readable description of the reason for the exception.</span></span>
*  <span data-ttu-id="7049a-120">`InnerException` es una propiedad de solo lectura de tipo `Exception`.</span><span class="sxs-lookup"><span data-stu-id="7049a-120">`InnerException` is a read-only property of type `Exception`.</span></span> <span data-ttu-id="7049a-121">Si su valor es distinto de null, hace referencia a la excepción que produjo la excepción actual, es decir, en que se ha producido la excepción actual en un bloque catch controla la `InnerException`.</span><span class="sxs-lookup"><span data-stu-id="7049a-121">If its value is non-null, it refers to the exception that caused the current exception—that is, the current exception was raised in a catch block handling the `InnerException`.</span></span> <span data-ttu-id="7049a-122">En caso contrario, su valor es null, que indica que esta excepción no fue causada por otra excepción.</span><span class="sxs-lookup"><span data-stu-id="7049a-122">Otherwise, its value is null, indicating that this exception was not caused by another exception.</span></span> <span data-ttu-id="7049a-123">El número de objetos de excepción que se encadenan de esta manera puede ser arbitrario.</span><span class="sxs-lookup"><span data-stu-id="7049a-123">The number of exception objects chained together in this manner can be arbitrary.</span></span>

<span data-ttu-id="7049a-124">El valor de estas propiedades se puede especificar en las llamadas al constructor de instancia para `System.Exception`.</span><span class="sxs-lookup"><span data-stu-id="7049a-124">The value of these properties can be specified in calls to the instance constructor for `System.Exception`.</span></span>

## <a name="how-exceptions-are-handled"></a><span data-ttu-id="7049a-125">¿Cómo se controlan las excepciones</span><span class="sxs-lookup"><span data-stu-id="7049a-125">How exceptions are handled</span></span>

<span data-ttu-id="7049a-126">Las excepciones se controlan mediante un `try` instrucción ([la instrucción try](statements.md#the-try-statement)).</span><span class="sxs-lookup"><span data-stu-id="7049a-126">Exceptions are handled by a `try` statement ([The try statement](statements.md#the-try-statement)).</span></span>

<span data-ttu-id="7049a-127">Cuando se produce una excepción, el sistema busca más cercano `catch` cláusula que pueda controlar la excepción, según lo determinado por el tipo de tiempo de ejecución de la excepción.</span><span class="sxs-lookup"><span data-stu-id="7049a-127">When an exception occurs, the system searches for the nearest `catch` clause that can handle the exception, as determined by the run-time type of the exception.</span></span> <span data-ttu-id="7049a-128">En primer lugar, se busca el método actual para incluir léxicamente `try` instrucción y las cláusulas catch asociada de la instrucción try se consideran en orden.</span><span class="sxs-lookup"><span data-stu-id="7049a-128">First, the current method is searched for a lexically enclosing `try` statement, and the associated catch clauses of the try statement are considered in order.</span></span> <span data-ttu-id="7049a-129">Si se produce un error, se busca el método que llamó al método actual para incluir léxicamente `try` instrucción que contenga el punto de la llamada al método actual.</span><span class="sxs-lookup"><span data-stu-id="7049a-129">If that fails, the method that called the current method is searched for a lexically enclosing `try` statement that encloses the point of the call to the current method.</span></span> <span data-ttu-id="7049a-130">Esta búsqueda continúa hasta que un `catch` encontrar una cláusula que pueda controlar la excepción actual, una clase de excepción que sea de la misma clase o una clase base del tipo de tiempo de ejecución de la excepción de asignación de nombres.</span><span class="sxs-lookup"><span data-stu-id="7049a-130">This search continues until a `catch` clause is found that can handle the current exception, by naming an exception class that is of the same class, or a base class, of the run-time type of the exception being thrown.</span></span> <span data-ttu-id="7049a-131">Un `catch` cláusula que no asigne nombre a una clase de excepción puede controlar cualquier excepción.</span><span class="sxs-lookup"><span data-stu-id="7049a-131">A `catch` clause that doesn't name an exception class can handle any exception.</span></span>

<span data-ttu-id="7049a-132">Una vez que se encuentra una cláusula catch coincidente, el sistema se prepara para transferir el control a la primera instrucción de la cláusula catch.</span><span class="sxs-lookup"><span data-stu-id="7049a-132">Once a matching catch clause is found, the system prepares to transfer control to the first statement of the catch clause.</span></span> <span data-ttu-id="7049a-133">Antes de comenzar la ejecución de la cláusula catch, el sistema ejecuta primero, en orden, cualquiera `finally` cláusulas que se asociaron con instrucciones try más anidados que a la que se detectó la excepción.</span><span class="sxs-lookup"><span data-stu-id="7049a-133">Before execution of the catch clause begins, the system first executes, in order, any `finally` clauses that were associated with try statements more nested that than the one that caught the exception.</span></span>

<span data-ttu-id="7049a-134">Si no se encuentra ninguna cláusula catch coincidente, se produce una de estas dos cosas:</span><span class="sxs-lookup"><span data-stu-id="7049a-134">If no matching catch clause is found, one of two things occurs:</span></span>

*  <span data-ttu-id="7049a-135">Si la búsqueda de una cláusula catch coincidente llega a un constructor estático ([constructores estáticos](classes.md#static-constructors)) o un inicializador de campo estático, un `System.TypeInitializationException` se produce en el momento que desencadenó la invocación del constructor estático.</span><span class="sxs-lookup"><span data-stu-id="7049a-135">If the search for a matching catch clause reaches a static constructor ([Static constructors](classes.md#static-constructors)) or static field initializer, then a `System.TypeInitializationException` is thrown at the point that triggered the invocation of the static constructor.</span></span> <span data-ttu-id="7049a-136">La excepción interna de la `System.TypeInitializationException` contiene la excepción que se inició originalmente.</span><span class="sxs-lookup"><span data-stu-id="7049a-136">The inner exception of the `System.TypeInitializationException` contains the exception that was originally thrown.</span></span>
*  <span data-ttu-id="7049a-137">Si el código que inicialmente se inició el subproceso llega a la búsqueda de cláusulas catch coincidentes, se termina la ejecución del subproceso.</span><span class="sxs-lookup"><span data-stu-id="7049a-137">If the search for matching catch clauses reaches the code that initially started the thread, then execution of the thread is terminated.</span></span> <span data-ttu-id="7049a-138">El impacto de cuando dicha terminación es definido por la implementación.</span><span class="sxs-lookup"><span data-stu-id="7049a-138">The impact of such termination is implementation-defined.</span></span>

<span data-ttu-id="7049a-139">Las excepciones que se producen durante la ejecución de un destructor merecen una mención especial.</span><span class="sxs-lookup"><span data-stu-id="7049a-139">Exceptions that occur during destructor execution are worth special mention.</span></span> <span data-ttu-id="7049a-140">Si se produce una excepción durante la ejecución de un destructor y no se detecta esa excepción, se termina la ejecución de dicho destructor y se llama al destructor de la clase base (si existe).</span><span class="sxs-lookup"><span data-stu-id="7049a-140">If an exception occurs during destructor execution, and that exception is not caught, then the execution of that destructor is terminated and the destructor of the base class (if any) is called.</span></span> <span data-ttu-id="7049a-141">Si no hay ninguna clase base (como en el caso de los `object` tipo) o si no hay ningún destructor de clase base, a continuación, se descarta la excepción.</span><span class="sxs-lookup"><span data-stu-id="7049a-141">If there is no base class (as in the case of the `object` type) or if there is no base class destructor, then the exception is discarded.</span></span>

## <a name="common-exception-classes"></a><span data-ttu-id="7049a-142">Clases de excepciones comunes</span><span class="sxs-lookup"><span data-stu-id="7049a-142">Common Exception Classes</span></span>

<span data-ttu-id="7049a-143">Las excepciones siguientes se producen ciertas operaciones de C#.</span><span class="sxs-lookup"><span data-stu-id="7049a-143">The following exceptions are thrown by certain C# operations.</span></span>

|                                      |                |
|--------------------------------------|----------------|
| `System.ArithmeticException`         | <span data-ttu-id="7049a-144">Una clase base para las excepciones que se producen durante las operaciones aritméticas, como `System.DivideByZeroException` y `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="7049a-144">A base class for exceptions that occur during arithmetic operations, such as `System.DivideByZeroException` and `System.OverflowException`.</span></span> | 
| `System.ArrayTypeMismatchException`  | <span data-ttu-id="7049a-145">Se produce cuando se produce un error en un almacén en una matriz porque el tipo real del elemento almacenado es incompatible con el tipo real de la matriz.</span><span class="sxs-lookup"><span data-stu-id="7049a-145">Thrown when a store into an array fails because the actual type of the stored element is incompatible with the actual type of the array.</span></span> | 
| `System.DivideByZeroException`       | <span data-ttu-id="7049a-146">Se produce cuando se produce un intento de dividir un valor integral por cero.</span><span class="sxs-lookup"><span data-stu-id="7049a-146">Thrown when an attempt to divide an integral value by zero occurs.</span></span> | 
| `System.IndexOutOfRangeException`    | <span data-ttu-id="7049a-147">Se produce cuando se intenta indexar una matriz a través de un índice que es menor que cero o fuera de los límites de la matriz.</span><span class="sxs-lookup"><span data-stu-id="7049a-147">Thrown when an attempt to index an array via an index that is less than zero or outside the bounds of the array.</span></span> | 
| `System.InvalidCastException`        | <span data-ttu-id="7049a-148">Se produce cuando se produce un error en una conversión explícita de un tipo base o interfaz a un tipo derivado en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="7049a-148">Thrown when an explicit conversion from a base type or interface to a derived type fails at run time.</span></span> | 
| `System.NullReferenceException`      | <span data-ttu-id="7049a-149">Se produce cuando un `null` referencia se utiliza de forma que hace que el objeto que se hace referencia sea necesaria.</span><span class="sxs-lookup"><span data-stu-id="7049a-149">Thrown when a `null` reference is used in a way that causes the referenced object to be required.</span></span> | 
| `System.OutOfMemoryException`        | <span data-ttu-id="7049a-150">Se produce cuando un intento de asignar memoria (a través de `new`) se produce un error.</span><span class="sxs-lookup"><span data-stu-id="7049a-150">Thrown when an attempt to allocate memory (via `new`) fails.</span></span> | 
| `System.OverflowException`           | <span data-ttu-id="7049a-151">Se inicia cuando se desborda una operación aritmética en un contexto `checked`.</span><span class="sxs-lookup"><span data-stu-id="7049a-151">Thrown when an arithmetic operation in a `checked` context overflows.</span></span> | 
| `System.StackOverflowException`      | <span data-ttu-id="7049a-152">Se produce cuando se agota la pila de ejecución por tener demasiadas llamadas a métodos pendientes; Normalmente es indicativa de recursividad muy profunda o ilimitada.</span><span class="sxs-lookup"><span data-stu-id="7049a-152">Thrown when the execution stack is exhausted by having too many pending method calls; typically indicative of very deep or unbounded recursion.</span></span> | 
| `System.TypeInitializationException` | <span data-ttu-id="7049a-153">Se produce cuando un constructor estático inicia una excepción y no `catch` cláusulas existe para capturarla.</span><span class="sxs-lookup"><span data-stu-id="7049a-153">Thrown when a static constructor throws an exception, and no `catch` clauses exists to catch it.</span></span> | 
