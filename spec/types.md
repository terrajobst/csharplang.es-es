---
ms.openlocfilehash: 088c4a77cecde490c556c44c239a3496f896582e
ms.sourcegitcommit: 4ddf18d000734c1b6d0a48127bf338086fc3f2c3
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/05/2019
ms.locfileid: "73616136"
---
# <a name="types"></a><span data-ttu-id="17a40-101">Tipos</span><span class="sxs-lookup"><span data-stu-id="17a40-101">Types</span></span>

<span data-ttu-id="17a40-102">Los tipos del C# lenguaje se dividen en dos categorías principales: ***tipos de valor*** y ***tipos de referencia***.</span><span class="sxs-lookup"><span data-stu-id="17a40-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="17a40-103">Ambos tipos de valor y tipos de referencia pueden ser ***tipos genéricos***, que toman uno o varios ***parámetros de tipo***.</span><span class="sxs-lookup"><span data-stu-id="17a40-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="17a40-104">Los parámetros de tipo pueden designar tanto tipos de valor como tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="17a40-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="17a40-105">La categoría final de tipos, punteros, solo está disponible en código no seguro.</span><span class="sxs-lookup"><span data-stu-id="17a40-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="17a40-106">Esto se describe con más detalle en [tipos de puntero](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="17a40-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="17a40-107">Los tipos de valor se diferencian de los tipos de referencia en que las variables de los tipos de valor contienen directamente sus datos, mientras que las variables de los tipos de referencia almacenan ***referencias*** a sus datos, lo que se conoce como ***objetos***.</span><span class="sxs-lookup"><span data-stu-id="17a40-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="17a40-108">Con los tipos de referencia, es posible que dos variables hagan referencia al mismo objeto y, por lo tanto, las operaciones en una variable afecten al objeto al que hace referencia la otra variable.</span><span class="sxs-lookup"><span data-stu-id="17a40-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="17a40-109">Con los tipos de valor, cada variable tiene su propia copia de los datos y no es posible que las operaciones en una afecten a la otra.</span><span class="sxs-lookup"><span data-stu-id="17a40-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="17a40-110">C#el sistema de tipos de está unificado, de modo que un valor de cualquier tipo se puede tratar como un objeto.</span><span class="sxs-lookup"><span data-stu-id="17a40-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="17a40-111">Todos los tipos de C# directa o indirectamente se derivan del tipo de clase `object`, y `object` es la clase base definitiva de todos los tipos.</span><span class="sxs-lookup"><span data-stu-id="17a40-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="17a40-112">Los valores de tipos de referencia se tratan como objetos mediante la visualización de los valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="17a40-113">Los valores de los tipos de valor se tratan como objetos realizando las operaciones de conversión boxing y unboxing ([conversión boxing y conversión unboxing](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="17a40-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="17a40-114">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="17a40-114">Value types</span></span>

<span data-ttu-id="17a40-115">Un tipo de valor es un tipo de estructura o un tipo de enumeración.</span><span class="sxs-lookup"><span data-stu-id="17a40-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="17a40-116">C#proporciona un conjunto de tipos de struct predefinidos denominados ***tipos simples***.</span><span class="sxs-lookup"><span data-stu-id="17a40-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="17a40-117">Los tipos simples se identifican mediante palabras reservadas.</span><span class="sxs-lookup"><span data-stu-id="17a40-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="17a40-118">A diferencia de una variable de un tipo de referencia, una variable de un tipo de valor solo puede contener el valor `null` si el tipo de valor es un tipo que acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="17a40-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="17a40-119">Para cada tipo de valor que no acepta valores NULL hay un tipo de valor que acepta valores NULL correspondiente que denota el mismo conjunto de valores más el valor `null`.</span><span class="sxs-lookup"><span data-stu-id="17a40-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="17a40-120">La asignación a una variable de un tipo de valor crea una copia del valor que se va a asignar.</span><span class="sxs-lookup"><span data-stu-id="17a40-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="17a40-121">Esto difiere de la asignación a una variable de un tipo de referencia, que copia la referencia pero no el objeto identificado por la referencia.</span><span class="sxs-lookup"><span data-stu-id="17a40-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="17a40-122">Tipo System. ValueType</span><span class="sxs-lookup"><span data-stu-id="17a40-122">The System.ValueType type</span></span>

<span data-ttu-id="17a40-123">Todos los tipos de valor heredan implícitamente de la clase `System.ValueType`, que, a su vez, hereda de la clase `object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="17a40-124">No es posible que ningún tipo derive de un tipo de valor y, por tanto, los tipos de valor están sellados implícitamente ([clases selladas](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="17a40-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="17a40-125">Tenga en cuenta que `System.ValueType` no es *value_type*a sí mismo.</span><span class="sxs-lookup"><span data-stu-id="17a40-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="17a40-126">En su lugar, se trata de un *class_type* desde el que se derivan automáticamente todos los *value_type*s.</span><span class="sxs-lookup"><span data-stu-id="17a40-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="17a40-127">Constructores predeterminados</span><span class="sxs-lookup"><span data-stu-id="17a40-127">Default constructors</span></span>

<span data-ttu-id="17a40-128">Todos los tipos de valor declaran implícitamente un constructor de instancia sin parámetros público denominado ***constructor predeterminado***.</span><span class="sxs-lookup"><span data-stu-id="17a40-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="17a40-129">El constructor predeterminado devuelve una instancia inicializada en cero que se conoce como ***valor predeterminado*** para el tipo de valor:</span><span class="sxs-lookup"><span data-stu-id="17a40-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="17a40-130">En todos los *Simple_Type*s, el valor predeterminado es el valor generado por un patrón de bits de todos los ceros:</span><span class="sxs-lookup"><span data-stu-id="17a40-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="17a40-131">Para `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`y `ulong`, el valor predeterminado es `0`.</span><span class="sxs-lookup"><span data-stu-id="17a40-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="17a40-132">Por `char`, el valor predeterminado es `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="17a40-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="17a40-133">Por `float`, el valor predeterminado es `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="17a40-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="17a40-134">Por `double`, el valor predeterminado es `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="17a40-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="17a40-135">Por `decimal`, el valor predeterminado es `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="17a40-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="17a40-136">Por `bool`, el valor predeterminado es `false`.</span><span class="sxs-lookup"><span data-stu-id="17a40-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="17a40-137">Para un `E`*enum_type* , el valor predeterminado es `0`, convertido al tipo `E`.</span><span class="sxs-lookup"><span data-stu-id="17a40-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="17a40-138">En el caso de *struct_type*, el valor predeterminado es el valor generado al establecer todos los campos de tipo de valor en sus valores predeterminados y todos los campos de tipo de referencia en `null`.</span><span class="sxs-lookup"><span data-stu-id="17a40-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="17a40-139">En el caso de *nullable_type* , el valor predeterminado es una instancia para la que la propiedad `HasValue` es false y la propiedad `Value` es undefined.</span><span class="sxs-lookup"><span data-stu-id="17a40-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="17a40-140">El valor predeterminado también se conoce como el ***valor null*** del tipo que acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="17a40-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="17a40-141">Al igual que cualquier otro constructor de instancia, el constructor predeterminado de un tipo de valor se invoca mediante el operador `new`.</span><span class="sxs-lookup"><span data-stu-id="17a40-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="17a40-142">Por motivos de eficacia, este requisito no está diseñado para tener realmente la implementación que genera una llamada al constructor.</span><span class="sxs-lookup"><span data-stu-id="17a40-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="17a40-143">En el ejemplo siguiente, las variables `i` y `j` se inicializan en cero.</span><span class="sxs-lookup"><span data-stu-id="17a40-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="17a40-144">Dado que cada tipo de valor tiene implícitamente un constructor de instancia sin parámetros público, no es posible que un tipo de struct contenga una declaración explícita de un constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="17a40-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="17a40-145">Sin embargo, se permite que un tipo de estructura declare constructores de instancia con parámetros ([constructores](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="17a40-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="17a40-146">Tipos de estructura</span><span class="sxs-lookup"><span data-stu-id="17a40-146">Struct types</span></span>

<span data-ttu-id="17a40-147">Un tipo de estructura es un tipo de valor que puede declarar constantes, campos, métodos, propiedades, indizadores, operadores, constructores de instancias, constructores estáticos y tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="17a40-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="17a40-148">La declaración de tipos de struct se describe en [declaraciones de struct](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="17a40-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="17a40-149">Tipos simples</span><span class="sxs-lookup"><span data-stu-id="17a40-149">Simple types</span></span>

<span data-ttu-id="17a40-150">C#proporciona un conjunto de tipos de struct predefinidos denominados ***tipos simples***.</span><span class="sxs-lookup"><span data-stu-id="17a40-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="17a40-151">Los tipos simples se identifican mediante palabras reservadas, pero estas palabras reservadas son simplemente alias para los tipos de struct predefinidos en el espacio de nombres `System`, como se describe en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="17a40-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="17a40-152">__Palabra reservada__</span><span class="sxs-lookup"><span data-stu-id="17a40-152">__Reserved word__</span></span> | <span data-ttu-id="17a40-153">__Tipo con alias__</span><span class="sxs-lookup"><span data-stu-id="17a40-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="17a40-154">Dado que un tipo simple incluye un alias para un tipo de estructura, cada tipo simple tiene miembros.</span><span class="sxs-lookup"><span data-stu-id="17a40-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="17a40-155">Por ejemplo, `int` tiene los miembros declarados en `System.Int32` y los miembros heredados de `System.Object`, y se permiten las siguientes instrucciones:</span><span class="sxs-lookup"><span data-stu-id="17a40-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="17a40-156">Los tipos simples se diferencian de otros tipos struct en que permiten determinadas operaciones adicionales:</span><span class="sxs-lookup"><span data-stu-id="17a40-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="17a40-157">La mayoría de los tipos simples permiten crear valores escribiendo *literales* ([literales](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="17a40-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="17a40-158">Por ejemplo, `123` es un literal de tipo `int` y `'a'` es un literal de tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="17a40-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="17a40-159">C#no proporciona ningún aprovisionamiento para los literales de tipos struct en general y los valores no predeterminados de otros tipos struct siempre se crean en última instancia mediante constructores de instancias de esos tipos de estructura.</span><span class="sxs-lookup"><span data-stu-id="17a40-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="17a40-160">Cuando los operandos de una expresión son constantes de tipo simple, es posible que el compilador evalúe la expresión en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="17a40-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="17a40-161">Este tipo de expresión se conoce como *constant_expression* ([expresiones constantes](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="17a40-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="17a40-162">Las expresiones que implican operadores definidos por otros tipos struct no se consideran expresiones constantes.</span><span class="sxs-lookup"><span data-stu-id="17a40-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="17a40-163">A través de `const` declaraciones es posible declarar constantes de los tipos simples ([constantes](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="17a40-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="17a40-164">No es posible tener constantes de otros tipos struct, pero los campos `static readonly` proporcionan un efecto similar.</span><span class="sxs-lookup"><span data-stu-id="17a40-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="17a40-165">Las conversiones que implican tipos simples pueden participar en la evaluación de los operadores de conversión definidos por otros tipos struct, pero un operador de conversión definido por el usuario nunca puede participar en la evaluación de otro operador definido por el usuario ([evaluación de conversiones definidas por el usuario](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="17a40-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="17a40-166">Tipos enteros</span><span class="sxs-lookup"><span data-stu-id="17a40-166">Integral types</span></span>

<span data-ttu-id="17a40-167">C#admite nueve tipos enteros: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`y `char`.</span><span class="sxs-lookup"><span data-stu-id="17a40-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="17a40-168">Los tipos enteros tienen los siguientes tamaños y rangos de valores:</span><span class="sxs-lookup"><span data-stu-id="17a40-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="17a40-169">El tipo de `sbyte` representa enteros de 8 bits con signo con valores comprendidos entre-128 y 127.</span><span class="sxs-lookup"><span data-stu-id="17a40-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="17a40-170">El tipo de `byte` representa enteros de 8 bits sin signo con valores comprendidos entre 0 y 255.</span><span class="sxs-lookup"><span data-stu-id="17a40-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="17a40-171">El tipo de `short` representa enteros de 16 bits con signo con valores comprendidos entre-32768 y 32767.</span><span class="sxs-lookup"><span data-stu-id="17a40-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="17a40-172">El tipo de `ushort` representa enteros de 16 bits sin signo con valores comprendidos entre 0 y 65535.</span><span class="sxs-lookup"><span data-stu-id="17a40-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="17a40-173">El tipo de `int` representa enteros de 32 bits con signo con valores comprendidos entre-2147483648 y 2147483647.</span><span class="sxs-lookup"><span data-stu-id="17a40-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="17a40-174">El tipo de `uint` representa enteros de 32 bits sin signo con valores comprendidos entre 0 y 4294967295.</span><span class="sxs-lookup"><span data-stu-id="17a40-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="17a40-175">El tipo de `long` representa enteros de 64 bits con signo con valores comprendidos entre-9223372036854775808 y 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="17a40-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="17a40-176">El tipo de `ulong` representa enteros de 64 bits sin signo con valores comprendidos entre 0 y 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="17a40-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="17a40-177">El tipo de `char` representa enteros de 16 bits sin signo con valores comprendidos entre 0 y 65535.</span><span class="sxs-lookup"><span data-stu-id="17a40-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="17a40-178">El conjunto de valores posibles para el tipo de `char` corresponde al Juego de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="17a40-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="17a40-179">Aunque `char` tiene la misma representación que `ushort`, no todas las operaciones permitidas en un tipo se permiten en el otro.</span><span class="sxs-lookup"><span data-stu-id="17a40-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="17a40-180">Los operadores unarios y binarios de tipo entero siempre operan con una precisión de 32 bits con signo, una precisión de 32 bits sin signo, una precisión de 64 con signo o una precisión de bit 64 sin signo:</span><span class="sxs-lookup"><span data-stu-id="17a40-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="17a40-181">En el caso de los operadores unario `+` y `~`, el operando se convierte al tipo `T`, donde `T` es el primero de `int`, `uint`, `long`y `ulong` que pueden representar por completo todos los valores posibles del operando.</span><span class="sxs-lookup"><span data-stu-id="17a40-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="17a40-182">La operación se realiza entonces con la precisión de tipo `T`y el tipo del resultado es `T`.</span><span class="sxs-lookup"><span data-stu-id="17a40-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="17a40-183">Para el operador unario `-`, el operando se convierte al tipo `T`, donde `T` es el primero de `int` y `long` que pueden representar por completo todos los valores posibles del operando.</span><span class="sxs-lookup"><span data-stu-id="17a40-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="17a40-184">La operación se realiza entonces con la precisión de tipo `T`y el tipo del resultado es `T`.</span><span class="sxs-lookup"><span data-stu-id="17a40-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="17a40-185">No se puede aplicar el operador unario `-` a los operandos de tipo `ulong`.</span><span class="sxs-lookup"><span data-stu-id="17a40-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="17a40-186">Para los operadores binarios `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`y `<=` , los operandos se convierten al tipo `T`, donde `T` es el primero de `int`, `uint`, `long`y `ulong` que pueden representar por completo todos los valores posibles de ambos operandos.</span><span class="sxs-lookup"><span data-stu-id="17a40-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="17a40-187">A continuación, la operación se realiza utilizando la precisión de tipo `T`y el tipo del resultado es `T` (o `bool` para los operadores relacionales).</span><span class="sxs-lookup"><span data-stu-id="17a40-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="17a40-188">No se permite que un operando sea de tipo `long` y el otro es de tipo `ulong` con los operadores binarios.</span><span class="sxs-lookup"><span data-stu-id="17a40-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="17a40-189">En el caso de los operadores binarios `<<` y `>>`, el operando izquierdo se convierte al tipo `T`, donde `T` es el primero de `int`, `uint`, `long`y `ulong` que pueden representar por completo todos los valores posibles del operando.</span><span class="sxs-lookup"><span data-stu-id="17a40-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="17a40-190">La operación se realiza entonces con la precisión de tipo `T`y el tipo del resultado es `T`.</span><span class="sxs-lookup"><span data-stu-id="17a40-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="17a40-191">El tipo de `char` se clasifica como un tipo entero, pero difiere de los demás tipos enteros de dos maneras:</span><span class="sxs-lookup"><span data-stu-id="17a40-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="17a40-192">No hay ninguna conversión implícita de otros tipos al tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="17a40-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="17a40-193">En concreto, aunque los tipos `sbyte`, `byte`y `ushort` tienen intervalos de valores que se pueden representar completamente mediante el tipo de `char`, las conversiones implícitas de `sbyte`, `byte`o `ushort` a `char` no existen.</span><span class="sxs-lookup"><span data-stu-id="17a40-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="17a40-194">Las constantes del tipo `char` deben escribirse como *character_literal*s o como *integer_literal*s en combinación con una conversión al tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="17a40-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="17a40-195">Por ejemplo, `(char)10` es lo mismo que `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="17a40-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="17a40-196">Los operadores y las instrucciones `checked` y `unchecked` se utilizan para controlar la comprobación de desbordamiento para las operaciones aritméticas de tipo entero y las conversiones ([los operadores Checked y unchecked](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="17a40-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="17a40-197">En un contexto de `checked`, un desbordamiento produce un error en tiempo de compilación o hace que se inicie una `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="17a40-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="17a40-198">En un contexto de `unchecked`, se omiten los desbordamientos y se descartan los bits de orden superior que no caben en el tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="17a40-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="17a40-199">Tipos de punto flotante</span><span class="sxs-lookup"><span data-stu-id="17a40-199">Floating point types</span></span>

<span data-ttu-id="17a40-200">C#admite dos tipos de punto flotante: `float` y `double`.</span><span class="sxs-lookup"><span data-stu-id="17a40-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="17a40-201">Los tipos `float` y `double` se representan mediante los formatos IEEE 754 de precisión sencilla de 32 bits y de doble precisión de 64 bits, que proporcionan los siguientes conjuntos de valores:</span><span class="sxs-lookup"><span data-stu-id="17a40-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="17a40-202">Cero positivo y cero negativo.</span><span class="sxs-lookup"><span data-stu-id="17a40-202">Positive zero and negative zero.</span></span> <span data-ttu-id="17a40-203">En la mayoría de los casos, cero positivo y cero negativo se comportan exactamente igual que el valor cero simple, pero ciertas operaciones distinguen entre los dos ([operador de división](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="17a40-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="17a40-204">Infinito positivo y infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="17a40-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="17a40-205">Dichas operaciones producen infinitos, como la división de un número distinto de cero por cero.</span><span class="sxs-lookup"><span data-stu-id="17a40-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="17a40-206">Por ejemplo, `1.0 / 0.0` produce infinito positivo y `-1.0 / 0.0` produce infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="17a40-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="17a40-207">El valor ***no numérico*** , a menudo abreviado como Nan.</span><span class="sxs-lookup"><span data-stu-id="17a40-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="17a40-208">Los Nan se generan mediante operaciones de punto flotante no válidas, como la división de cero por cero.</span><span class="sxs-lookup"><span data-stu-id="17a40-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="17a40-209">El conjunto finito de valores distintos de cero del formulario `s * m * 2^e`, donde `s` es 1 o-1, y `m` y `e` vienen determinados por el tipo de punto flotante determinado: por `float`, `0 < m < 2^24` y `-149 <= e <= 104`y para `double`, `0 < m < 2^53` y `-1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="17a40-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `-1075 <= e <= 970`.</span></span> <span data-ttu-id="17a40-210">Los números de punto flotante desnormalizados se consideran valores distintos de cero válidos.</span><span class="sxs-lookup"><span data-stu-id="17a40-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="17a40-211">El tipo de `float` puede representar valores comprendidos entre aproximadamente `1.5 * 10^-45` para `3.4 * 10^38` con una precisión de 7 dígitos.</span><span class="sxs-lookup"><span data-stu-id="17a40-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="17a40-212">El tipo de `double` puede representar valores que van desde aproximadamente `5.0 * 10^-324` a `1.7 × 10^308` con una precisión de 15-16 dígitos.</span><span class="sxs-lookup"><span data-stu-id="17a40-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="17a40-213">Si uno de los operandos de un operador binario es de un tipo de punto flotante, el otro operando debe ser de un tipo entero o de un tipo de punto flotante, y la operación se evalúa como sigue:</span><span class="sxs-lookup"><span data-stu-id="17a40-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="17a40-214">Si uno de los operandos es de un tipo entero, ese operando se convierte en el tipo de punto flotante del otro operando.</span><span class="sxs-lookup"><span data-stu-id="17a40-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="17a40-215">Después, si alguno de los operandos es de tipo `double`, el otro operando se convierte en `double`, la operación se realiza utilizando al menos `double` intervalo y precisión, y el tipo del resultado es `double` (o `bool` para los operadores relacionales).</span><span class="sxs-lookup"><span data-stu-id="17a40-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="17a40-216">De lo contrario, la operación se realiza utilizando al menos `float` intervalo y la precisión, y el tipo del resultado es `float` (o `bool` para los operadores relacionales).</span><span class="sxs-lookup"><span data-stu-id="17a40-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="17a40-217">Los operadores de punto flotante, incluidos los operadores de asignación, nunca generan excepciones.</span><span class="sxs-lookup"><span data-stu-id="17a40-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="17a40-218">En su lugar, en situaciones excepcionales, las operaciones de punto flotante producen cero, infinito o NaN, como se describe a continuación:</span><span class="sxs-lookup"><span data-stu-id="17a40-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="17a40-219">Si el resultado de una operación de punto flotante es demasiado pequeño para el formato de destino, el resultado de la operación se convierte en cero positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="17a40-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="17a40-220">Si el resultado de una operación de punto flotante es demasiado grande para el formato de destino, el resultado de la operación se convierte en infinito positivo o infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="17a40-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="17a40-221">Si una operación de punto flotante no es válida, el resultado de la operación se convierte en NaN.</span><span class="sxs-lookup"><span data-stu-id="17a40-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="17a40-222">Si uno o ambos operandos de una operación de punto flotante son NaN, el resultado de la operación se convierte en NaN.</span><span class="sxs-lookup"><span data-stu-id="17a40-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="17a40-223">Las operaciones de punto flotante se pueden realizar con una precisión mayor que el tipo de resultado de la operación.</span><span class="sxs-lookup"><span data-stu-id="17a40-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="17a40-224">Por ejemplo, algunas arquitecturas de hardware admiten un tipo de punto flotante "extendido" o "Long Double" con un intervalo y una precisión mayores que el tipo de `double` y realizan implícitamente todas las operaciones de punto flotante con este tipo de precisión superior.</span><span class="sxs-lookup"><span data-stu-id="17a40-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="17a40-225">Solo con un costo excesivo en el rendimiento se pueden realizar estas arquitecturas de hardware para realizar operaciones de punto flotante con menos precisión, y en lugar de requerir una implementación para que pierda C# rendimiento y precisión, permite un tipo de precisión mayor. que se va a utilizar para todas las operaciones de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="17a40-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="17a40-226">Aparte de ofrecer resultados más precisos, esto rara vez tiene efectos medibles.</span><span class="sxs-lookup"><span data-stu-id="17a40-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="17a40-227">Sin embargo, en las expresiones con el formato `x * y / z`, donde la multiplicación genera un resultado que está fuera del intervalo de `double`, pero la división posterior devuelve el resultado temporal al intervalo de `double`, el hecho de que la expresión se evalúa en un un formato de intervalo superior puede provocar que se genere un resultado finito en lugar de un infinito.</span><span class="sxs-lookup"><span data-stu-id="17a40-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="17a40-228">Tipo decimal</span><span class="sxs-lookup"><span data-stu-id="17a40-228">The decimal type</span></span>

<span data-ttu-id="17a40-229">El tipo `decimal` es un tipo de datos de 128 bits adecuado para cálculos financieros y monetarios.</span><span class="sxs-lookup"><span data-stu-id="17a40-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="17a40-230">El tipo de `decimal` puede representar valores comprendidos entre `1.0 * 10^-28` aproximadamente `7.9 * 10^28` con 28-29 dígitos significativos.</span><span class="sxs-lookup"><span data-stu-id="17a40-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="17a40-231">El conjunto finito de valores de tipo `decimal` tiene el formato `(-1)^s * c * 10^-e`, donde el signo `s` es 0 ó 1, el coeficiente `c` viene dado por `0 <= *c* < 2^96`y el `e` de escala es tal que `0 <= e <= 28`. El tipo de `decimal` no admite ceros con signo, infinitos o NaN.</span><span class="sxs-lookup"><span data-stu-id="17a40-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="17a40-232">Un `decimal` se representa como un entero de 96 bits escalado por una potencia de diez.</span><span class="sxs-lookup"><span data-stu-id="17a40-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="17a40-233">En el caso de `decimal`s con un valor absoluto inferior a `1.0m`, el valor es exacto hasta la posición decimal 28, pero no más.</span><span class="sxs-lookup"><span data-stu-id="17a40-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="17a40-234">Para `decimal`s con un valor absoluto mayor o igual que `1.0m`, el valor es exacto a 28 o 29 dígitos.</span><span class="sxs-lookup"><span data-stu-id="17a40-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="17a40-235">Al contrario que los tipos de datos `float` y `double`, los números fraccionarios decimales como 0,1 se pueden representar exactamente en la representación `decimal`.</span><span class="sxs-lookup"><span data-stu-id="17a40-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="17a40-236">En las representaciones de `float` y `double`, estos números suelen ser fracciones infinitas, por lo que las representaciones son más propensas a errores de redondeo.</span><span class="sxs-lookup"><span data-stu-id="17a40-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="17a40-237">Si uno de los operandos de un operador binario es de tipo `decimal`, el otro operando debe ser de un tipo entero o de un tipo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="17a40-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="17a40-238">Si hay un operando de tipo entero, se convierte en `decimal` antes de que se realice la operación.</span><span class="sxs-lookup"><span data-stu-id="17a40-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="17a40-239">El resultado de una operación con valores de tipo `decimal` es que resultaría de calcular un resultado exacto (conservando la escala, tal y como se define para cada operador) y, a continuación, redondear para ajustarse a la representación.</span><span class="sxs-lookup"><span data-stu-id="17a40-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="17a40-240">Los resultados se redondean al valor representable más cercano y, cuando un resultado está igualmente cerca de dos valores representables, al valor que tiene un número par en la posición del dígito menos significativo (esto se conoce como "redondeo bancario").</span><span class="sxs-lookup"><span data-stu-id="17a40-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="17a40-241">Un resultado de cero siempre tiene un signo de 0 y una escala de 0.</span><span class="sxs-lookup"><span data-stu-id="17a40-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="17a40-242">Si una operación aritmética decimal produce un valor menor o igual que `5 * 10^-29` en valor absoluto, el resultado de la operación se convierte en cero.</span><span class="sxs-lookup"><span data-stu-id="17a40-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="17a40-243">Si una operación aritmética `decimal` genera un resultado que es demasiado grande para el formato de `decimal`, se produce una `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="17a40-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="17a40-244">El tipo de `decimal` tiene una precisión mayor pero menor que los tipos de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="17a40-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="17a40-245">Por lo tanto, las conversiones de los tipos de punto flotante a `decimal` pueden producir excepciones de desbordamiento, y las conversiones de `decimal` a los tipos de punto flotante podrían provocar la pérdida de precisión.</span><span class="sxs-lookup"><span data-stu-id="17a40-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="17a40-246">Por estos motivos, no existe ninguna conversión implícita entre los tipos de punto flotante y `decimal`, y sin conversiones explícitas, no es posible mezclar operandos de punto flotante y `decimal` en la misma expresión.</span><span class="sxs-lookup"><span data-stu-id="17a40-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="17a40-247">Tipo bool</span><span class="sxs-lookup"><span data-stu-id="17a40-247">The bool type</span></span>

<span data-ttu-id="17a40-248">El tipo de `bool` representa las cantidades lógicas booleanas.</span><span class="sxs-lookup"><span data-stu-id="17a40-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="17a40-249">Los valores posibles de tipo `bool` son `true` y `false`.</span><span class="sxs-lookup"><span data-stu-id="17a40-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="17a40-250">No existe ninguna conversión estándar entre `bool` y otros tipos.</span><span class="sxs-lookup"><span data-stu-id="17a40-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="17a40-251">En concreto, el tipo de `bool` es distinto y separado de los tipos enteros, y no se puede usar un valor `bool` en lugar de un valor entero y viceversa.</span><span class="sxs-lookup"><span data-stu-id="17a40-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="17a40-252">En los lenguajes C++ C y, un valor entero o de punto flotante cero, o un puntero nulo se puede convertir al valor booleano `false`, y un valor entero o de punto flotante distinto de cero, o un puntero no nulo se puede convertir al valor booleano `true`.</span><span class="sxs-lookup"><span data-stu-id="17a40-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="17a40-253">En C#, estas conversiones se realizan comparando explícitamente un valor entero o de punto flotante en cero, o comparando explícitamente una referencia de objeto a `null`.</span><span class="sxs-lookup"><span data-stu-id="17a40-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="17a40-254">Tipos de enumeración</span><span class="sxs-lookup"><span data-stu-id="17a40-254">Enumeration types</span></span>

<span data-ttu-id="17a40-255">Un tipo de enumeración es un tipo distinto con constantes con nombre.</span><span class="sxs-lookup"><span data-stu-id="17a40-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="17a40-256">Cada tipo de enumeración tiene un tipo subyacente, que debe ser `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` o `ulong`.</span><span class="sxs-lookup"><span data-stu-id="17a40-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="17a40-257">El conjunto de valores del tipo de enumeración es el mismo que el conjunto de valores del tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="17a40-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="17a40-258">Los valores del tipo de enumeración no están restringidos a los valores de las constantes con nombre.</span><span class="sxs-lookup"><span data-stu-id="17a40-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="17a40-259">Los tipos de enumeración se definen mediante declaraciones de enumeración ([declaraciones](enums.md#enum-declarations)de enumeración).</span><span class="sxs-lookup"><span data-stu-id="17a40-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="17a40-260">Tipos que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="17a40-260">Nullable types</span></span>

<span data-ttu-id="17a40-261">Un tipo que acepta valores NULL puede representar todos los valores de su ***tipo subyacente*** más un valor null adicional.</span><span class="sxs-lookup"><span data-stu-id="17a40-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="17a40-262">Un tipo que acepta valores NULL se escribe `T?`, donde `T` es el tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="17a40-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="17a40-263">Esta sintaxis es una abreviatura de `System.Nullable<T>`y las dos formas se pueden usar indistintamente.</span><span class="sxs-lookup"><span data-stu-id="17a40-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="17a40-264">Un ***tipo de valor que no acepta valores NULL*** es un tipo de valor distinto de `System.Nullable<T>` y su `T?` abreviado (para cualquier `T`), además de cualquier parámetro de tipo restringido para ser un tipo de valor que no acepta valores NULL (es decir, cualquier parámetro de tipo con una `struct` restricción).</span><span class="sxs-lookup"><span data-stu-id="17a40-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="17a40-265">El tipo de `System.Nullable<T>` especifica la restricción de tipo de valor para `T` ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)), lo que significa que el tipo subyacente de un tipo que acepta valores NULL puede ser cualquier tipo de valor que no acepte valores NULL.</span><span class="sxs-lookup"><span data-stu-id="17a40-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="17a40-266">El tipo subyacente de un tipo que acepta valores NULL no puede ser un tipo que acepta valores NULL ni un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="17a40-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="17a40-267">Por ejemplo, `int??` y `string?` son tipos no válidos.</span><span class="sxs-lookup"><span data-stu-id="17a40-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="17a40-268">Una instancia de un tipo que acepta valores NULL `T?` tiene dos propiedades públicas de solo lectura:</span><span class="sxs-lookup"><span data-stu-id="17a40-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="17a40-269">Propiedad `HasValue` de tipo `bool`</span><span class="sxs-lookup"><span data-stu-id="17a40-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="17a40-270">Propiedad `Value` de tipo `T`</span><span class="sxs-lookup"><span data-stu-id="17a40-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="17a40-271">Una instancia para la que `HasValue` es true se dice que no es NULL.</span><span class="sxs-lookup"><span data-stu-id="17a40-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="17a40-272">Una instancia no NULL contiene un valor conocido y `Value` devuelve ese valor.</span><span class="sxs-lookup"><span data-stu-id="17a40-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="17a40-273">Una instancia para la que `HasValue` es false se dice que es NULL.</span><span class="sxs-lookup"><span data-stu-id="17a40-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="17a40-274">Una instancia null tiene un valor sin definir.</span><span class="sxs-lookup"><span data-stu-id="17a40-274">A null instance has an undefined value.</span></span> <span data-ttu-id="17a40-275">Al intentar leer el `Value` de una instancia null, se produce una `System.InvalidOperationException`.</span><span class="sxs-lookup"><span data-stu-id="17a40-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="17a40-276">El proceso de acceso a la propiedad `Value` de una instancia que acepta valores NULL se conoce como ***desencapsulado***.</span><span class="sxs-lookup"><span data-stu-id="17a40-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="17a40-277">Además del constructor predeterminado, todos los tipos que aceptan valores NULL `T?` tienen un constructor público que toma un único argumento de tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="17a40-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="17a40-278">Dado un valor `x` de tipo `T`, una invocación del constructor con el formato</span><span class="sxs-lookup"><span data-stu-id="17a40-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="17a40-279">crea una instancia no NULL de `T?` para la que se `x`la propiedad `Value`.</span><span class="sxs-lookup"><span data-stu-id="17a40-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="17a40-280">El proceso de creación de una instancia no NULL de un tipo que acepta valores NULL para un valor determinado se conoce como ***ajuste***.</span><span class="sxs-lookup"><span data-stu-id="17a40-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="17a40-281">Las conversiones implícitas están disponibles desde el literal `null` a `T?` ([conversiones de literales null](conversions.md#null-literal-conversions)) y de `T` a `T?` ([conversiones implícitas que aceptan valores NULL](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="17a40-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="17a40-282">Tipos de referencia</span><span class="sxs-lookup"><span data-stu-id="17a40-282">Reference types</span></span>

<span data-ttu-id="17a40-283">Un tipo de referencia es un tipo de clase, un tipo de interfaz, un tipo de matriz o un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="17a40-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="17a40-284">Un valor de tipo de referencia es una referencia a una ***instancia*** del tipo, la última conocida como un ***objeto***.</span><span class="sxs-lookup"><span data-stu-id="17a40-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="17a40-285">El valor especial `null` es compatible con todos los tipos de referencia e indica la ausencia de una instancia.</span><span class="sxs-lookup"><span data-stu-id="17a40-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="17a40-286">Tipos de clase</span><span class="sxs-lookup"><span data-stu-id="17a40-286">Class types</span></span>

<span data-ttu-id="17a40-287">Un tipo de clase define una estructura de datos que contiene miembros de datos (constantes y campos), miembros de función (métodos, propiedades, eventos, indizadores, operadores, constructores de instancias, destructores y constructores estáticos) y tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="17a40-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="17a40-288">Los tipos de clase admiten la herencia, un mecanismo por el que las clases derivadas pueden extender y especializar clases base.</span><span class="sxs-lookup"><span data-stu-id="17a40-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="17a40-289">Las instancias de tipos de clase se crean mediante *object_creation_expression*s ([expresiones de creación de objetos](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="17a40-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="17a40-290">Los tipos de clase se describen en [clases](classes.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="17a40-291">Algunos tipos de clase predefinidos tienen un significado C# especial en el idioma, tal y como se describe en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="17a40-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="17a40-292">__Tipo de clase__</span><span class="sxs-lookup"><span data-stu-id="17a40-292">__Class type__</span></span>     | <span data-ttu-id="17a40-293">__Descripción__</span><span class="sxs-lookup"><span data-stu-id="17a40-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="17a40-294">Última clase base de todos los demás tipos.</span><span class="sxs-lookup"><span data-stu-id="17a40-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="17a40-295">Vea [el tipo de objeto](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="17a40-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="17a40-296">Tipo de cadena del C# lenguaje.</span><span class="sxs-lookup"><span data-stu-id="17a40-296">The string type of the C# language.</span></span> <span data-ttu-id="17a40-297">Vea [el tipo de cadena](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="17a40-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="17a40-298">Clase base de todos los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="17a40-298">The base class of all value types.</span></span> <span data-ttu-id="17a40-299">Vea [el tipo System. ValueType](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="17a40-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="17a40-300">La clase base de todos los tipos de enumeración.</span><span class="sxs-lookup"><span data-stu-id="17a40-300">The base class of all enum types.</span></span> <span data-ttu-id="17a40-301">Vea [enumeraciones](enums.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="17a40-302">La clase base de todos los tipos de matriz.</span><span class="sxs-lookup"><span data-stu-id="17a40-302">The base class of all array types.</span></span> <span data-ttu-id="17a40-303">Vea [Matrices](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="17a40-304">La clase base de todos los tipos de delegado.</span><span class="sxs-lookup"><span data-stu-id="17a40-304">The base class of all delegate types.</span></span> <span data-ttu-id="17a40-305">Vea [delegados](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="17a40-306">La clase base de todos los tipos de excepción.</span><span class="sxs-lookup"><span data-stu-id="17a40-306">The base class of all exception types.</span></span> <span data-ttu-id="17a40-307">Vea [excepciones](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="17a40-308">Tipo object</span><span class="sxs-lookup"><span data-stu-id="17a40-308">The object type</span></span>

<span data-ttu-id="17a40-309">El tipo de clase `object` es la última clase base de todos los demás tipos.</span><span class="sxs-lookup"><span data-stu-id="17a40-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="17a40-310">Cada tipo se C# deriva directa o indirectamente del tipo de clase `object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="17a40-311">La palabra clave `object` es simplemente un alias para la clase predefinida `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="17a40-312">Tipo dynamic</span><span class="sxs-lookup"><span data-stu-id="17a40-312">The dynamic type</span></span>

<span data-ttu-id="17a40-313">El tipo de `dynamic`, como `object`, puede hacer referencia a cualquier objeto.</span><span class="sxs-lookup"><span data-stu-id="17a40-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="17a40-314">Cuando se aplican operadores a expresiones de tipo `dynamic`, su resolución se aplaza hasta que se ejecuta el programa.</span><span class="sxs-lookup"><span data-stu-id="17a40-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="17a40-315">Por lo tanto, si el operador no se puede aplicar legalmente al objeto al que se hace referencia, no se proporciona ningún error durante la compilación.</span><span class="sxs-lookup"><span data-stu-id="17a40-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="17a40-316">En su lugar, se producirá una excepción cuando se produzca un error en la resolución del operador en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="17a40-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="17a40-317">Su finalidad es permitir el enlace dinámico, que se describe en detalle en el [enlace dinámico](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="17a40-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="17a40-318">`dynamic` se considera idéntica a `object` excepto en los siguientes aspectos:</span><span class="sxs-lookup"><span data-stu-id="17a40-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="17a40-319">Las operaciones en expresiones de tipo `dynamic` se pueden enlazar dinámicamente ([enlace dinámico](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="17a40-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="17a40-320">La inferencia de tipos ([inferencia de tipos](expressions.md#type-inference)) preferirá `dynamic` sobre `object` si ambos son candidatos.</span><span class="sxs-lookup"><span data-stu-id="17a40-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="17a40-321">Debido a esta equivalencia, lo siguiente incluye:</span><span class="sxs-lookup"><span data-stu-id="17a40-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="17a40-322">Existe una conversión implícita de identidad entre `object` y `dynamic`, y entre tipos construidos que son iguales al reemplazar `dynamic` por `object`</span><span class="sxs-lookup"><span data-stu-id="17a40-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="17a40-323">Las conversiones implícitas y explícitas a y desde `object` también se aplican a y desde `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="17a40-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="17a40-324">Las firmas de método que son iguales al reemplazar `dynamic` por `object` se consideran la misma firma</span><span class="sxs-lookup"><span data-stu-id="17a40-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="17a40-325">No se distingue el tipo `dynamic` de `object` en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="17a40-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="17a40-326">Una expresión de tipo `dynamic` se conoce como una ***expresión dinámica***.</span><span class="sxs-lookup"><span data-stu-id="17a40-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="17a40-327">Tipo string</span><span class="sxs-lookup"><span data-stu-id="17a40-327">The string type</span></span>

<span data-ttu-id="17a40-328">El tipo de `string` es un tipo de clase sellado que hereda directamente de `object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="17a40-329">Las instancias de la clase `string` representan cadenas de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="17a40-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="17a40-330">Los valores del tipo `string` pueden escribirse como literales de cadena ([literales de cadena](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="17a40-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="17a40-331">La palabra clave `string` es simplemente un alias para la clase predefinida `System.String`.</span><span class="sxs-lookup"><span data-stu-id="17a40-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="17a40-332">Tipos de interfaz</span><span class="sxs-lookup"><span data-stu-id="17a40-332">Interface types</span></span>

<span data-ttu-id="17a40-333">Una interfaz define un contrato.</span><span class="sxs-lookup"><span data-stu-id="17a40-333">An interface defines a contract.</span></span> <span data-ttu-id="17a40-334">Una clase o estructura que implementa una interfaz debe adherirse a su contrato.</span><span class="sxs-lookup"><span data-stu-id="17a40-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="17a40-335">Una interfaz puede heredar de varias interfaces base, y una clase o estructura puede implementar varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="17a40-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="17a40-336">Los tipos de interfaz se describen en [interfaces](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="17a40-337">Tipos de matriz</span><span class="sxs-lookup"><span data-stu-id="17a40-337">Array types</span></span>

<span data-ttu-id="17a40-338">Una matriz es una estructura de datos que contiene cero o más variables a las que se tiene acceso a través de índices calculados.</span><span class="sxs-lookup"><span data-stu-id="17a40-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="17a40-339">Las variables contenidas en una matriz, también denominadas elementos de la matriz, son todas del mismo tipo, y este tipo se denomina tipo de elemento de la matriz.</span><span class="sxs-lookup"><span data-stu-id="17a40-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="17a40-340">Los tipos de matriz se describen en [matrices](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="17a40-341">Tipos delegados</span><span class="sxs-lookup"><span data-stu-id="17a40-341">Delegate types</span></span>

<span data-ttu-id="17a40-342">Un delegado es una estructura de datos que hace referencia a uno o más métodos.</span><span class="sxs-lookup"><span data-stu-id="17a40-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="17a40-343">En el caso de los métodos de instancia, también hace referencia a sus instancias de objeto correspondientes.</span><span class="sxs-lookup"><span data-stu-id="17a40-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="17a40-344">El equivalente más cercano de un delegado en C C++ o es un puntero de función, pero mientras que un puntero de función solo puede hacer referencia a funciones estáticas, un delegado puede hacer referencia a métodos estáticos y de instancia.</span><span class="sxs-lookup"><span data-stu-id="17a40-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="17a40-345">En el último caso, el delegado almacena no solo una referencia al punto de entrada del método, sino también una referencia a la instancia de objeto en la que se invoca el método.</span><span class="sxs-lookup"><span data-stu-id="17a40-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="17a40-346">Los tipos de delegado se describen en [delegados](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="17a40-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="17a40-347">Conversión boxing y conversión unboxing</span><span class="sxs-lookup"><span data-stu-id="17a40-347">Boxing and unboxing</span></span>

<span data-ttu-id="17a40-348">El concepto de conversión boxing y unboxing es central C#para el sistema de tipos de.</span><span class="sxs-lookup"><span data-stu-id="17a40-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="17a40-349">Proporciona un puente entre *value_type*s y *reference_type*s, ya que permite que cualquier valor de una *value_type* se convierta al tipo `object`y desde este.</span><span class="sxs-lookup"><span data-stu-id="17a40-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="17a40-350">Las conversiones boxing y unboxing permiten una vista unificada del sistema de tipos en el que un valor de cualquier tipo se puede tratar en última instancia como un objeto.</span><span class="sxs-lookup"><span data-stu-id="17a40-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="17a40-351">Conversiones Boxing</span><span class="sxs-lookup"><span data-stu-id="17a40-351">Boxing conversions</span></span>

<span data-ttu-id="17a40-352">Una conversión boxing permite que un *value_type* se convierta implícitamente en un *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="17a40-353">Existen las siguientes conversiones Boxing:</span><span class="sxs-lookup"><span data-stu-id="17a40-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="17a40-354">De cualquier *value_type* al tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="17a40-355">De cualquier *value_type* al tipo `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="17a40-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="17a40-356">De cualquier *non_nullable_value_type* a cualquier *interface_type* implementado por *value_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="17a40-357">De cualquier *nullable_type* a cualquier *interface_type* implementado por el tipo subyacente de *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="17a40-358">De cualquier *enum_type* al tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="17a40-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="17a40-359">Desde cualquier *nullable_type* con un *enum_type* subyacente al tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="17a40-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="17a40-360">Tenga en cuenta que una conversión implícita de un parámetro de tipo se ejecutará como conversión boxing si en tiempo de ejecución termina la conversión de un tipo de valor a un tipo de referencia ([conversiones implícitas que implican parámetros de tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="17a40-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="17a40-361">La conversión boxing de un valor de *non_nullable_value_type* consiste en asignar una instancia de objeto y copiar el valor de *non_nullable_value_type* en esa instancia.</span><span class="sxs-lookup"><span data-stu-id="17a40-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="17a40-362">La conversión boxing de un valor de *nullable_type* genera una referencia nula si es el valor `null` (`HasValue` se `false`) o el resultado de desencapsular y convertir en Boxing el valor subyacente en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="17a40-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="17a40-363">El proceso real de conversión boxing de un valor de *non_nullable_value_type* se explica mejor al imaginarse la existencia de una ***clase de conversión boxing***genérica, que se comporta como si se hubiese declarado de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="17a40-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="17a40-364">La conversión boxing de un valor `v` de tipo `T` ahora consiste en ejecutar la expresión `new Box<T>(v)`y devolver la instancia resultante como un valor de tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="17a40-365">Por lo tanto, las instrucciones</span><span class="sxs-lookup"><span data-stu-id="17a40-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="17a40-366">se corresponden conceptualmente con</span><span class="sxs-lookup"><span data-stu-id="17a40-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="17a40-367">Una clase de conversión boxing como `Box<T>` anterior no existe realmente y el tipo dinámico de un valor de conversión boxing no es realmente un tipo de clase.</span><span class="sxs-lookup"><span data-stu-id="17a40-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="17a40-368">En su lugar, un valor con conversión boxing de tipo `T` tiene el tipo dinámico `T`y una comprobación de tipos dinámicos mediante el operador `is` puede simplemente hacer referencia a `T`de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="17a40-369">Por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="17a40-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="17a40-370">generará la cadena "`Box contains an int`" en la consola.</span><span class="sxs-lookup"><span data-stu-id="17a40-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="17a40-371">Una conversión boxing implica que se realice una copia del valor al que se va a aplicar la conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="17a40-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="17a40-372">Esto es diferente de la conversión de *reference_type* al tipo `object`, en el que el valor sigue haciendo referencia a la misma instancia y simplemente se considera el tipo menos derivado `object`.</span><span class="sxs-lookup"><span data-stu-id="17a40-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="17a40-373">Por ejemplo, dada la declaración</span><span class="sxs-lookup"><span data-stu-id="17a40-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="17a40-374">las instrucciones siguientes</span><span class="sxs-lookup"><span data-stu-id="17a40-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="17a40-375">generará el valor 10 en la consola porque la operación de conversión boxing implícita que se produce en la asignación de `p` a `box` hace que se copie el valor de `p`.</span><span class="sxs-lookup"><span data-stu-id="17a40-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="17a40-376">Si `Point` ha declarado un `class` en su lugar, se generará el valor 20 porque `p` y `box` harían referencia a la misma instancia.</span><span class="sxs-lookup"><span data-stu-id="17a40-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="17a40-377">Conversiones unboxing</span><span class="sxs-lookup"><span data-stu-id="17a40-377">Unboxing conversions</span></span>

<span data-ttu-id="17a40-378">Una conversión unboxing permite que un *reference_type* se convierta explícitamente en un *value_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="17a40-379">Existen las siguientes conversiones unboxing:</span><span class="sxs-lookup"><span data-stu-id="17a40-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="17a40-380">Del tipo `object` a cualquier *value_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="17a40-381">Del tipo `System.ValueType` a cualquier *value_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="17a40-382">De cualquier *interface_type* a cualquier *non_nullable_value_type* que implemente *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="17a40-383">De cualquier *interface_type* a cualquier *nullable_type* cuyo tipo subyacente implementa *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="17a40-384">Del tipo `System.Enum` a cualquier *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="17a40-385">Del tipo `System.Enum` a cualquier *nullable_type* con un *enum_type*subyacente.</span><span class="sxs-lookup"><span data-stu-id="17a40-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="17a40-386">Tenga en cuenta que una conversión explícita a un parámetro de tipo se ejecutará como una conversión unboxing si en tiempo de ejecución termina la conversión de un tipo de referencia a un tipo de valor ([conversiones dinámicas explícitas](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="17a40-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="17a40-387">Una operación de conversión unboxing a un *non_nullable_value_type* consiste en comprobar primero que la instancia de objeto es un valor de conversión boxing de la *non_nullable_value_type*especificada y, a continuación, copiar el valor fuera de la instancia.</span><span class="sxs-lookup"><span data-stu-id="17a40-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="17a40-388">La conversión unboxing a un *nullable_type* genera el valor null de *nullable_type* si el operando de origen es `null`, o el resultado ajustado de la conversión unboxing de la instancia de objeto en el tipo subyacente del *nullable_type* en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="17a40-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="17a40-389">Al hacer referencia a la clase de conversión boxing imaginaria descrita en la sección anterior, una conversión unboxing de un objeto `box` a un `T` *value_type* consiste en ejecutar la expresión `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="17a40-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="17a40-390">Por lo tanto, las instrucciones</span><span class="sxs-lookup"><span data-stu-id="17a40-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="17a40-391">se corresponden conceptualmente con</span><span class="sxs-lookup"><span data-stu-id="17a40-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="17a40-392">Para que una conversión unboxing a un *non_nullable_value_type* determinado se realice correctamente en tiempo de ejecución, el valor del operando de origen debe ser una referencia a un valor de conversión boxing de ese *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="17a40-393">Si el operando de origen es `null`, se produce una `System.NullReferenceException`.</span><span class="sxs-lookup"><span data-stu-id="17a40-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="17a40-394">Si el operando de origen es una referencia a un objeto incompatible, se produce una `System.InvalidCastException`.</span><span class="sxs-lookup"><span data-stu-id="17a40-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="17a40-395">Para que una conversión unboxing a un *nullable_type* determinado se realice correctamente en tiempo de ejecución, el valor del operando de origen debe ser `null` o una referencia a un valor de conversión boxing de la *non_nullable_value_type* subyacente de *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="17a40-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="17a40-396">Si el operando de origen es una referencia a un objeto incompatible, se produce una `System.InvalidCastException`.</span><span class="sxs-lookup"><span data-stu-id="17a40-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="17a40-397">Tipos construidos</span><span class="sxs-lookup"><span data-stu-id="17a40-397">Constructed types</span></span>

<span data-ttu-id="17a40-398">Una declaración de tipo genérico, por sí sola, denota un ***tipo genérico sin enlazar*** que se usa como "Blueprint" para formar muchos tipos diferentes, por medio de la aplicación de ***argumentos de tipo***.</span><span class="sxs-lookup"><span data-stu-id="17a40-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="17a40-399">Los argumentos de tipo se escriben entre corchetes angulares (`<` y `>`) inmediatamente después del nombre del tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="17a40-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="17a40-400">Un tipo que incluye al menos un argumento de tipo se denomina ***tipo construido***.</span><span class="sxs-lookup"><span data-stu-id="17a40-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="17a40-401">Un tipo construido se puede usar en la mayoría de los lugares del lenguaje en el que puede aparecer un nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="17a40-402">Un tipo genérico sin enlazar solo se puede usar dentro de un *typeof_expression* ([el operador typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="17a40-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="17a40-403">Los tipos construidos también se pueden usar en expresiones como nombres simples ([nombres simples](expressions.md#simple-names)) o al obtener acceso a un miembro ([acceso a miembros](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="17a40-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="17a40-404">Cuando se evalúa un *namespace_or_type_name* , solo se tienen en cuenta los tipos genéricos con el número correcto de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="17a40-405">Por lo tanto, es posible usar el mismo identificador para identificar distintos tipos, siempre que los tipos tengan distintos números de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="17a40-406">Esto resulta útil cuando se combinan clases genéricas y no genéricas en el mismo programa:</span><span class="sxs-lookup"><span data-stu-id="17a40-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="17a40-407">Un *type_name* podría identificar un tipo construido aunque no especifique directamente los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="17a40-408">Esto puede ocurrir cuando un tipo está anidado dentro de una declaración de clase genérica y el tipo de instancia de la declaración contenedora se usa implícitamente para la búsqueda de nombres ([tipos anidados en clases genéricas](classes.md#nested-types-in-generic-classes)):</span><span class="sxs-lookup"><span data-stu-id="17a40-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="17a40-409">En código no seguro, un tipo construido no se puede usar como *unmanaged_type* ([tipos de puntero](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="17a40-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="17a40-410">Argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="17a40-410">Type arguments</span></span>

<span data-ttu-id="17a40-411">Cada argumento de una lista de argumentos de tipo es simplemente un *tipo*.</span><span class="sxs-lookup"><span data-stu-id="17a40-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="17a40-412">En el código no seguro ([código no seguro](unsafe-code.md)), un *type_argument* no puede ser un tipo de puntero.</span><span class="sxs-lookup"><span data-stu-id="17a40-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="17a40-413">Cada argumento de tipo debe satisfacer las restricciones en el parámetro de tipo correspondiente ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="17a40-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="17a40-414">Tipos abiertos y cerrados</span><span class="sxs-lookup"><span data-stu-id="17a40-414">Open and closed types</span></span>

<span data-ttu-id="17a40-415">Todos los tipos se pueden clasificar como ***tipos abiertos*** o ***tipos cerrados***.</span><span class="sxs-lookup"><span data-stu-id="17a40-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="17a40-416">Un tipo abierto es un tipo que implica parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="17a40-417">Más específicamente:</span><span class="sxs-lookup"><span data-stu-id="17a40-417">More specifically:</span></span>

*  <span data-ttu-id="17a40-418">Un parámetro de tipo define un tipo abierto.</span><span class="sxs-lookup"><span data-stu-id="17a40-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="17a40-419">Un tipo de matriz es un tipo abierto solo si su tipo de elemento es un tipo abierto.</span><span class="sxs-lookup"><span data-stu-id="17a40-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="17a40-420">Un tipo construido es un tipo abierto solo si uno o varios de sus argumentos de tipo es un tipo abierto.</span><span class="sxs-lookup"><span data-stu-id="17a40-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="17a40-421">Un tipo anidado construido es un tipo abierto si y solo si uno o varios de sus argumentos de tipo o los argumentos de tipo de sus tipos contenedores es un tipo abierto.</span><span class="sxs-lookup"><span data-stu-id="17a40-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="17a40-422">Un tipo cerrado es un tipo que no es un tipo abierto.</span><span class="sxs-lookup"><span data-stu-id="17a40-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="17a40-423">En tiempo de ejecución, todo el código dentro de una declaración de tipos genéricos se ejecuta en el contexto de un tipo construido cerrado que se creó mediante la aplicación de argumentos de tipo a la declaración genérica.</span><span class="sxs-lookup"><span data-stu-id="17a40-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="17a40-424">Cada parámetro de tipo dentro del tipo genérico se enlaza a un tipo en tiempo de ejecución determinado.</span><span class="sxs-lookup"><span data-stu-id="17a40-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="17a40-425">El procesamiento en tiempo de ejecución de todas las instrucciones y expresiones siempre se produce con tipos cerrados y los tipos abiertos solo se producen durante el procesamiento en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="17a40-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="17a40-426">Cada tipo construido cerrado tiene su propio conjunto de variables estáticas, que no se comparten con otros tipos construidos cerrados.</span><span class="sxs-lookup"><span data-stu-id="17a40-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="17a40-427">Puesto que no existe un tipo abierto en tiempo de ejecución, no hay variables estáticas asociadas a un tipo abierto.</span><span class="sxs-lookup"><span data-stu-id="17a40-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="17a40-428">Dos tipos construidos cerrados son del mismo tipo si se construyen a partir del mismo tipo genérico sin enlazar y sus argumentos de tipo correspondientes son del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="17a40-429">Tipos enlazados y sin enlazar</span><span class="sxs-lookup"><span data-stu-id="17a40-429">Bound and unbound types</span></span>

<span data-ttu-id="17a40-430">El término ***tipo sin enlazar*** hace referencia a un tipo no genérico o a un tipo genérico sin enlazar.</span><span class="sxs-lookup"><span data-stu-id="17a40-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="17a40-431">El término de ***tipo enlazado*** hace referencia a un tipo no genérico o a un tipo construido.</span><span class="sxs-lookup"><span data-stu-id="17a40-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="17a40-432">Un tipo sin enlazar hace referencia a la entidad declarada por una declaración de tipos.</span><span class="sxs-lookup"><span data-stu-id="17a40-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="17a40-433">Un tipo genérico sin enlazar no es en sí mismo un tipo y no se puede usar como el tipo de una variable, argumento o valor devuelto, o como un tipo base.</span><span class="sxs-lookup"><span data-stu-id="17a40-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="17a40-434">La única construcción en la que se puede hacer referencia a un tipo genérico sin enlazar es la expresión `typeof` ([el operador typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="17a40-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="17a40-435">Satisfacer restricciones</span><span class="sxs-lookup"><span data-stu-id="17a40-435">Satisfying constraints</span></span>

<span data-ttu-id="17a40-436">Siempre que se hace referencia a un tipo construido o a un método genérico, los argumentos de tipo proporcionados se comprueban con las restricciones de parámetro de tipo declaradas en el tipo o método genérico ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="17a40-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="17a40-437">Para cada cláusula `where`, el argumento de tipo `A` que corresponde al parámetro de tipo con nombre se compara con cada restricción de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="17a40-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="17a40-438">Si la restricción es un tipo de clase, un tipo de interfaz o un parámetro de tipo, deje `C` representar esa restricción con los argumentos de tipo proporcionados que se sustituyen por los parámetros de tipo que aparecen en la restricción.</span><span class="sxs-lookup"><span data-stu-id="17a40-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="17a40-439">Para satisfacer la restricción, debe ser el caso de que el tipo `A` sea convertible al tipo `C` por una de las siguientes acciones:</span><span class="sxs-lookup"><span data-stu-id="17a40-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="17a40-440">Una conversión de identidad ([conversión de identidad](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="17a40-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="17a40-441">Una conversión de referencia implícita ([conversiones de referencia implícita](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="17a40-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="17a40-442">Una conversión boxing ([conversiones boxing](conversions.md#boxing-conversions)), siempre que el tipo a sea un tipo de valor que no acepte valores NULL.</span><span class="sxs-lookup"><span data-stu-id="17a40-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="17a40-443">Referencia implícita, conversión boxing o conversión de parámetros de tipo de un parámetro de tipo `A` a `C`.</span><span class="sxs-lookup"><span data-stu-id="17a40-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="17a40-444">Si la restricción es la restricción de tipo de referencia (`class`), el tipo `A` debe cumplir uno de los siguientes elementos:</span><span class="sxs-lookup"><span data-stu-id="17a40-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="17a40-445">`A` es un tipo de interfaz, tipo de clase, tipo de delegado o tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="17a40-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="17a40-446">Tenga en cuenta que `System.ValueType` y `System.Enum` son tipos de referencia que cumplen esta restricción.</span><span class="sxs-lookup"><span data-stu-id="17a40-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="17a40-447">`A` es un parámetro de tipo que se sabe que es un tipo de referencia ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="17a40-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="17a40-448">Si la restricción es la restricción de tipo de valor (`struct`), el tipo `A` debe cumplir uno de los siguientes elementos:</span><span class="sxs-lookup"><span data-stu-id="17a40-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="17a40-449">`A` es un tipo de estructura o un tipo de enumeración, pero no un tipo que acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="17a40-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="17a40-450">Tenga en cuenta que `System.ValueType` y `System.Enum` son tipos de referencia que no cumplen esta restricción.</span><span class="sxs-lookup"><span data-stu-id="17a40-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="17a40-451">`A` es un parámetro de tipo que tiene la restricción de tipo de valor ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="17a40-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="17a40-452">Si la restricción es la restricción de constructor `new()`, el `A` de tipo no debe estar `abstract` y debe tener un constructor sin parámetros público.</span><span class="sxs-lookup"><span data-stu-id="17a40-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="17a40-453">Esto se cumple si se cumple una de las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="17a40-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="17a40-454">`A` es un tipo de valor, ya que todos los tipos de valor tienen un constructor predeterminado público ([constructores predeterminados](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="17a40-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="17a40-455">`A` es un parámetro de tipo que tiene la restricción de constructor ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="17a40-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="17a40-456">`A` es un parámetro de tipo que tiene la restricción de tipo de valor ([restricciones de parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="17a40-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="17a40-457">`A` es una clase que no se `abstract` y contiene un constructor de `public` explícitamente declarado sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="17a40-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="17a40-458">`A` no es `abstract` y tiene un constructor predeterminado ([constructores predeterminados](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="17a40-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="17a40-459">Se produce un error en tiempo de compilación si los argumentos de tipo especificados no satisfacen una o varias restricciones de un parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="17a40-460">Dado que los parámetros de tipo no se heredan, las restricciones nunca se heredan.</span><span class="sxs-lookup"><span data-stu-id="17a40-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="17a40-461">En el ejemplo siguiente, `D` debe especificar la restricción en su parámetro de tipo `T` para que `T` cumpla la restricción impuesta por la `B<T>`de clase base.</span><span class="sxs-lookup"><span data-stu-id="17a40-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="17a40-462">En cambio, la clase `E` no necesita especificar una restricción, porque `List<T>` implementa `IEnumerable` para cualquier `T`.</span><span class="sxs-lookup"><span data-stu-id="17a40-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="17a40-463">Parámetros de tipo</span><span class="sxs-lookup"><span data-stu-id="17a40-463">Type parameters</span></span>

<span data-ttu-id="17a40-464">Un parámetro de tipo es un identificador que designa un tipo de valor o un tipo de referencia al que está enlazado el parámetro en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="17a40-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="17a40-465">Dado que se pueden crear instancias de un parámetro de tipo con muchos argumentos de tipo reales diferentes, los parámetros de tipo tienen operaciones y restricciones ligeramente diferentes a las de otros tipos.</span><span class="sxs-lookup"><span data-stu-id="17a40-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="17a40-466">Se incluyen los siguientes:</span><span class="sxs-lookup"><span data-stu-id="17a40-466">These include:</span></span>

*  <span data-ttu-id="17a40-467">Un parámetro de tipo no se puede usar directamente para declarar una clase base ([clase base](classes.md#base-class)) o una interfaz ([listas de parámetros de tipo variante](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="17a40-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="17a40-468">Las reglas para la búsqueda de miembros en parámetros de tipo dependen de las restricciones, si las hay, que se aplican al parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="17a40-469">Se detallan en la [búsqueda de miembros](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="17a40-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="17a40-470">Las conversiones disponibles para un parámetro de tipo dependen de las restricciones, si las hay, que se aplican al parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="17a40-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="17a40-471">Se detallan en [conversiones implícitas que implican parámetros de tipo](conversions.md#implicit-conversions-involving-type-parameters) y [conversiones dinámicas explícitas](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="17a40-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="17a40-472">El `null` literal no se puede convertir en un tipo proporcionado por un parámetro de tipo, excepto si se sabe que el parámetro de tipo es un tipo de referencia ([conversiones implícitas que implican parámetros de tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="17a40-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="17a40-473">Sin embargo, en su lugar se puede usar una expresión `default` ([expresiones de valor predeterminado](expressions.md#default-value-expressions)).</span><span class="sxs-lookup"><span data-stu-id="17a40-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="17a40-474">Además, un valor con un tipo proporcionado por un parámetro de tipo puede compararse con `null` mediante `==` y `!=` ([operadores de igualdad de tipos de referencia](expressions.md#reference-type-equality-operators)), a menos que el parámetro de tipo tenga la restricción de tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="17a40-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="17a40-475">Una expresión `new` ([expresiones de creación de objetos](expressions.md#object-creation-expressions)) solo se puede utilizar con un parámetro de tipo si el parámetro de tipo está restringido por un *constructor_constraint* o la restricción de tipo de valor (restricciones de[parámetro de tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="17a40-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="17a40-476">Un parámetro de tipo no se puede usar en ningún lugar dentro de un atributo.</span><span class="sxs-lookup"><span data-stu-id="17a40-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="17a40-477">No se puede usar un parámetro de tipo en un acceso de miembro ([acceso a miembros](expressions.md#member-access)) o nombre de tipo (espacio de nombres[y nombres de tipo](basic-concepts.md#namespace-and-type-names)) para identificar un miembro estático o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="17a40-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="17a40-478">En código no seguro, no se puede usar un parámetro de tipo como *unmanaged_type* ([tipos de puntero](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="17a40-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="17a40-479">Como tipo, los parámetros de tipo son únicamente una construcción en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="17a40-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="17a40-480">En tiempo de ejecución, cada parámetro de tipo se enlaza a un tipo en tiempo de ejecución que se especificó proporcionando un argumento de tipo a la declaración de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="17a40-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="17a40-481">Por lo tanto, el tipo de una variable declarada con un parámetro de tipo, en tiempo de ejecución, será un tipo construido cerrado ([tipos abiertos y cerrados](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="17a40-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="17a40-482">La ejecución en tiempo de ejecución de todas las instrucciones y expresiones que impliquen parámetros de tipo usa el tipo real que se proporcionó como argumento de tipo para ese parámetro.</span><span class="sxs-lookup"><span data-stu-id="17a40-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="17a40-483">Tipos de árbol de expresión</span><span class="sxs-lookup"><span data-stu-id="17a40-483">Expression tree types</span></span>

<span data-ttu-id="17a40-484">Los ***árboles de expresión*** permiten representar expresiones lambda como estructuras de datos en lugar de código ejecutable.</span><span class="sxs-lookup"><span data-stu-id="17a40-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="17a40-485">Los árboles de expresión son valores de ***tipos de árbol de expresión*** con el formato `System.Linq.Expressions.Expression<D>`, donde `D` es cualquier tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="17a40-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="17a40-486">En el resto de esta especificación, haremos referencia a estos tipos mediante el `Expression<D>`abreviado.</span><span class="sxs-lookup"><span data-stu-id="17a40-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="17a40-487">Si existe una conversión de una expresión lambda a un tipo de delegado `D`, también existe una conversión al tipo de árbol de expresión `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="17a40-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="17a40-488">Mientras que la conversión de una expresión lambda a un tipo de delegado genera un delegado que hace referencia al código ejecutable de la expresión lambda, la conversión a un tipo de árbol de expresión crea una representación de árbol de expresión de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="17a40-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="17a40-489">Los árboles de expresión son representaciones eficaces de datos en memoria de expresiones lambda y hacen que la estructura de la expresión lambda sea transparente y explícita.</span><span class="sxs-lookup"><span data-stu-id="17a40-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="17a40-490">Al igual que un tipo de delegado `D`, se dice que `Expression<D>` tiene tipos de parámetro y de valor devuelto, que son los mismos que los de `D`.</span><span class="sxs-lookup"><span data-stu-id="17a40-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="17a40-491">En el ejemplo siguiente se representa una expresión lambda como código ejecutable y como un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="17a40-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="17a40-492">Dado que existe una conversión a `Func<int,int>`, también existe una conversión para `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="17a40-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="17a40-493">Después de estas asignaciones, el delegado `del` hace referencia a un método que devuelve `x + 1`y el árbol de expresión `exp` hace referencia a una estructura de datos que describe la `x => x + 1`de la expresión.</span><span class="sxs-lookup"><span data-stu-id="17a40-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="17a40-494">La definición exacta del tipo genérico `Expression<D>` así como las reglas precisas para construir un árbol de expresión cuando una expresión lambda se convierte en un tipo de árbol de expresión, está fuera del ámbito de esta especificación.</span><span class="sxs-lookup"><span data-stu-id="17a40-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="17a40-495">Es importante hacer dos cosas:</span><span class="sxs-lookup"><span data-stu-id="17a40-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="17a40-496">No todas las expresiones lambda se pueden convertir en árboles de expresión.</span><span class="sxs-lookup"><span data-stu-id="17a40-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="17a40-497">Por ejemplo, las expresiones lambda con cuerpos de instrucciones y expresiones lambda que contienen expresiones de asignación no se pueden representar.</span><span class="sxs-lookup"><span data-stu-id="17a40-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="17a40-498">En estos casos, todavía existe una conversión, pero se producirá un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="17a40-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="17a40-499">Estas excepciones se detallan en [conversiones de funciones anónimas](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="17a40-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="17a40-500">`Expression<D>` ofrece un método de instancia `Compile` que genera un delegado de tipo `D`:</span><span class="sxs-lookup"><span data-stu-id="17a40-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="17a40-501">Al invocar este delegado se produce el código representado por el árbol de expresión que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="17a40-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="17a40-502">Por lo tanto, dado que las definiciones anteriores, del y DEL2 son equivalentes, y las dos instrucciones siguientes tendrán el mismo efecto:</span><span class="sxs-lookup"><span data-stu-id="17a40-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="17a40-503">Después de ejecutar este código, `i1` y `i2` tendrán el valor `2`.</span><span class="sxs-lookup"><span data-stu-id="17a40-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

