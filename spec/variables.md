---
ms.openlocfilehash: a01cf9387b8dc47de036bf0bd1496c19a441d81c
ms.sourcegitcommit: 7f7fc6e9e195e51b7ff8229aeaa70aa9fbbb63cb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/10/2019
ms.locfileid: "70876798"
---
# <a name="variables"></a><span data-ttu-id="294e4-101">variables</span><span class="sxs-lookup"><span data-stu-id="294e4-101">Variables</span></span>

<span data-ttu-id="294e4-102">Las variables representan ubicaciones de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="294e4-102">Variables represent storage locations.</span></span> <span data-ttu-id="294e4-103">Cada variable tiene un tipo que determina qué valores se pueden almacenar en la variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="294e4-104">C#es un lenguaje con seguridad de tipos y el C# compilador garantiza que los valores almacenados en variables siempre son del tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="294e4-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="294e4-105">El valor de una variable se puede cambiar a través de la asignación o mediante `++` el `--` uso de los operadores y.</span><span class="sxs-lookup"><span data-stu-id="294e4-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="294e4-106">Una variable debe estar ***asignada definitivamente*** ([asignación definitiva](variables.md#definite-assignment)) antes de que se pueda obtener su valor.</span><span class="sxs-lookup"><span data-stu-id="294e4-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="294e4-107">Tal y como se describe en las secciones siguientes, las variables se ***asignan inicialmente*** o no se ***asignan inicialmente***.</span><span class="sxs-lookup"><span data-stu-id="294e4-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="294e4-108">Una variable asignada inicialmente tiene un valor inicial bien definido y siempre se considera asignada definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="294e4-109">Una variable no asignada inicialmente no tiene ningún valor inicial.</span><span class="sxs-lookup"><span data-stu-id="294e4-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="294e4-110">Para que una variable no asignada inicialmente se considere asignada definitivamente en una determinada ubicación, se debe realizar una asignación a la variable en todas las rutas de acceso de ejecución posibles que conducen a esa ubicación.</span><span class="sxs-lookup"><span data-stu-id="294e4-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="294e4-111">Categorías de variables</span><span class="sxs-lookup"><span data-stu-id="294e4-111">Variable categories</span></span>

<span data-ttu-id="294e4-112">C#define siete categorías de variables: variables estáticas, variables de instancia, elementos de matriz, parámetros de valor, parámetros de referencia, parámetros de salida y variables locales.</span><span class="sxs-lookup"><span data-stu-id="294e4-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="294e4-113">En las secciones siguientes se describe cada una de estas categorías.</span><span class="sxs-lookup"><span data-stu-id="294e4-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="294e4-114">En el ejemplo</span><span class="sxs-lookup"><span data-stu-id="294e4-114">In the example</span></span>
```csharp
class A
{
    public static int x;
    int y;

    void F(int[] v, int a, ref int b, out int c) {
        int i = 1;
        c = a + b++;
    }
}
```
<span data-ttu-id="294e4-115">`x`es una variable estática, `y` es una variable de instancia `v[0]` , es un elemento de `a` matriz, es un parámetro `b` de valor, es un `c` parámetro de referencia, es un `i` parámetro de salida y es una variable local. .</span><span class="sxs-lookup"><span data-stu-id="294e4-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="294e4-116">Variables estáticas</span><span class="sxs-lookup"><span data-stu-id="294e4-116">Static variables</span></span>

<span data-ttu-id="294e4-117">Un campo declarado con el `static` modificador se denomina ***variable estática***.</span><span class="sxs-lookup"><span data-stu-id="294e4-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="294e4-118">Una variable estática se produce antes de la ejecución del constructor estático ([constructores estáticos](classes.md#static-constructors)) para su tipo contenedor y deja de existir cuando el dominio de aplicación asociado deja de existir.</span><span class="sxs-lookup"><span data-stu-id="294e4-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="294e4-119">El valor inicial de una variable estática es el valor predeterminado ([valores predeterminados](variables.md#default-values)) del tipo de la variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="294e4-120">A efectos de la comprobación de asignación definitiva, se considera que una variable estática está asignada inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="294e4-121">Variables de instancia</span><span class="sxs-lookup"><span data-stu-id="294e4-121">Instance variables</span></span>

<span data-ttu-id="294e4-122">Un campo declarado sin el `static` modificador se denomina ***variable de instancia***.</span><span class="sxs-lookup"><span data-stu-id="294e4-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="294e4-123">Variables de instancia en clases</span><span class="sxs-lookup"><span data-stu-id="294e4-123">Instance variables in classes</span></span>

<span data-ttu-id="294e4-124">Una variable de instancia de una clase se produce cuando se crea una nueva instancia de esa clase y deja de existir cuando no hay ninguna referencia a esa instancia y se ha ejecutado el destructor de la instancia (si existe).</span><span class="sxs-lookup"><span data-stu-id="294e4-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="294e4-125">El valor inicial de una variable de instancia de una clase es el valor predeterminado ([valores predeterminados](variables.md#default-values)) del tipo de la variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="294e4-126">Con el fin de comprobar la asignación definitiva, se considera que una variable de instancia de una clase está asignada inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="294e4-127">Variables de instancia en Structs</span><span class="sxs-lookup"><span data-stu-id="294e4-127">Instance variables in structs</span></span>

<span data-ttu-id="294e4-128">Una variable de instancia de un struct tiene exactamente la misma duración que la variable de estructura a la que pertenece.</span><span class="sxs-lookup"><span data-stu-id="294e4-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="294e4-129">En otras palabras, cuando una variable de un tipo struct entra en existencia o deja de existir, también se realizan las variables de instancia de la estructura.</span><span class="sxs-lookup"><span data-stu-id="294e4-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="294e4-130">El estado de asignación inicial de una variable de instancia de una estructura es el mismo que el de la variable de estructura contenedora.</span><span class="sxs-lookup"><span data-stu-id="294e4-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="294e4-131">En otras palabras, cuando se considera que una variable de estructura está asignada inicialmente, también se consideran variables de instancia y, cuando una variable de struct se considera inicialmente sin asignar, sus variables de instancia también se desasignan.</span><span class="sxs-lookup"><span data-stu-id="294e4-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="294e4-132">Elementos de matriz</span><span class="sxs-lookup"><span data-stu-id="294e4-132">Array elements</span></span>

<span data-ttu-id="294e4-133">Los elementos de una matriz se componen cuando se crea una instancia de matriz y dejan de existir cuando no hay ninguna referencia a esa instancia de la matriz.</span><span class="sxs-lookup"><span data-stu-id="294e4-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="294e4-134">El valor inicial de cada uno de los elementos de una matriz es el valor predeterminado ([valores predeterminados](variables.md#default-values)) del tipo de los elementos de la matriz.</span><span class="sxs-lookup"><span data-stu-id="294e4-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="294e4-135">Con el fin de comprobar la asignación definitiva, se considera que un elemento de la matriz está asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="294e4-136">Parámetros de valor</span><span class="sxs-lookup"><span data-stu-id="294e4-136">Value parameters</span></span>

<span data-ttu-id="294e4-137">Un parámetro declarado sin un `ref` modificador o `out` es un ***parámetro de valor***.</span><span class="sxs-lookup"><span data-stu-id="294e4-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="294e4-138">Un parámetro de valor se basa en la invocación del miembro de función (método, constructor de instancia, descriptor de acceso o operador) o función anónima a la que pertenece el parámetro, y se inicializa con el valor del argumento proporcionado en la invocación.</span><span class="sxs-lookup"><span data-stu-id="294e4-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="294e4-139">Normalmente, un parámetro de valor deja de existir cuando se devuelve el miembro de función o la función anónima.</span><span class="sxs-lookup"><span data-stu-id="294e4-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="294e4-140">Sin embargo, si el parámetro de valor se captura mediante una función anónima ([expresiones de función anónima](expressions.md#anonymous-function-expressions)), su tiempo de vida se extiende al menos hasta que el delegado o el árbol de expresión creado a partir de esa función anónima sea válido para la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="294e4-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="294e4-141">Con el fin de comprobar la asignación definitiva, se considera que un parámetro de valor está asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="294e4-142">Parámetros de referencia</span><span class="sxs-lookup"><span data-stu-id="294e4-142">Reference parameters</span></span>

<span data-ttu-id="294e4-143">Un parámetro declarado con un `ref` modificador es un ***parámetro de referencia***.</span><span class="sxs-lookup"><span data-stu-id="294e4-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="294e4-144">Un parámetro de referencia no crea una nueva ubicación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="294e4-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="294e4-145">En su lugar, un parámetro de referencia representa la misma ubicación de almacenamiento que la variable proporcionada como argumento en el miembro de función o la invocación de la función anónima.</span><span class="sxs-lookup"><span data-stu-id="294e4-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="294e4-146">Por lo tanto, el valor de un parámetro de referencia es siempre el mismo que el de la variable subyacente.</span><span class="sxs-lookup"><span data-stu-id="294e4-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="294e4-147">Las siguientes reglas de asignación definitiva se aplican a los parámetros de referencia.</span><span class="sxs-lookup"><span data-stu-id="294e4-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="294e4-148">Tenga en cuenta las diferentes reglas para los parámetros de salida que se describen en [parámetros de salida](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="294e4-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="294e4-149">Una variable debe estar asignada definitivamente ([asignación definitiva](variables.md#definite-assignment)) antes de que se pueda pasar como un parámetro de referencia en un miembro de función o una invocación de delegado.</span><span class="sxs-lookup"><span data-stu-id="294e4-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="294e4-150">Dentro de un miembro de función o una función anónima, se considera que un parámetro de referencia está asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="294e4-151">Dentro de un método de instancia o un descriptor de acceso `this` de instancia de un tipo de estructura, la palabra clave se comporta exactamente como un parámetro de referencia del tipo de estructura ([este acceso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="294e4-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="294e4-152">Parámetros de salida</span><span class="sxs-lookup"><span data-stu-id="294e4-152">Output parameters</span></span>

<span data-ttu-id="294e4-153">Un parámetro declarado con un `out` modificador es un ***parámetro de salida***.</span><span class="sxs-lookup"><span data-stu-id="294e4-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="294e4-154">Un parámetro de salida no crea una nueva ubicación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="294e4-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="294e4-155">En su lugar, un parámetro de salida representa la misma ubicación de almacenamiento que la variable proporcionada como argumento en la invocación del miembro de función o delegado.</span><span class="sxs-lookup"><span data-stu-id="294e4-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="294e4-156">Por lo tanto, el valor de un parámetro de salida es siempre el mismo que el de la variable subyacente.</span><span class="sxs-lookup"><span data-stu-id="294e4-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="294e4-157">Las siguientes reglas de asignación definitiva se aplican a los parámetros de salida.</span><span class="sxs-lookup"><span data-stu-id="294e4-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="294e4-158">Tenga en cuenta las diferentes reglas para los parámetros de referencia descritos en [parámetros de referencia](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="294e4-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="294e4-159">No es necesario asignar definitivamente una variable antes de que se pueda pasar como parámetro de salida en un miembro de función o en una invocación de delegado.</span><span class="sxs-lookup"><span data-stu-id="294e4-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="294e4-160">Tras la finalización normal de una invocación de un miembro de función o delegado, cada variable que se pasó como parámetro de salida se considera asignada en esa ruta de acceso de ejecución.</span><span class="sxs-lookup"><span data-stu-id="294e4-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="294e4-161">Dentro de un miembro de función o una función anónima, un parámetro de salida se considera inicialmente sin asignar.</span><span class="sxs-lookup"><span data-stu-id="294e4-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="294e4-162">Todos los parámetros de salida de un miembro de función o de una función anónima deben estar asignados definitivamente ([asignación definitiva](variables.md#definite-assignment)) antes de que el miembro de función o la función anónima devuelvan normalmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="294e4-163">Dentro de un constructor de instancia de un tipo de `this` estructura, la palabra clave se comporta exactamente como un parámetro de salida del tipo de estructura ([este acceso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="294e4-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="294e4-164">Variables locales</span><span class="sxs-lookup"><span data-stu-id="294e4-164">Local variables</span></span>

<span data-ttu-id="294e4-165">Una ***variable local*** está declarada por un *local_variable_declaration*, que puede producirse en un *bloque*, *for_Statement*, *switch_statement* o *using_statement*; o bien, *foreach_statement* o *specific_catch_clause* para un *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="294e4-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="294e4-166">La duración de una variable local es la parte de la ejecución del programa durante la que se garantiza que el almacenamiento está reservado para ella.</span><span class="sxs-lookup"><span data-stu-id="294e4-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="294e4-167">Esta duración extiende al menos una entrada en el *bloque*, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*o *specific_catch_clause* con el que está asociada, hasta que la ejecución de ese *bloque*, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*o *specific_catch_clause* finaliza de forma alguna.</span><span class="sxs-lookup"><span data-stu-id="294e4-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="294e4-168">(Si se escribe un *bloque* incluido o se llama a un método, se suspende, pero no finaliza, la ejecución del *bloque*actual, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*o *specific_ catch_clause*). Si una función anónima captura la variable local ([variables externas capturadas](expressions.md#captured-outer-variables)), su duración se extiende al menos hasta que el delegado o árbol de expresión creado a partir de la función anónima, junto con cualquier otro objeto que se refiere a la la variable capturada, es válida para la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="294e4-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="294e4-169">Si el *bloque*primario, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*o *specific_catch_clause* se escribe de forma recursiva, se crea una nueva instancia de la variable local. la hora y su *local_variable_initializer*, si existe, se evalúan cada vez.</span><span class="sxs-lookup"><span data-stu-id="294e4-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="294e4-170">Una variable local introducida por un *local_variable_declaration* no se inicializa automáticamente y, por tanto, no tiene ningún valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="294e4-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="294e4-171">Con el fin de comprobar la asignación definitiva, una variable local introducida por una *local_variable_declaration* se considera inicialmente sin asignar.</span><span class="sxs-lookup"><span data-stu-id="294e4-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="294e4-172">Un *local_variable_declaration* puede incluir un *local_variable_initializer*, en cuyo caso la variable se considera definitivamente asignada solo después de la expresión de inicialización ([instrucciones de declaración](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="294e4-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="294e4-173">Dentro del ámbito de una variable local introducida por un *local_variable_declaration*, se trata de un error en tiempo de compilación para hacer referencia a esa variable local en una posición textual que precede a su *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="294e4-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="294e4-174">Si la declaración de variable local es implícita ([declaraciones de variables locales](statements.md#local-variable-declarations)), también es un error hacer referencia a la variable dentro de su *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="294e4-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="294e4-175">Una variable local introducida por un *foreach_statement* o un *specific_catch_clause* se considera definitivamente asignada en todo el ámbito.</span><span class="sxs-lookup"><span data-stu-id="294e4-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="294e4-176">La duración real de una variable local depende de la implementación.</span><span class="sxs-lookup"><span data-stu-id="294e4-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="294e4-177">Por ejemplo, un compilador puede determinar estáticamente que una variable local de un bloque solo se usa para una pequeña parte de ese bloque.</span><span class="sxs-lookup"><span data-stu-id="294e4-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="294e4-178">Con este análisis, el compilador podría generar código que hace que el almacenamiento de la variable tenga una duración más corta que el bloque contenedor.</span><span class="sxs-lookup"><span data-stu-id="294e4-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="294e4-179">El almacenamiento al que se hace referencia mediante una variable de referencia local se recupera independientemente de la duración de esa variable de referencia local ([Administración automática de memoria](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="294e4-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="294e4-180">Valores predeterminados</span><span class="sxs-lookup"><span data-stu-id="294e4-180">Default values</span></span>

<span data-ttu-id="294e4-181">Las siguientes categorías de variables se inicializan automáticamente con sus valores predeterminados:</span><span class="sxs-lookup"><span data-stu-id="294e4-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="294e4-182">Variables estáticas.</span><span class="sxs-lookup"><span data-stu-id="294e4-182">Static variables.</span></span>
*  <span data-ttu-id="294e4-183">Variables de instancia de instancias de clase.</span><span class="sxs-lookup"><span data-stu-id="294e4-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="294e4-184">Elementos de matriz.</span><span class="sxs-lookup"><span data-stu-id="294e4-184">Array elements.</span></span>

<span data-ttu-id="294e4-185">El valor predeterminado de una variable depende del tipo de la variable y se determina de la manera siguiente:</span><span class="sxs-lookup"><span data-stu-id="294e4-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="294e4-186">En el caso de una variable de *value_type*, el valor predeterminado es el mismo que el valor calculado por el constructor predeterminado del *value_type*([constructores predeterminados](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="294e4-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="294e4-187">En el caso de una variable de *reference_type*, el valor `null`predeterminado es.</span><span class="sxs-lookup"><span data-stu-id="294e4-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="294e4-188">Normalmente, la inicialización en los valores predeterminados se realiza al hacer que el administrador de memoria o el recolector de elementos no utilizados inicialicen la memoria para todos los bits cero antes de que se asignen para su uso.</span><span class="sxs-lookup"><span data-stu-id="294e4-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="294e4-189">Por esta razón, es conveniente usar All-bits-cero para representar la referencia nula.</span><span class="sxs-lookup"><span data-stu-id="294e4-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="294e4-190">Asignación definitiva</span><span class="sxs-lookup"><span data-stu-id="294e4-190">Definite assignment</span></span>

<span data-ttu-id="294e4-191">En una ubicación determinada del código ejecutable de un miembro de función, se dice que una variable está ***asignada definitivamente*** si el compilador puede demostrar, mediante un análisis de flujo estático determinado ([reglas precisas para determinar la asignación definitiva](variables.md#precise-rules-for-determining-definite-assignment)), que la variable se ha inicializado automáticamente o ha sido el destino de al menos una asignación.</span><span class="sxs-lookup"><span data-stu-id="294e4-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="294e4-192">De manera informativa, las reglas de asignación definitiva son las siguientes:</span><span class="sxs-lookup"><span data-stu-id="294e4-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="294e4-193">Una variable asignada inicialmente ([variables asignadas inicialmente](variables.md#initially-assigned-variables)) siempre se considera asignada definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="294e4-194">Una variable no asignada inicialmente ([variables inicialmente sin asignar](variables.md#initially-unassigned-variables)) se considera definitivamente asignada en una ubicación determinada si todas las rutas de acceso de ejecución posibles que conducen a esa ubicación contienen al menos uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="294e4-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="294e4-195">Asignación simple ([asignación simple](expressions.md#simple-assignment)) en la que la variable es el operando izquierdo.</span><span class="sxs-lookup"><span data-stu-id="294e4-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="294e4-196">Una expresión de invocación ([expresiones de invocación](expressions.md#invocation-expressions)) o una expresión de creación de objetos ([expresiones de creación de objetos](expressions.md#object-creation-expressions)) que pasa la variable como parámetro de salida.</span><span class="sxs-lookup"><span data-stu-id="294e4-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="294e4-197">En el caso de una variable local, es una declaración de variable local ([declaraciones de variables locales](statements.md#local-variable-declarations)) que incluye un inicializador de variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="294e4-198">La especificación formal subyacente a las reglas informal anteriores se describe en [variables asignadas inicialmente](variables.md#initially-assigned-variables), [variables inicialmente sin asignar](variables.md#initially-unassigned-variables)y [reglas precisas para determinar la asignación definitiva](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="294e4-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="294e4-199">El seguimiento de los Estados de asignación definitiva de las variables de instancia de una variable *struct_type* se realiza de forma individual y colectiva.</span><span class="sxs-lookup"><span data-stu-id="294e4-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="294e4-200">Además de las reglas anteriores, las siguientes reglas se aplican a las variables *struct_type* y sus variables de instancia:</span><span class="sxs-lookup"><span data-stu-id="294e4-200">In addition to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="294e4-201">Una variable de instancia se considera asignada definitivamente si su variable *struct_type* que contiene se considera asignada definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="294e4-202">Una variable *struct_type* se considera asignada definitivamente si cada una de sus variables de instancia se considera definitivamente asignada.</span><span class="sxs-lookup"><span data-stu-id="294e4-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="294e4-203">La asignación definitiva es un requisito en los contextos siguientes:</span><span class="sxs-lookup"><span data-stu-id="294e4-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="294e4-204">Una variable debe estar asignada definitivamente en cada ubicación donde se obtiene su valor.</span><span class="sxs-lookup"><span data-stu-id="294e4-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="294e4-205">Esto garantiza que nunca se produzcan valores sin definir.</span><span class="sxs-lookup"><span data-stu-id="294e4-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="294e4-206">La aparición de una variable en una expresión se considera que obtiene el valor de la variable, excepto cuando</span><span class="sxs-lookup"><span data-stu-id="294e4-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="294e4-207">la variable es el operando izquierdo de una asignación simple,</span><span class="sxs-lookup"><span data-stu-id="294e4-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="294e4-208">la variable se pasa como parámetro de salida, o bien</span><span class="sxs-lookup"><span data-stu-id="294e4-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="294e4-209">la variable es una variable *struct_type* y se produce como operando izquierdo de un acceso de miembro.</span><span class="sxs-lookup"><span data-stu-id="294e4-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="294e4-210">Una variable debe estar asignada definitivamente en cada ubicación en la que se pasa como parámetro de referencia.</span><span class="sxs-lookup"><span data-stu-id="294e4-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="294e4-211">Esto garantiza que el miembro de función que se invoca puede considerar el parámetro de referencia asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="294e4-212">Todos los parámetros de salida de un miembro de función deben asignarse definitivamente en cada ubicación en la que el miembro `return` de función devuelva (a través de una instrucción o a través de la ejecución hasta el final del cuerpo del miembro de función).</span><span class="sxs-lookup"><span data-stu-id="294e4-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="294e4-213">Esto garantiza que los miembros de función no devuelven valores no definidos en los parámetros de salida, lo que permite al compilador considerar una invocación de miembro de función que toma una variable como parámetro de salida equivalente a una asignación a la variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="294e4-214">La `this` variable de un constructor de instancia *struct_type* debe estar asignada definitivamente en cada ubicación en la que el constructor de instancia devuelva.</span><span class="sxs-lookup"><span data-stu-id="294e4-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="294e4-215">Variables asignadas inicialmente</span><span class="sxs-lookup"><span data-stu-id="294e4-215">Initially assigned variables</span></span>

<span data-ttu-id="294e4-216">Las siguientes categorías de variables se clasifican como asignadas inicialmente:</span><span class="sxs-lookup"><span data-stu-id="294e4-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="294e4-217">Variables estáticas.</span><span class="sxs-lookup"><span data-stu-id="294e4-217">Static variables.</span></span>
*  <span data-ttu-id="294e4-218">Variables de instancia de instancias de clase.</span><span class="sxs-lookup"><span data-stu-id="294e4-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="294e4-219">Variables de instancia de las variables de struct asignadas inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="294e4-220">Elementos de matriz.</span><span class="sxs-lookup"><span data-stu-id="294e4-220">Array elements.</span></span>
*  <span data-ttu-id="294e4-221">Parámetros de valor.</span><span class="sxs-lookup"><span data-stu-id="294e4-221">Value parameters.</span></span>
*  <span data-ttu-id="294e4-222">Parámetros de referencia.</span><span class="sxs-lookup"><span data-stu-id="294e4-222">Reference parameters.</span></span>
*  <span data-ttu-id="294e4-223">Variables declaradas `catch` en una cláusula `foreach` o instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="294e4-224">Variables inicialmente sin asignar</span><span class="sxs-lookup"><span data-stu-id="294e4-224">Initially unassigned variables</span></span>

<span data-ttu-id="294e4-225">Las siguientes categorías de variables se clasifican como sin asignar inicialmente:</span><span class="sxs-lookup"><span data-stu-id="294e4-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="294e4-226">Variables de instancia de variables de estructura inicialmente sin asignar.</span><span class="sxs-lookup"><span data-stu-id="294e4-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="294e4-227">Parámetros de salida, incluida `this` la variable de constructores de instancia de struct.</span><span class="sxs-lookup"><span data-stu-id="294e4-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="294e4-228">Variables locales, excepto las declaradas `catch` en una cláusula `foreach` o una instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="294e4-229">Reglas precisas para determinar la asignación definitiva</span><span class="sxs-lookup"><span data-stu-id="294e4-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="294e4-230">Con el fin de determinar que cada variable usada está asignada definitivamente, el compilador debe utilizar un proceso equivalente al descrito en esta sección.</span><span class="sxs-lookup"><span data-stu-id="294e4-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="294e4-231">El compilador procesa el cuerpo de cada miembro de función que tiene una o varias variables sin asignar inicialmente.</span><span class="sxs-lookup"><span data-stu-id="294e4-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="294e4-232">Para *cada variable de*inicial sin asignar, el compilador determina un ***Estado de asignación definitiva*** para *v* en cada uno de los siguientes puntos del miembro de función:</span><span class="sxs-lookup"><span data-stu-id="294e4-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="294e4-233">Al principio de cada instrucción</span><span class="sxs-lookup"><span data-stu-id="294e4-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="294e4-234">En el punto final ([puntos de conexión y disponibilidad](statements.md#end-points-and-reachability)) de cada instrucción</span><span class="sxs-lookup"><span data-stu-id="294e4-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="294e4-235">En cada arco que transfiere el control a otra instrucción o al punto final de una instrucción</span><span class="sxs-lookup"><span data-stu-id="294e4-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="294e4-236">Al principio de cada expresión</span><span class="sxs-lookup"><span data-stu-id="294e4-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="294e4-237">Al final de cada expresión</span><span class="sxs-lookup"><span data-stu-id="294e4-237">At the end of each expression</span></span>

<span data-ttu-id="294e4-238">El estado de asignación definitiva de *v* puede ser:</span><span class="sxs-lookup"><span data-stu-id="294e4-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="294e4-239">Definitivamente asignada.</span><span class="sxs-lookup"><span data-stu-id="294e4-239">Definitely assigned.</span></span> <span data-ttu-id="294e4-240">Esto indica que en todos los flujos de control posibles hasta este punto, se ha asignado un valor a *v* .</span><span class="sxs-lookup"><span data-stu-id="294e4-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="294e4-241">No asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-241">Not definitely assigned.</span></span> <span data-ttu-id="294e4-242">Para el estado de una variable al final de una expresión de tipo `bool`, el estado de una variable que no está asignado definitivamente puede ser uno de los siguientes subestados:</span><span class="sxs-lookup"><span data-stu-id="294e4-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="294e4-243">Se asigna definitivamente después de la expresión true.</span><span class="sxs-lookup"><span data-stu-id="294e4-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="294e4-244">Este estado indica que *v* se asigna definitivamente si la expresión booleana se evalúa como true, pero no se asigna necesariamente si la expresión booleana se evalúa como false.</span><span class="sxs-lookup"><span data-stu-id="294e4-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="294e4-245">Se asigna definitivamente después de la expresión false.</span><span class="sxs-lookup"><span data-stu-id="294e4-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="294e4-246">Este estado indica que *v* se asigna definitivamente si la expresión booleana se evalúa como false, pero no se asigna necesariamente si la expresión booleana se evalúa como true.</span><span class="sxs-lookup"><span data-stu-id="294e4-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="294e4-247">Las siguientes reglas rigen cómo se determina el estado de una variable *v* en cada ubicación.</span><span class="sxs-lookup"><span data-stu-id="294e4-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="294e4-248">Reglas generales para las instrucciones</span><span class="sxs-lookup"><span data-stu-id="294e4-248">General rules for statements</span></span>

*  <span data-ttu-id="294e4-249">*v* no se asigna definitivamente al principio del cuerpo de un miembro de función.</span><span class="sxs-lookup"><span data-stu-id="294e4-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="294e4-250">*v* se asigna definitivamente al principio de cualquier instrucción inalcanzable.</span><span class="sxs-lookup"><span data-stu-id="294e4-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="294e4-251">El estado de asignación definitiva de *v* al principio de cualquier otra instrucción se determina comprobando el estado de asignación definitiva de *v* en todas las transferencias de flujo de control que tienen como destino el inicio de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="294e4-252">Si (y solo si) *v* se asigna definitivamente en todas estas transferencias de flujo de control, entonces *v* se asigna definitivamente al principio de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="294e4-253">El conjunto de posibles transferencias de flujo de control se determina de la misma manera que para comprobar la disponibilidad de la instrucción (puntos de conexión[y disponibilidad](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="294e4-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="294e4-254">El estado de asignación definitiva de *v* en el punto final de un bloque, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach` `lock`,, `using`o `switch`la instrucción se determina comprobando el estado de asignación definitiva de *v* en todas las transferencias de flujo de control que tienen como destino el punto final de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="294e4-255">Si *v* se asigna definitivamente en todas estas transferencias de flujo de control, entonces *v* se asigna definitivamente en el punto final de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="294e4-256">Casos *v* no se asigna definitivamente en el punto final de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="294e4-257">El conjunto de posibles transferencias de flujo de control se determina de la misma manera que para comprobar la disponibilidad de la instrucción (puntos de conexión[y disponibilidad](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="294e4-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="294e4-258">Instrucciones de bloqueo, comprobadas y no comprobadas</span><span class="sxs-lookup"><span data-stu-id="294e4-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="294e4-259">El estado de asignación definitiva de *v* en la transferencia de control a la primera instrucción de la lista de instrucciones en el bloque (o al punto final del bloque, si la lista de instrucciones está vacía) es igual que la instrucción de asignación definitiva de *v* antes del bloque. instrucción `checked`, o `unchecked` .</span><span class="sxs-lookup"><span data-stu-id="294e4-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="294e4-260">Instrucciones de expresión</span><span class="sxs-lookup"><span data-stu-id="294e4-260">Expression statements</span></span>

<span data-ttu-id="294e4-261">Para una instrucción de expresión *stmt* que consta de la expresión *expr*:</span><span class="sxs-lookup"><span data-stu-id="294e4-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="294e4-262">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-263">Si *se* asigna definitivamente al final de *expr*, se asigna definitivamente en el punto final de *stmt*; casos no se asigna definitivamente en el punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="294e4-264">Instrucciones de declaración</span><span class="sxs-lookup"><span data-stu-id="294e4-264">Declaration statements</span></span>

*  <span data-ttu-id="294e4-265">Si *stmt* es una instrucción de declaración sin inicializadores, *v* tiene el mismo estado de asignación definitiva en el punto final de *stmt* que al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-266">Si *stmt* es una instrucción de declaración con inicializadores, el estado de asignación definitiva para *v* se determina como si *stmt* fuera una lista de instrucciones, con una instrucción de asignación para cada declaración con un inicializador (en el orden de Declaración).</span><span class="sxs-lookup"><span data-stu-id="294e4-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="294e4-267">Instrucciones if</span><span class="sxs-lookup"><span data-stu-id="294e4-267">If statements</span></span>

<span data-ttu-id="294e4-268">Para una `if` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="294e4-269">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-270">Si *v* se asigna definitivamente al final de *expr*, se asigna definitivamente en la transferencia de flujo de control a *then_stmt* y a *else_stmt* o al punto final de *stmt* si no hay ninguna cláusula ELSE.</span><span class="sxs-lookup"><span data-stu-id="294e4-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="294e4-271">Si *v* tiene el estado "definitivamente asignado después de una expresión true" al final de *expr*, se asigna definitivamente en la transferencia del flujo de control a *then_stmt*y no se asigna definitivamente en la transferencia del flujo de control a *else_ stmt* o al punto final de *stmt* si no hay ninguna cláusula ELSE.</span><span class="sxs-lookup"><span data-stu-id="294e4-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="294e4-272">Si *v* tiene el estado "definitivamente asignado después de la expresión false" al final de *expr*, se asigna definitivamente en la transferencia del flujo de control a *else_stmt*y no se asigna definitivamente en la transferencia del flujo de control a *then_stmt* .</span><span class="sxs-lookup"><span data-stu-id="294e4-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="294e4-273">Se asigna definitivamente en el punto final de *stmt* si y solo si se asigna definitivamente en el punto final de *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="294e4-274">De lo contrario, se considera que *v* no está asignado definitivamente en la transferencia de flujo de control a *then_stmt* o *else_stmt*, o al punto final de *stmt* si no hay ninguna cláusula ELSE.</span><span class="sxs-lookup"><span data-stu-id="294e4-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="294e4-275">Instrucciones switch</span><span class="sxs-lookup"><span data-stu-id="294e4-275">Switch statements</span></span>

<span data-ttu-id="294e4-276">En una `switch` instrucción *stmt* con una expresión de control *expr*:</span><span class="sxs-lookup"><span data-stu-id="294e4-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="294e4-277">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-278">El estado de asignación definitiva de *v* en la lista de transferencias de flujo de control a una lista de instrucciones del bloque switch es igual que el estado de asignación definitiva de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="294e4-279">While (instrucciones)</span><span class="sxs-lookup"><span data-stu-id="294e4-279">While statements</span></span>

<span data-ttu-id="294e4-280">Para una `while` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="294e4-281">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-282">Si *v* se asigna definitivamente al final de *expr*, se asigna definitivamente en la transferencia de flujo de control a *while_body* y al punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="294e4-283">Si *v* tiene el estado "definitivamente asignado después de una expresión true" al final de *expr*, se asigna definitivamente en la transferencia del flujo de control a *while_body*, pero no se asigna definitivamente en el punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="294e4-284">Si *v* tiene el estado "definitivamente asignado después de la expresión false" al final de *expr*, se asigna definitivamente en la transferencia del flujo de control al punto final de *stmt*, pero no se asigna definitivamente en la transferencia del flujo de control a *While _body*.</span><span class="sxs-lookup"><span data-stu-id="294e4-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="294e4-285">Do (instrucciones)</span><span class="sxs-lookup"><span data-stu-id="294e4-285">Do statements</span></span>

<span data-ttu-id="294e4-286">Para una `do` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="294e4-287">*v* tiene el mismo estado de asignación definitiva en la transferencia del flujo de control desde el principio de *stmt* a *do_body* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-288">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como en el punto final de *do_body*.</span><span class="sxs-lookup"><span data-stu-id="294e4-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="294e4-289">Si *v* se asigna definitivamente al final de *expr*, se asigna definitivamente en la transferencia del flujo de control al punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="294e4-290">Si *v* tiene el estado "definitivamente asignado después de la expresión false" al final de *expr*, se asigna definitivamente en la transferencia del flujo de control al punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="294e4-291">Instrucciones for</span><span class="sxs-lookup"><span data-stu-id="294e4-291">For statements</span></span>

<span data-ttu-id="294e4-292">Comprobación de asignación definitiva para una `for` instrucción de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="294e4-293">se realiza como si se hubiera escrito la instrucción:</span><span class="sxs-lookup"><span data-stu-id="294e4-293">is done as if the statement were written:</span></span>
```csharp
{
    for_initializer ;
    while ( for_condition ) {
        embedded_statement ;
        for_iterator ;
    }
}
```

<span data-ttu-id="294e4-294">Si *for_condition* se omite en la instrucción `for` , la evaluación de la asignación definitiva continúa como si *for_condition* se reemplazara por `true` en la expansión anterior.</span><span class="sxs-lookup"><span data-stu-id="294e4-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="294e4-295">Instrucciones break, continue y Goto</span><span class="sxs-lookup"><span data-stu-id="294e4-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="294e4-296">El estado de asignación definitiva de *v* en la transferencia de flujo de control provocada `continue`por una `goto` `break`instrucción, o es igual que el estado de asignación definitiva de *v* al principio de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="294e4-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="294e4-297">Instrucciones Throw</span><span class="sxs-lookup"><span data-stu-id="294e4-297">Throw statements</span></span>

<span data-ttu-id="294e4-298">Para una instrucción *stmt* con el formato</span><span class="sxs-lookup"><span data-stu-id="294e4-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="294e4-299">El estado de asignación definitiva de *v* al principio de *expr* es igual que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="294e4-300">Instrucciones Return</span><span class="sxs-lookup"><span data-stu-id="294e4-300">Return statements</span></span>

<span data-ttu-id="294e4-301">Para una instrucción *stmt* con el formato</span><span class="sxs-lookup"><span data-stu-id="294e4-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="294e4-302">El estado de asignación definitiva de *v* al principio de *expr* es igual que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-303">Si *v* es un parámetro de salida, se debe asignar definitivamente:</span><span class="sxs-lookup"><span data-stu-id="294e4-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="294e4-304">después de *expr*</span><span class="sxs-lookup"><span data-stu-id="294e4-304">after *expr*</span></span>
    * <span data-ttu-id="294e4-305">o `finally` al final del bloque de`catch` o queincluye`try` la`return` instrucción. - `try` - `finally` - `finally`</span><span class="sxs-lookup"><span data-stu-id="294e4-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="294e4-306">Para una instrucción stmt de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="294e4-307">Si *v* es un parámetro de salida, se debe asignar definitivamente:</span><span class="sxs-lookup"><span data-stu-id="294e4-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="294e4-308">antes de *stmt*</span><span class="sxs-lookup"><span data-stu-id="294e4-308">before *stmt*</span></span>
    * <span data-ttu-id="294e4-309">o `finally` al final del bloque de`catch` o queincluye`try` la`return` instrucción. - `try` - `finally` - `finally`</span><span class="sxs-lookup"><span data-stu-id="294e4-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="294e4-310">Instrucciones try-catch</span><span class="sxs-lookup"><span data-stu-id="294e4-310">Try-catch statements</span></span>

<span data-ttu-id="294e4-311">Para una instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="294e4-312">El estado de asignación definitiva de *v* al principio de *try_block* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-313">El estado de asignación definitiva de *v* al principio de *catch_block_i* (para cualquier *i*) es el mismo que el estado de asignación definitiva de *v*al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-314">El estado de asignación definitiva de *v* en el punto final de *stmt* está asignado definitivamente si (y sólo si) *v* se asigna definitivamente en el punto final de  *try_block* y cada *catch_block_i* (para cada *i* de 1 a *n*).</span><span class="sxs-lookup"><span data-stu-id="294e4-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="294e4-315">Try-finally (instrucciones)</span><span class="sxs-lookup"><span data-stu-id="294e4-315">Try-finally statements</span></span>

<span data-ttu-id="294e4-316">Para una `try` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="294e4-317">El estado de asignación definitiva de *v* al principio de *try_block* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-318">El estado de asignación definitiva de *v* al principio de *finally_block* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-319">El estado de asignación definitiva de *v* en el punto final de *stmt* se asigna definitivamente si (y solo si) se cumple al menos una de las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="294e4-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="294e4-320">*v* se asigna definitivamente en el punto final de *try_block*</span><span class="sxs-lookup"><span data-stu-id="294e4-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="294e4-321">*v* se asigna definitivamente en el punto final de *finally_block*</span><span class="sxs-lookup"><span data-stu-id="294e4-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="294e4-322">Si se realiza una transferencia de flujo de control ( `goto` por ejemplo, una instrucción) que comienza dentro de *try_block*y finaliza fuera de *try_block*, también se considera que *v* está asignado definitivamente en esa transferencia de flujo de control si *v* es se asigna definitivamente en el extremo de *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="294e4-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="294e4-323">(Esto no es solo si, si *v* se asigna definitivamente por otro motivo en esta transferencia de flujo de control, todavía se considera asignada definitivamente).</span><span class="sxs-lookup"><span data-stu-id="294e4-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="294e4-324">Instrucciones try-catch-finally</span><span class="sxs-lookup"><span data-stu-id="294e4-324">Try-catch-finally statements</span></span>

<span data-ttu-id="294e4-325">Análisis de asignación definitiva para una `try` - `catch` - instrucción delaforma:`finally`</span><span class="sxs-lookup"><span data-stu-id="294e4-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="294e4-326">se realiza como si la instrucción fuera una `try` - `try` - `finally` instrucción que incluye una `catch` instrucción:</span><span class="sxs-lookup"><span data-stu-id="294e4-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
    try try_block
    catch(...) catch_block_1
    ...
    catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="294e4-327">En el ejemplo siguiente se muestra cómo los distintos bloques `try` de una instrucción ([la instrucción try](statements.md#the-try-statement)) afectan a la asignación definitiva.</span><span class="sxs-lookup"><span data-stu-id="294e4-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
    static void F() {
        int i, j;
        try {
            goto LABEL;
            // neither i nor j definitely assigned
            i = 1;
            // i definitely assigned
        }

        catch {
            // neither i nor j definitely assigned
            i = 3;
            // i definitely assigned
        }

        finally {
            // neither i nor j definitely assigned
            j = 5;
            // j definitely assigned
            }
        // i and j definitely assigned
        LABEL:;
        // j definitely assigned

    }
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="294e4-328">Instrucciones foreach</span><span class="sxs-lookup"><span data-stu-id="294e4-328">Foreach statements</span></span>

<span data-ttu-id="294e4-329">Para una `foreach` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="294e4-330">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-331">El estado de asignación definitiva de *v* en la transferencia de flujo de control a *embedded_statement* o al punto final de *stmt* es el mismo que el estado de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="294e4-332">Instrucciones Using</span><span class="sxs-lookup"><span data-stu-id="294e4-332">Using statements</span></span>

<span data-ttu-id="294e4-333">Para una `using` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="294e4-334">El estado de asignación definitiva de *v* al principio de *resource_acquisition* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-335">El estado de asignación definitiva de *v* en la transferencia de flujo de control a *embedded_statement* es el mismo que el estado de *v* al final de *resource_acquisition*.</span><span class="sxs-lookup"><span data-stu-id="294e4-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="294e4-336">Lock (instrucciones)</span><span class="sxs-lookup"><span data-stu-id="294e4-336">Lock statements</span></span>

<span data-ttu-id="294e4-337">Para una `lock` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="294e4-338">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-339">El estado de asignación definitiva de *v* en la transferencia de flujo de control a *embedded_statement* es el mismo que el estado de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="294e4-340">Yield (instrucciones)</span><span class="sxs-lookup"><span data-stu-id="294e4-340">Yield statements</span></span>

<span data-ttu-id="294e4-341">Para una `yield return` instrucción *stmt* de la forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="294e4-342">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="294e4-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="294e4-343">El estado de asignación definitiva de *v* al final de *stmt* es el mismo que el estado de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="294e4-344">Una `yield break` instrucción no tiene ningún efecto en el estado de asignación definitiva.</span><span class="sxs-lookup"><span data-stu-id="294e4-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="294e4-345">Reglas generales para expresiones simples</span><span class="sxs-lookup"><span data-stu-id="294e4-345">General rules for simple expressions</span></span>

<span data-ttu-id="294e4-346">La siguiente regla se aplica a estos tipos de expresiones: literales ([literales](expressions.md#literals)), nombres simples ([nombres simples](expressions.md#simple-names)), expresiones de acceso a miembros ([acceso a miembros](expressions.md#member-access)), expresiones de acceso base no indizadas ([acceso base](expressions.md#base-access)) `typeof`.expresiones ([el operador typeof](expressions.md#the-typeof-operator)), expresiones de valor predeterminado ([expresiones de valor predeterminado](expressions.md#default-value-expressions)) `nameof` y expresiones ([nombre de expresiones](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="294e4-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="294e4-347">El estado de asignación definitiva de *v* al final de dicha expresión es el mismo que el estado de asignación definitiva de *v* al principio de la expresión.</span><span class="sxs-lookup"><span data-stu-id="294e4-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="294e4-348">Reglas generales para expresiones con expresiones incrustadas</span><span class="sxs-lookup"><span data-stu-id="294e4-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="294e4-349">Las siguientes reglas se aplican a estos tipos de expresiones: expresiones entre paréntesis ([expresiones entre paréntesis](expressions.md#parenthesized-expressions)), expresiones de acceso a elementos ([acceso a elementos](expressions.md#element-access)), expresiones de acceso base con indexación ([acceso base](expressions.md#base-access)), incremento y Expresiones de decremento ([operadores de incremento y decremento](expressions.md#postfix-increment-and-decrement-operators) [postfijo, operadores de incremento y decremento de prefijo](expressions.md#prefix-increment-and-decrement-operators)), expresiones de conversión ([expresiones de conversión](expressions.md#cast-expressions)), `+` unario, `-`, `~`, expresiones `*`, `+` binario, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, expresiones `^` ([operadores aritméticos](expressions.md#arithmetic-operators), [operadores de desplazamiento](expressions.md#shift-operators), [operadores relacionales y de pruebas de tipos](expressions.md#relational-and-type-testing-operators), [operadores lógicos](expressions.md#logical-operators)), expresiones de asignación de compuestos ([asignación de compuestos](expressions.md#compound-assignment)), `checked` y expresiones `unchecked` ([operadores comprobados y sin comprobar](expressions.md#the-checked-and-unchecked-operators)), más matrices y delegado Expresiones de creación ([operador New](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="294e4-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="294e4-350">Cada una de estas expresiones tiene una o más subexpresiones que se evalúan de forma incondicional en un orden fijo.</span><span class="sxs-lookup"><span data-stu-id="294e4-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="294e4-351">Por ejemplo, el operador `%` binario evalúa el lado izquierdo del operador y, a continuación, el lado derecho.</span><span class="sxs-lookup"><span data-stu-id="294e4-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="294e4-352">Una operación de indización evalúa la expresión indizada y, a continuación, evalúa cada una de las expresiones de índice, en orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="294e4-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="294e4-353">En el caso de una expresión *expr*, que tiene subexpresiones *E1, E2,...,* en, evaluadas en ese orden:</span><span class="sxs-lookup"><span data-stu-id="294e4-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="294e4-354">El estado de asignación definitiva de *v* al principio de *E1* es el mismo que el estado de asignación definitiva al principio de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="294e4-355">El estado de asignación definitiva de *v* al principio de *ei* (*i* mayor que uno) es el mismo que el estado de asignación definitiva al final de la subexpresión anterior.</span><span class="sxs-lookup"><span data-stu-id="294e4-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="294e4-356">El estado de asignación definitiva de *v* al final de *expr* es el mismo que el estado de asignación definitiva al final de *en*</span><span class="sxs-lookup"><span data-stu-id="294e4-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="294e4-357">Expresiones de invocación y expresiones de creación de objetos</span><span class="sxs-lookup"><span data-stu-id="294e4-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="294e4-358">Para *una expresión de invocación de la* forma:</span><span class="sxs-lookup"><span data-stu-id="294e4-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="294e4-359">o una expresión de creación de objeto con el formato:</span><span class="sxs-lookup"><span data-stu-id="294e4-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="294e4-360">En el caso de una expresión de invocación, el estado de asignación definitiva de *v* antes de *primary_expression* es el mismo que el estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-361">En el caso de una expresión de invocación, el estado de asignación definitiva de *v* antes de *arg1* es el mismo que el estado de *v* después de *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="294e4-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="294e4-362">En el caso de una expresión de creación de objeto, el estado de asignación definitiva de *v* antes de *arg1* es el mismo que el estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-363">Para cada argumento *Argi*, el estado de asignación definitiva de *v* después de *Argi* viene determinado por las reglas de la expresión normal, `ref` omitiendo `out` los modificadores o.</span><span class="sxs-lookup"><span data-stu-id="294e4-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="294e4-364">Para cada argumento *argi* para cualquier *i* mayor que uno, el estado de asignación definitiva de *v* antes *argi* es el mismo que el estado de *v* después de la anterior *arg*.</span><span class="sxs-lookup"><span data-stu-id="294e4-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="294e4-365">Si la variable *v* se `out` pasa como argumento (es decir, un argumento con el `out v`formato) en cualquiera de los argumentos, el estado de *v* después de la *expresión* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="294e4-366">Casos el estado de *v* después de *expr* es el mismo que el estado de *v* después de *argn*.</span><span class="sxs-lookup"><span data-stu-id="294e4-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="294e4-367">Para inicializadores de matriz ([expresiones de creación de matriz](expressions.md#array-creation-expressions)), inicializadores de objeto ([inicializadores de objeto](expressions.md#object-initializers)), inicializadores de colección ([inicializadores de colección](expressions.md#collection-initializers)) e inicializadores de objeto anónimos (creación de[objetos anónimos Expresiones](expressions.md#anonymous-object-creation-expressions)), el estado de asignación definitiva viene determinado por la expansión en la que se definen estas construcciones en términos de.</span><span class="sxs-lookup"><span data-stu-id="294e4-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="294e4-368">Expresiones de asignación simples</span><span class="sxs-lookup"><span data-stu-id="294e4-368">Simple assignment expressions</span></span>

<span data-ttu-id="294e4-369">Para una expresión *expr* con el formato `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="294e4-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="294e4-370">El estado de asignación definitiva de *v* antes de *expr_rhs* es el mismo que el estado de asignación definitiva de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-371">El estado de asignación definitiva de *v* después de *expr* viene determinado por:</span><span class="sxs-lookup"><span data-stu-id="294e4-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="294e4-372">Si *w* es la misma variable que *v*, se asigna definitivamente el estado de asignación definitiva de *v* después de *expr* .</span><span class="sxs-lookup"><span data-stu-id="294e4-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="294e4-373">De lo contrario, si la asignación se produce en el constructor de instancia de un tipo de estructura, si *w* es un acceso de propiedad que designa una propiedad implementada automáticamente *P* en la instancia que se está construyendo y *v* es el campo de respaldo oculto de *P*, después se asigna definitivamente el estado de asignación definitiva de *v* después de *expr* .</span><span class="sxs-lookup"><span data-stu-id="294e4-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="294e4-374">De lo contrario, el estado de asignación definitiva de *v* después de *expr* es el mismo que el estado de asignación definitiva de *v* después de *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="294e4-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="294e4-375">Expresiones de & & (condicional AND)</span><span class="sxs-lookup"><span data-stu-id="294e4-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="294e4-376">Para una expresión *expr* con el formato `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="294e4-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="294e4-377">El estado de asignación definitiva de *v* antes de *expr_first* es el mismo que el estado de asignación definitiva de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-378">El estado de asignación definitiva de *v* antes de que *expr_second* se asigne definitivamente si el estado de *v* después de *expr_first* se asigna definitivamente o "se asigna definitivamente después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="294e4-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="294e4-379">De lo contrario, no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="294e4-380">El estado de asignación definitiva de *v* después de *expr* viene determinado por:</span><span class="sxs-lookup"><span data-stu-id="294e4-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="294e4-381">Si *expr_first* es una expresión constante con el valor `false`, el estado de asignación definitiva de *v* después de *expr* es igual que el estado de asignación definitiva de *v* después de *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="294e4-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="294e4-382">De lo contrario, si el estado de *v* después de *expr_first* se asigna definitivamente, el estado de *v* después de la *expresión* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="294e4-383">De lo contrario, si el estado de *v* después de *expr_second* está asignado definitivamente, y el estado de *v* después de *expr_first* es "definitivamente asignado después de la expresión false", el estado de *v* después de *expr* es definitivamente. vuelve.</span><span class="sxs-lookup"><span data-stu-id="294e4-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="294e4-384">De lo contrario, si el estado de *v* después de *expr_second* se asigna definitivamente o "se asigna definitivamente después de una expresión true", el estado de *v* después de *expr* es "definitivamente asignado después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="294e4-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="294e4-385">De lo contrario, si el estado de *v* después de *expr_first* es "definitivamente asignado después de la expresión false" y el estado de *v* después de *expr_second* es "definitivamente asignado después de la expresión false", el estado de *v* después *de expr* es "definitivamente asignada después de la expresión false".</span><span class="sxs-lookup"><span data-stu-id="294e4-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="294e4-386">De lo contrario, el estado de *v* después de *expr* no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="294e4-387">En el ejemplo</span><span class="sxs-lookup"><span data-stu-id="294e4-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="294e4-388">la variable `i` se considera asignada definitivamente en una de las instrucciones incrustadas `if` de una instrucción, pero no en la otra.</span><span class="sxs-lookup"><span data-stu-id="294e4-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="294e4-389">En la `if` instrucción de método `F`, la variable `i` se asigna definitivamente en la primera instrucción incrustada porque la ejecución de `(i = y)` la expresión siempre precede a la ejecución de esta instrucción incrustada.</span><span class="sxs-lookup"><span data-stu-id="294e4-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="294e4-390">Por el contrario, la `i` variable no está asignada definitivamente en la segunda instrucción incrustada, puesto `x >= 0` que podría haber probado false, `i` lo que da lugar a que se Desasigne la variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="294e4-391">|| expresiones (condicionales OR)</span><span class="sxs-lookup"><span data-stu-id="294e4-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="294e4-392">Para una expresión *expr* con el formato `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="294e4-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="294e4-393">El estado de asignación definitiva de *v* antes de *expr_first* es el mismo que el estado de asignación definitiva de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-394">El estado de asignación definitiva de *v* antes de que *expr_second* se asigne definitivamente si el estado de *v* después de *expr_first* se asigna definitivamente o "se asigna definitivamente después de la expresión false".</span><span class="sxs-lookup"><span data-stu-id="294e4-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="294e4-395">De lo contrario, no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="294e4-396">La instrucción de asignación definitiva de *v* después de *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="294e4-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="294e4-397">Si *expr_first* es una expresión constante con el valor `true`, el estado de asignación definitiva de *v* después de *expr* es igual que el estado de asignación definitiva de *v* después de *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="294e4-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="294e4-398">De lo contrario, si el estado de *v* después de *expr_first* se asigna definitivamente, el estado de *v* después de la *expresión* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="294e4-399">De lo contrario, si el estado de *v* después de *expr_second* se asigna definitivamente, y el estado de *v* después de *expr_first* es "definitivamente asignado después de una expresión true", el estado de *v* después de *expr* es definitivamente. vuelve.</span><span class="sxs-lookup"><span data-stu-id="294e4-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="294e4-400">De lo contrario, si el estado de *v* después de *expr_second* se asigna definitivamente o "se asigna definitivamente después de la expresión false", el estado de *v* después de *expr* es "definitivamente asignado después de la expresión false".</span><span class="sxs-lookup"><span data-stu-id="294e4-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="294e4-401">De lo contrario, si el estado de *v* después de *expr_first* es "definitivamente asignado después de una expresión true" y el estado de *v* después de *expr_second* es "definitivamente asignado después de una expresión true", el estado de *v* después de *expr* está "definitivamente asignada después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="294e4-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="294e4-402">De lo contrario, el estado de *v* después de *expr* no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="294e4-403">En el ejemplo</span><span class="sxs-lookup"><span data-stu-id="294e4-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="294e4-404">la variable `i` se considera asignada definitivamente en una de las instrucciones incrustadas `if` de una instrucción, pero no en la otra.</span><span class="sxs-lookup"><span data-stu-id="294e4-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="294e4-405">En la `if` instrucción de método `G`, la variable `i` se asigna definitivamente en la segunda instrucción incrustada porque la ejecución de `(i = y)` la expresión siempre precede a la ejecución de esta instrucción incrustada.</span><span class="sxs-lookup"><span data-stu-id="294e4-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="294e4-406">Por el contrario, la `i` variable no está asignada definitivamente en la primera instrucción incrustada, ya `x >= 0` que es posible que se haya `i` probado como true, lo que da lugar a que se Desasigne la variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="294e4-407">!</span><span class="sxs-lookup"><span data-stu-id="294e4-407">!</span></span> <span data-ttu-id="294e4-408">expresiones (negación lógica)</span><span class="sxs-lookup"><span data-stu-id="294e4-408">(logical negation) expressions</span></span>

<span data-ttu-id="294e4-409">Para una expresión *expr* con el formato `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="294e4-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="294e4-410">El estado de asignación definitiva de *v* antes de *expr_operand* es el mismo que el estado de asignación definitiva de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-411">El estado de asignación definitiva de *v* después de *expr* viene determinado por:</span><span class="sxs-lookup"><span data-stu-id="294e4-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="294e4-412">Si el estado de *v* después de \* expr_operand \* se asigna definitivamente, el estado de *v* después de la *expresión* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="294e4-413">Si el estado de *v* después de \* expr_operand \* no se asigna definitivamente, el estado de *v* después de *expr* no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="294e4-414">Si el estado de *v* después de \* expr_operand \* es "definitivamente asignado después de la expresión false", el estado de *v* después de *expr* es "definitivamente asignado después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="294e4-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="294e4-415">Si el estado de *v* después de \* expr_operand \* es "definitivamente asignado después de una expresión true", el estado de *v* después de *expr* es "definitivamente asignado después de la expresión false".</span><span class="sxs-lookup"><span data-stu-id="294e4-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="294e4-416">??</span><span class="sxs-lookup"><span data-stu-id="294e4-416">??</span></span> <span data-ttu-id="294e4-417">expresiones (uso combinado de NULL)</span><span class="sxs-lookup"><span data-stu-id="294e4-417">(null coalescing) expressions</span></span>

<span data-ttu-id="294e4-418">Para una expresión *expr* con el formato `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="294e4-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="294e4-419">El estado de asignación definitiva de *v* antes de *expr_first* es el mismo que el estado de asignación definitiva de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-420">El estado de asignación definitiva de *v* antes de *expr_second* es el mismo que el estado de asignación definitiva de *v* después de *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="294e4-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="294e4-421">La instrucción de asignación definitiva de *v* después de *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="294e4-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="294e4-422">Si *expr_first* es una expresión constante ([expresiones constantes](expressions.md#constant-expressions)) con valor null, el estado de *v* después de *expr* es el mismo que el estado de *v* después de *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="294e4-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="294e4-423">De lo contrario, el estado de *v* después de *expr* es el mismo que el estado de asignación definitiva de *v* después de *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="294e4-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="294e4-424">expresiones?: (condicionales)</span><span class="sxs-lookup"><span data-stu-id="294e4-424">?: (conditional) expressions</span></span>

<span data-ttu-id="294e4-425">Para una expresión *expr* con el formato `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="294e4-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="294e4-426">El estado de asignación definitiva de *v* antes de *expr_cond* es el mismo que el estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="294e4-427">El estado de asignación definitiva de *v* antes de *expr_true* se asigna definitivamente solo si se cumple una de las siguientes opciones:</span><span class="sxs-lookup"><span data-stu-id="294e4-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="294e4-428">*expr_cond* es una expresión constante con el valor`false`</span><span class="sxs-lookup"><span data-stu-id="294e4-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="294e4-429">el estado de *v* después de *expr_cond* se asigna definitivamente o "definitivamente se asigna después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="294e4-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="294e4-430">El estado de asignación definitiva de *v* antes de *expr_false* se asigna definitivamente solo si se cumple una de las siguientes opciones:</span><span class="sxs-lookup"><span data-stu-id="294e4-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="294e4-431">*expr_cond* es una expresión constante con el valor`true`</span><span class="sxs-lookup"><span data-stu-id="294e4-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="294e4-432">el estado de *v* después de *expr_cond* se asigna definitivamente o "se asigna definitivamente después de la expresión false".</span><span class="sxs-lookup"><span data-stu-id="294e4-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="294e4-433">El estado de asignación definitiva de *v* después de *expr* viene determinado por:</span><span class="sxs-lookup"><span data-stu-id="294e4-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="294e4-434">Si *expr_cond* es una expresión constante ([expresiones constantes](expressions.md#constant-expressions)) con valor `true` , el estado de *v* después de *expr* es el mismo que el estado de *v* después de *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="294e4-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="294e4-435">De lo contrario, si *expr_cond* es una expresión constante ([expresiones constantes](expressions.md#constant-expressions)) `false` con valor, el estado de *v* después de *expr* es el mismo que el estado de *v* después de *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="294e4-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="294e4-436">De lo contrario, si el estado de *v* después de *expr_true* se asigna definitivamente y el estado de *v* después de *expr_false* se asigna definitivamente, el estado de *v* *después de* la asignación definitivamente se asigna.</span><span class="sxs-lookup"><span data-stu-id="294e4-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="294e4-437">De lo contrario, el estado de *v* después de *expr* no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="294e4-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="294e4-438">Funciones anónimas</span><span class="sxs-lookup"><span data-stu-id="294e4-438">Anonymous functions</span></span>

<span data-ttu-id="294e4-439">Para una *expresión* *lambda_expression* o *anonymous_method_expression* con un cuerpo ( *bloque* o *expresión*) *cuerpo*:</span><span class="sxs-lookup"><span data-stu-id="294e4-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="294e4-440">El estado de asignación definitiva de una variable externa *v* antes del *cuerpo* es el mismo que el estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="294e4-441">Es decir, el estado de asignación definitiva de las variables externas se hereda del contexto de la función anónima.</span><span class="sxs-lookup"><span data-stu-id="294e4-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="294e4-442">El estado de asignación definitiva de una variable externa *v* después de *expr* es igual que el estado de *v* antes de *expr*.</span><span class="sxs-lookup"><span data-stu-id="294e4-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="294e4-443">El ejemplo</span><span class="sxs-lookup"><span data-stu-id="294e4-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="294e4-444">genera un error en tiempo de compilación `max` , ya que no se asigna definitivamente donde se declara la función anónima.</span><span class="sxs-lookup"><span data-stu-id="294e4-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="294e4-445">El ejemplo</span><span class="sxs-lookup"><span data-stu-id="294e4-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="294e4-446">también genera un error en tiempo de compilación, ya que `n` la asignación a en la función anónima no tiene ningún efecto en el estado `n` de asignación definitiva de fuera de la función anónima.</span><span class="sxs-lookup"><span data-stu-id="294e4-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="294e4-447">Referencias de variables</span><span class="sxs-lookup"><span data-stu-id="294e4-447">Variable references</span></span>

<span data-ttu-id="294e4-448">Un *variable_reference* es una *expresión* que se clasifica como una variable.</span><span class="sxs-lookup"><span data-stu-id="294e4-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="294e4-449">Un *variable_reference* denota una ubicación de almacenamiento a la que se puede tener acceso para obtener el valor actual y para almacenar un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="294e4-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="294e4-450">En C y C++, una *variable_reference* se conoce como *lvalue*.</span><span class="sxs-lookup"><span data-stu-id="294e4-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="294e4-451">Atomicidad de referencias de variables</span><span class="sxs-lookup"><span data-stu-id="294e4-451">Atomicity of variable references</span></span>

<span data-ttu-id="294e4-452">Las lecturas y escrituras de los siguientes tipos de datos son `bool`atómicas `byte`: `sbyte`, `short` `char`,, `uint`, `int`, `float` `ushort`,,, y los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="294e4-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="294e4-453">Además, las operaciones de lectura y escritura de tipos de enumeración con un tipo subyacente en la lista anterior también son atómicas.</span><span class="sxs-lookup"><span data-stu-id="294e4-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="294e4-454">No se garantiza que las lecturas y escrituras `long`de `ulong`otros tipos, `decimal`incluidos,, `double`y, así como los tipos definidos por el usuario, sean atómicos.</span><span class="sxs-lookup"><span data-stu-id="294e4-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="294e4-455">Aparte de las funciones de biblioteca diseñadas para ese propósito, no hay ninguna garantía de lectura-modificación-escritura atómica, como en el caso de incremento o decremento.</span><span class="sxs-lookup"><span data-stu-id="294e4-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

