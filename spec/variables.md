# <a name="variables"></a><span data-ttu-id="0ae45-101">Variables</span><span class="sxs-lookup"><span data-stu-id="0ae45-101">Variables</span></span>

<span data-ttu-id="0ae45-102">Las variables representan ubicaciones de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="0ae45-102">Variables represent storage locations.</span></span> <span data-ttu-id="0ae45-103">Cada variable tiene un tipo que determina qué valores se pueden almacenar en la variable.</span><span class="sxs-lookup"><span data-stu-id="0ae45-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="0ae45-104">C# es un lenguaje con seguridad de tipos y el compilador de C# garantiza que los valores almacenados en variables siempre son del tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="0ae45-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="0ae45-105">El valor de una variable se puede cambiar mediante una asignación o mediante el uso de la `++` y `--` operadores.</span><span class="sxs-lookup"><span data-stu-id="0ae45-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="0ae45-106">Debe ser una variable ***asignado definitivamente*** ([asignación definitiva](variables.md#definite-assignment)) antes de que se puede obtener su valor.</span><span class="sxs-lookup"><span data-stu-id="0ae45-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="0ae45-107">Como se describe en las secciones siguientes, las variables son ***asignado inicialmente*** o ***inicialmente sin asignar***.</span><span class="sxs-lookup"><span data-stu-id="0ae45-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="0ae45-108">Una variable asignada inicialmente tiene un valor inicial bien definido y siempre se considera asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="0ae45-109">Una variable no asignada inicialmente no tiene ningún valor inicial.</span><span class="sxs-lookup"><span data-stu-id="0ae45-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="0ae45-110">Para que una variable no asignada inicialmente se considera asignado definitivamente en una determinada ubicación, se debe producir una asignación a la variable en cada ruta de acceso de ejecución posibles que dan lugar a esa ubicación.</span><span class="sxs-lookup"><span data-stu-id="0ae45-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="0ae45-111">Categorías de variables</span><span class="sxs-lookup"><span data-stu-id="0ae45-111">Variable categories</span></span>

<span data-ttu-id="0ae45-112">C# define siete categorías de variables: variables estáticas, variables de instancia, elementos de matriz, parámetros de valor, los parámetros de referencia, parámetros de salida y variables locales.</span><span class="sxs-lookup"><span data-stu-id="0ae45-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="0ae45-113">Las secciones siguientes describen cada una de estas categorías.</span><span class="sxs-lookup"><span data-stu-id="0ae45-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="0ae45-114">En el ejemplo</span><span class="sxs-lookup"><span data-stu-id="0ae45-114">In the example</span></span>
```csharp
class A
{
public static int x;
int y;

void F(int[] v, int a, ref int b, out int c) {
int i = 1;
c = a + b++;
}
}
```
<span data-ttu-id="0ae45-115">`x` es una variable estática, `y` es una variable de instancia, `v[0]` es un elemento de matriz, `a` es un parámetro de valor, `b` es un parámetro de referencia, `c` es un parámetro de salida, y `i` es una variable local.</span><span class="sxs-lookup"><span data-stu-id="0ae45-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="0ae45-116">Variables estáticas</span><span class="sxs-lookup"><span data-stu-id="0ae45-116">Static variables</span></span>

<span data-ttu-id="0ae45-117">Un campo declarado con el `static` modificador se denomina un ***variable estática***.</span><span class="sxs-lookup"><span data-stu-id="0ae45-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="0ae45-118">Una variable estática entra en existencia antes de la ejecución del constructor estático ([constructores estáticos](classes.md#static-constructors)) para su tipo contenedor y deja de existir cuando deja de existir el dominio de aplicación asociado.</span><span class="sxs-lookup"><span data-stu-id="0ae45-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="0ae45-119">El valor inicial de una variable estática es el valor predeterminado ([los valores predeterminados](variables.md#default-values)) del tipo de variable.</span><span class="sxs-lookup"><span data-stu-id="0ae45-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="0ae45-120">Para fines de comprobación de asignación definitiva, una variable estática se considera asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="0ae45-121">Variables de instancia</span><span class="sxs-lookup"><span data-stu-id="0ae45-121">Instance variables</span></span>

<span data-ttu-id="0ae45-122">Un campo declarado sin el `static` modificador se denomina un ***variable de instancia***.</span><span class="sxs-lookup"><span data-stu-id="0ae45-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="0ae45-123">Variables de instancia en clases</span><span class="sxs-lookup"><span data-stu-id="0ae45-123">Instance variables in classes</span></span>

<span data-ttu-id="0ae45-124">Una variable de instancia de una clase entra en existencia cuando se crea una nueva instancia de esa clase y deja de existir cuando no hay ninguna referencia a esa instancia y se ha ejecutado el destructor de la instancia (si existe).</span><span class="sxs-lookup"><span data-stu-id="0ae45-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="0ae45-125">El valor inicial de una variable de instancia de una clase es el valor predeterminado ([los valores predeterminados](variables.md#default-values)) del tipo de variable.</span><span class="sxs-lookup"><span data-stu-id="0ae45-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="0ae45-126">Con el fin de comprobación de asignación definitiva, una variable de instancia de una clase se considera asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="0ae45-127">Variables de instancia en structs</span><span class="sxs-lookup"><span data-stu-id="0ae45-127">Instance variables in structs</span></span>

<span data-ttu-id="0ae45-128">Una variable de instancia de una estructura tiene exactamente la misma duración que la variable de estructura a la que pertenece.</span><span class="sxs-lookup"><span data-stu-id="0ae45-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="0ae45-129">En otras palabras, cuando una variable de tipo struct entra en la existencia o deja de existir, lo hacer demasiado de las variables de instancia de la estructura.</span><span class="sxs-lookup"><span data-stu-id="0ae45-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="0ae45-130">El estado de asignación inicial de una variable de instancia de una estructura es el mismo que el de la variable de estructura.</span><span class="sxs-lookup"><span data-stu-id="0ae45-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="0ae45-131">En otras palabras, cuando una variable de estructura se considera asignada inicialmente, lo son demasiado sus variables de instancia, y cuando una variable de estructura se considera inicialmente sin asignar, sus variables de instancia del mismo modo están asignados.</span><span class="sxs-lookup"><span data-stu-id="0ae45-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="0ae45-132">Elementos de matriz</span><span class="sxs-lookup"><span data-stu-id="0ae45-132">Array elements</span></span>

<span data-ttu-id="0ae45-133">Los elementos de una matriz nazcan cuando se crea una instancia de matriz y dejan de existir cuando no hay referencias a esa instancia de matriz.</span><span class="sxs-lookup"><span data-stu-id="0ae45-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="0ae45-134">El valor inicial de cada uno de los elementos de una matriz es el valor predeterminado ([los valores predeterminados](variables.md#default-values)) del tipo de los elementos de matriz.</span><span class="sxs-lookup"><span data-stu-id="0ae45-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="0ae45-135">Con el fin de comprobación de asignación definitiva, un elemento de matriz se considera asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="0ae45-136">Parámetros de valor</span><span class="sxs-lookup"><span data-stu-id="0ae45-136">Value parameters</span></span>

<span data-ttu-id="0ae45-137">Un parámetro declarado sin un `ref` o `out` modificador es un ***parámetro value***.</span><span class="sxs-lookup"><span data-stu-id="0ae45-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="0ae45-138">Un parámetro de valor entra en existencia al invocar el miembro de función (método, constructor de instancia, operador o descriptor de acceso) o una función anónima al que pertenece el parámetro y se inicializa con el valor del argumento especificado en la invocación.</span><span class="sxs-lookup"><span data-stu-id="0ae45-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="0ae45-139">Un parámetro de valor normalmente deja de existir cuando se devuelve el miembro de función o función anónima.</span><span class="sxs-lookup"><span data-stu-id="0ae45-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="0ae45-140">Sin embargo, si el valor del parámetro se captura mediante una función anónima ([expresiones de función anónima](expressions.md#anonymous-function-expressions)), su duración se extiende al menos hasta que el delegado o árbol de expresión que se crea a partir de esa función anónima es apto para colección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="0ae45-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="0ae45-141">Con el fin de comprobación de asignación definitiva, un parámetro de valor se considera asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="0ae45-142">Parámetros de referencia</span><span class="sxs-lookup"><span data-stu-id="0ae45-142">Reference parameters</span></span>

<span data-ttu-id="0ae45-143">Un parámetro declarado con un `ref` modificador es un ***hacer referencia al parámetro***.</span><span class="sxs-lookup"><span data-stu-id="0ae45-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="0ae45-144">Un parámetro de referencia no crea una nueva ubicación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="0ae45-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="0ae45-145">En su lugar, un parámetro de referencia representa la misma ubicación de almacenamiento que la variable especificada como argumento en el miembro de función o la invocación de función anónima.</span><span class="sxs-lookup"><span data-stu-id="0ae45-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="0ae45-146">Por lo tanto, el valor de un parámetro de referencia es siempre el mismo que la variable subyacente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="0ae45-147">Se aplican las siguientes reglas de asignación definitiva a los parámetros de referencia.</span><span class="sxs-lookup"><span data-stu-id="0ae45-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="0ae45-148">Tenga en cuenta las distintas reglas de los parámetros de salida que se describe en [parámetros de salida](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="0ae45-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="0ae45-149">Una variable debe asignarlo definitivamente ([asignación definitiva](variables.md#definite-assignment)) antes de que se puede pasar como un parámetro de referencia en una invocación de función miembro o un delegado.</span><span class="sxs-lookup"><span data-stu-id="0ae45-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="0ae45-150">Dentro de un miembro de función o función anónima, un parámetro de referencia se considera asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="0ae45-151">Dentro de un método de instancia o un descriptor de acceso de instancia de un tipo de estructura, el `this` palabra clave se comporta exactamente como un parámetro de referencia de tipo struct ([este acceso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="0ae45-152">Parámetros de salida</span><span class="sxs-lookup"><span data-stu-id="0ae45-152">Output parameters</span></span>

<span data-ttu-id="0ae45-153">Un parámetro declarado con un `out` modificador es un ***parámetro de salida***.</span><span class="sxs-lookup"><span data-stu-id="0ae45-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="0ae45-154">Un parámetro de salida no crea una nueva ubicación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="0ae45-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="0ae45-155">En su lugar, un parámetro de salida representa la misma ubicación de almacenamiento que la variable especificada como argumento en la invocación de función miembro o un delegado.</span><span class="sxs-lookup"><span data-stu-id="0ae45-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="0ae45-156">Por lo tanto, el valor de un parámetro de salida es siempre el mismo que la variable subyacente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="0ae45-157">Se aplican las siguientes reglas de asignación definitiva a los parámetros de salida.</span><span class="sxs-lookup"><span data-stu-id="0ae45-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="0ae45-158">Tenga en cuenta las distintas reglas de los parámetros de referencia se describe en [hacen referencia a parámetros](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="0ae45-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="0ae45-159">Una variable no debe estar asignada definitivamente antes de que se puede pasar como un parámetro de salida en un miembro de función o la invocación de delegado.</span><span class="sxs-lookup"><span data-stu-id="0ae45-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="0ae45-160">Tras la finalización normal de una invocación de miembro o un delegado de función, cada variable que se pasó como un parámetro de salida se considera asignado en esa ruta de acceso de ejecución.</span><span class="sxs-lookup"><span data-stu-id="0ae45-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="0ae45-161">Dentro de un miembro de función o función anónima, un parámetro de salida se considera inicialmente sin asignar.</span><span class="sxs-lookup"><span data-stu-id="0ae45-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="0ae45-162">Cada parámetro de salida de un miembro de función o función anónima debe asignarlo definitivamente ([asignación definitiva](variables.md#definite-assignment)) antes de la función miembro o función anónima vuelve con normalidad.</span><span class="sxs-lookup"><span data-stu-id="0ae45-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="0ae45-163">Dentro de un constructor de instancia de un tipo de estructura, el `this` palabra clave se comporta exactamente como un parámetro de salida de tipo struct ([este acceso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="0ae45-164">Variables locales</span><span class="sxs-lookup"><span data-stu-id="0ae45-164">Local variables</span></span>

<span data-ttu-id="0ae45-165">Un ***variable local*** se declara mediante un *local_variable_declaration*, lo que puede producirse en un *bloque*, un *for_statement*, un *switch_statement* o un *using_statement*; o por un *foreach_statement* o un *specific_catch_clause* para un *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="0ae45-166">La duración de una variable local es la parte de la ejecución del programa durante el cual almacenamiento garantiza que se va a reservar para él.</span><span class="sxs-lookup"><span data-stu-id="0ae45-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="0ae45-167">Esta duración se extiende al menos desde la entrada en el *bloque*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, o *specific_catch_clause* con el que está asociado, hasta la ejecución de ese *bloque*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, o *specific_catch_clause* extremos de ninguna manera.</span><span class="sxs-lookup"><span data-stu-id="0ae45-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="0ae45-168">(Escriba un texto delimitado *bloque* o llamar a un método se suspende, pero no finaliza, la ejecución del elemento actual *bloque*, *for_statement*, *switch_statement* , *using_statement*, *foreach_statement*, o *specific_catch_clause*.) Si se captura la variable local mediante una función anónima ([capturan las variables externas](expressions.md#captured-outer-variables)), su duración se extiende al menos hasta que el árbol de expresión o delegado creado a partir de la función anónima, junto con cualquier otro objeto que vienen a referencia a la variable capturada, son aptas para la recolección.</span><span class="sxs-lookup"><span data-stu-id="0ae45-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="0ae45-169">Si el elemento primario *bloque*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, o *specific_catch_clause* se escribe de forma recursiva, se crea una nueva instancia de la variable local cada hora y su *local_variable_initializer*, si existe, se evalúa. cada vez.</span><span class="sxs-lookup"><span data-stu-id="0ae45-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="0ae45-170">Una variable local introducida por un *local_variable_declaration* no se inicializa automáticamente y, por tanto, no tiene ningún valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="0ae45-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="0ae45-171">Con el fin de comprobación de asignación definitiva, una variable local introducidos por un *local_variable_declaration* se considera inicialmente sin asignar.</span><span class="sxs-lookup"><span data-stu-id="0ae45-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="0ae45-172">Un *local_variable_declaration* puede incluir un *local_variable_initializer*, en cuyo caso la variable se considera asignada definitivamente solo después de la expresión de inicialización ([ Las instrucciones de declaración](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="0ae45-173">Dentro del ámbito de una variable local introducido por un *local_variable_declaration*, es un error en tiempo de compilación para hacer referencia a la variable local en una posición textual que precede a su *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="0ae45-174">Si la declaración de variable local es implícita ([declaraciones de variable Local](statements.md#local-variable-declarations)), también es un error hacer referencia a la variable dentro de su *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="0ae45-175">Una variable local introducida por un *foreach_statement* o un *specific_catch_clause* se considera asignado definitivamente en todo su ámbito.</span><span class="sxs-lookup"><span data-stu-id="0ae45-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="0ae45-176">La duración real de una variable local es depende de la implementación.</span><span class="sxs-lookup"><span data-stu-id="0ae45-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="0ae45-177">Por ejemplo, un compilador puede determinar estáticamente que solo se usa una variable local en un bloque de una pequeña parte de ese bloque.</span><span class="sxs-lookup"><span data-stu-id="0ae45-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="0ae45-178">Con este análisis, el compilador podría generar código que es el resultado en el almacenamiento de la variable tiene una duración más corta que su bloque contenedor.</span><span class="sxs-lookup"><span data-stu-id="0ae45-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="0ae45-179">El almacenamiento al que hace referencia una variable de referencia local se reclama independientemente de la duración de esa variable de referencia local ([administración de memoria automática](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="0ae45-180">Valores predeterminados</span><span class="sxs-lookup"><span data-stu-id="0ae45-180">Default values</span></span>

<span data-ttu-id="0ae45-181">Las siguientes categorías de variables se inicializan automáticamente en sus valores predeterminados:</span><span class="sxs-lookup"><span data-stu-id="0ae45-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="0ae45-182">Variables estáticas.</span><span class="sxs-lookup"><span data-stu-id="0ae45-182">Static variables.</span></span>
*  <span data-ttu-id="0ae45-183">Variables de instancia de instancias de clase.</span><span class="sxs-lookup"><span data-stu-id="0ae45-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="0ae45-184">Elementos de la matriz.</span><span class="sxs-lookup"><span data-stu-id="0ae45-184">Array elements.</span></span>

<span data-ttu-id="0ae45-185">El valor predeterminado de una variable depende del tipo de la variable y se determina como sigue:</span><span class="sxs-lookup"><span data-stu-id="0ae45-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="0ae45-186">Para una variable de un *value_type*, el valor predeterminado es el mismo que el valor calculado por el *value_type*del constructor predeterminado ([constructores predeterminados](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="0ae45-187">Para una variable de un *reference_type*, el valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="0ae45-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="0ae45-188">Inicialización de los valores predeterminados normalmente se consigue haciendo que el Administrador de memoria o el recolector de elementos no utilizados inicializar la memoria para todos los bits cero antes de está asignada para su uso.</span><span class="sxs-lookup"><span data-stu-id="0ae45-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="0ae45-189">Por este motivo, es conveniente utilizar todos los bits cero para representar la referencia nula.</span><span class="sxs-lookup"><span data-stu-id="0ae45-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="0ae45-190">Asignación definitiva</span><span class="sxs-lookup"><span data-stu-id="0ae45-190">Definite assignment</span></span>

<span data-ttu-id="0ae45-191">En una ubicación especificada en el código ejecutable de un miembro de función, una variable se dice que ***asignado definitivamente*** si el compilador puede probar, mediante un análisis de flujo estático concreto ([reglas precisas para determinar definitiva asignación](variables.md#precise-rules-for-determining-definite-assignment)), que la variable se ha inicializado automáticamente o ha sido el destino de al menos una asignación.</span><span class="sxs-lookup"><span data-stu-id="0ae45-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="0ae45-192">De manera informal se ha indicado, las reglas de asignación definitiva son:</span><span class="sxs-lookup"><span data-stu-id="0ae45-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="0ae45-193">Una variable asignada inicialmente ([variables asignadas inicialmente](variables.md#initially-assigned-variables)) siempre se considera asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="0ae45-194">Una variable no asignada inicialmente ([inicialmente sin asignar variables](variables.md#initially-unassigned-variables)) se considera asignado definitivamente en una ubicación determinada si todas las rutas de ejecución posibles que llevan a esa ubicación contengan al menos uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="0ae45-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="0ae45-195">Una asignación simple ([asignación Simple](expressions.md#simple-assignment)) en el que la variable es el operando izquierdo.</span><span class="sxs-lookup"><span data-stu-id="0ae45-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="0ae45-196">Una expresión de invocación ([expresiones de invocación](expressions.md#invocation-expressions)) o una expresión de creación de objeto ([expresiones de creación de objeto](expressions.md#object-creation-expressions)) que pasa la variable como un parámetro de salida.</span><span class="sxs-lookup"><span data-stu-id="0ae45-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="0ae45-197">Para una variable local, una declaración de variable local ([declaraciones de variable Local](statements.md#local-variable-declarations)) que incluye un inicializador de variable.</span><span class="sxs-lookup"><span data-stu-id="0ae45-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="0ae45-198">La especificación formal subyacente a las reglas informales anteriores se describe en [variables asignadas inicialmente](variables.md#initially-assigned-variables), [inicialmente sin asignar variables](variables.md#initially-unassigned-variables), y [reglas precisas para determinar asignación definitiva](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="0ae45-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="0ae45-199">Los Estados de asignación definitiva de variables de instancia de un *struct_type* variable se realiza un seguimiento individual y también colectivo.</span><span class="sxs-lookup"><span data-stu-id="0ae45-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="0ae45-200">En adicionales a las reglas anteriores, las reglas siguientes se aplican a *struct_type* variables y sus variables de instancia:</span><span class="sxs-lookup"><span data-stu-id="0ae45-200">In additional to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="0ae45-201">Una variable de instancia se considera asignada definitivamente si lo contiene *struct_type* variable se considera asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="0ae45-202">Un *struct_type* variable se considera asignado definitivamente si cada uno de sus variables de instancia se considera asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="0ae45-203">Asignación definitiva es un requisito en los contextos siguientes:</span><span class="sxs-lookup"><span data-stu-id="0ae45-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="0ae45-204">Una variable debe estar asignada definitivamente en cada ubicación donde se obtiene su valor.</span><span class="sxs-lookup"><span data-stu-id="0ae45-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="0ae45-205">Esto garantiza que nunca se producen valores no definidos.</span><span class="sxs-lookup"><span data-stu-id="0ae45-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="0ae45-206">Se considera la aparición de una variable en una expresión para obtener el valor de la variable, excepto cuando</span><span class="sxs-lookup"><span data-stu-id="0ae45-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="0ae45-207">la variable es el operando izquierdo de una asignación simple,</span><span class="sxs-lookup"><span data-stu-id="0ae45-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="0ae45-208">la variable se pasa como parámetro de salida, o</span><span class="sxs-lookup"><span data-stu-id="0ae45-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="0ae45-209">la variable es un *struct_type* variable y se produce como el operando izquierdo de un acceso de miembro.</span><span class="sxs-lookup"><span data-stu-id="0ae45-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="0ae45-210">Una variable debe estar asignada definitivamente en cada ubicación donde se pasa como un parámetro de referencia.</span><span class="sxs-lookup"><span data-stu-id="0ae45-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="0ae45-211">Esto garantiza que el miembro de función que se invoca puede tener en cuenta el parámetro de referencia asignado inicialmente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="0ae45-212">Todos los parámetros de salida de un miembro de función deben asignarlo definitivamente en cada ubicación donde se devuelve el miembro de función (a través de un `return` instrucción o a través de la ejecución llega al final del cuerpo de miembro de función).</span><span class="sxs-lookup"><span data-stu-id="0ae45-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="0ae45-213">Esto garantiza que los miembros de función no devuelven valores no definidos en los parámetros de salida, lo que permite al compilador que considere la posibilidad de una invocación de miembros de función que toma una variable como un parámetro de salida equivalente a una asignación a la variable.</span><span class="sxs-lookup"><span data-stu-id="0ae45-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="0ae45-214">El `this` variable de un *struct_type* constructor de instancia debe asignarlo definitivamente en cada ubicación donde se devuelve ese constructor de instancia.</span><span class="sxs-lookup"><span data-stu-id="0ae45-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="0ae45-215">Variables asignadas inicialmente</span><span class="sxs-lookup"><span data-stu-id="0ae45-215">Initially assigned variables</span></span>

<span data-ttu-id="0ae45-216">Las siguientes categorías de variables se clasifican como asignadas inicialmente:</span><span class="sxs-lookup"><span data-stu-id="0ae45-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="0ae45-217">Variables estáticas.</span><span class="sxs-lookup"><span data-stu-id="0ae45-217">Static variables.</span></span>
*  <span data-ttu-id="0ae45-218">Variables de instancia de instancias de clase.</span><span class="sxs-lookup"><span data-stu-id="0ae45-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="0ae45-219">Variables de instancia de variables de estructura asignadas inicialmente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="0ae45-220">Elementos de la matriz.</span><span class="sxs-lookup"><span data-stu-id="0ae45-220">Array elements.</span></span>
*  <span data-ttu-id="0ae45-221">Parámetros de valor.</span><span class="sxs-lookup"><span data-stu-id="0ae45-221">Value parameters.</span></span>
*  <span data-ttu-id="0ae45-222">Parámetros de referencia.</span><span class="sxs-lookup"><span data-stu-id="0ae45-222">Reference parameters.</span></span>
*  <span data-ttu-id="0ae45-223">Las variables declaradas en un `catch` cláusula o `foreach` instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="0ae45-224">Variables inicialmente sin asignar</span><span class="sxs-lookup"><span data-stu-id="0ae45-224">Initially unassigned variables</span></span>

<span data-ttu-id="0ae45-225">Las siguientes categorías de variables se clasifican como inicialmente sin asignar:</span><span class="sxs-lookup"><span data-stu-id="0ae45-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="0ae45-226">Variables de instancia de struct inicialmente sin asignar variables.</span><span class="sxs-lookup"><span data-stu-id="0ae45-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="0ae45-227">Parámetros de salida, incluida la `this` variable de constructores de instancia de struct.</span><span class="sxs-lookup"><span data-stu-id="0ae45-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="0ae45-228">Las variables locales, excepto los declarados en un `catch` cláusula o `foreach` instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="0ae45-229">Reglas precisas para determinar la asignación definitiva</span><span class="sxs-lookup"><span data-stu-id="0ae45-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="0ae45-230">Con el fin de determinar que cada variable utilizada se asigna definitivamente, el compilador debe usar un proceso que es equivalente a la descrita en esta sección.</span><span class="sxs-lookup"><span data-stu-id="0ae45-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="0ae45-231">El compilador procesa el cuerpo de cada miembro de función que tiene una o más variables inicialmente sin asignar.</span><span class="sxs-lookup"><span data-stu-id="0ae45-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="0ae45-232">Para cada variable inicialmente sin asignar *v*, el compilador determina un ***estado de asignación definitiva*** para *v* en cada uno de los siguientes puntos en el miembro de función:</span><span class="sxs-lookup"><span data-stu-id="0ae45-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="0ae45-233">Al principio de cada instrucción</span><span class="sxs-lookup"><span data-stu-id="0ae45-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="0ae45-234">En el punto final ([puntos finales y alcance](statements.md#end-points-and-reachability)) de cada instrucción</span><span class="sxs-lookup"><span data-stu-id="0ae45-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="0ae45-235">En cada arco que transfiere el control a otra instrucción o al punto final de una instrucción</span><span class="sxs-lookup"><span data-stu-id="0ae45-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="0ae45-236">Al principio de cada expresión</span><span class="sxs-lookup"><span data-stu-id="0ae45-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="0ae45-237">Al final de cada expresión</span><span class="sxs-lookup"><span data-stu-id="0ae45-237">At the end of each expression</span></span>

<span data-ttu-id="0ae45-238">El estado de asignación definitiva de *v* puede ser:</span><span class="sxs-lookup"><span data-stu-id="0ae45-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="0ae45-239">Asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-239">Definitely assigned.</span></span> <span data-ttu-id="0ae45-240">Indica que todos los flujos de control posibles en este punto, *v* se ha asignado un valor.</span><span class="sxs-lookup"><span data-stu-id="0ae45-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="0ae45-241">No asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-241">Not definitely assigned.</span></span> <span data-ttu-id="0ae45-242">El estado de una variable al final de una expresión de tipo `bool`, el estado de una variable que no se ha asignado definitivamente mayo (pero no necesariamente) se dividen en uno de los subestados siguientes:</span><span class="sxs-lookup"><span data-stu-id="0ae45-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="0ae45-243">Se asigna definitivamente después de una expresión es true.</span><span class="sxs-lookup"><span data-stu-id="0ae45-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="0ae45-244">Este estado indica que *v* se asigna definitivamente si la expresión booleana se evalúa como true, pero no se asigna necesariamente si la expresión booleana se evalúa como false.</span><span class="sxs-lookup"><span data-stu-id="0ae45-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="0ae45-245">Se asigna definitivamente después de una expresión es false.</span><span class="sxs-lookup"><span data-stu-id="0ae45-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="0ae45-246">Este estado indica que *v* se asigna definitivamente si la expresión booleana se evalúa como false, pero no se asigna necesariamente si la expresión booleana se evalúa como true.</span><span class="sxs-lookup"><span data-stu-id="0ae45-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="0ae45-247">Las siguientes reglas determinan cómo el estado de una variable *v* viene determinada en cada ubicación.</span><span class="sxs-lookup"><span data-stu-id="0ae45-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="0ae45-248">Reglas generales para las instrucciones</span><span class="sxs-lookup"><span data-stu-id="0ae45-248">General rules for statements</span></span>

*  <span data-ttu-id="0ae45-249">*v* no se asigna definitivamente al principio de un cuerpo de función miembro.</span><span class="sxs-lookup"><span data-stu-id="0ae45-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="0ae45-250">*v* se asigna definitivamente al principio de cualquier instrucción inalcanzable.</span><span class="sxs-lookup"><span data-stu-id="0ae45-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="0ae45-251">El estado de asignación definitiva de *v* al principio de cualquier otra instrucción se determina comprobando el estado de asignación definitiva de *v* en todas las transferencias de flujo de control que tienen como destino el principio de la que instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="0ae45-252">Si (y sólo si) *v* se asigna definitivamente en todas estas transferencias de flujo de control, a continuación, *v* se asigna definitivamente al principio de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="0ae45-253">El conjunto de transferencias de flujo de control posibles se determina en la misma manera que el alcance de la instrucción de comprobación ([puntos finales y alcance](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="0ae45-254">El estado de asignación definitiva de *v* en el punto final de un bloque, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, o `switch` viene determinado por la comprobación del estado de asignación definitiva de *v* en todas las transferencias de flujo de control que tienen como destino el punto final de esa instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="0ae45-255">Si *v* se asigna definitivamente en todas estas transferencias de flujo de control, a continuación, *v* se asigna definitivamente en el punto final de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="0ae45-256">En caso contrario, *v* no se asigna definitivamente en el punto final de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="0ae45-257">El conjunto de transferencias de flujo de control posibles se determina en la misma manera que el alcance de la instrucción de comprobación ([puntos finales y alcance](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="0ae45-258">Instrucciones de bloque checked y unchecked</span><span class="sxs-lookup"><span data-stu-id="0ae45-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="0ae45-259">El estado de asignación definitiva de *v* en el control de transferencia de la primera instrucción de la lista de instrucciones en el bloque (o al punto final del bloque, si la lista de instrucciones está vacía) es el mismo que la instrucción de asignación definitiva de *v* antes del bloque, `checked`, o `unchecked` instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="0ae45-260">Instrucciones de expresión</span><span class="sxs-lookup"><span data-stu-id="0ae45-260">Expression statements</span></span>

<span data-ttu-id="0ae45-261">Para una instrucción de expresión *stmt* que consta de la expresión *expr*:</span><span class="sxs-lookup"><span data-stu-id="0ae45-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="0ae45-262">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-263">Si *v* si asigna definitivamente al final de *expr*, se asigna definitivamente en el punto final de *stmt*; en caso contrario, no se asigna definitivamente en el punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="0ae45-264">Instrucciones de declaración</span><span class="sxs-lookup"><span data-stu-id="0ae45-264">Declaration statements</span></span>

*  <span data-ttu-id="0ae45-265">Si *stmt* es una instrucción de declaración sin inicializadores, a continuación, *v* tiene el mismo estado de asignación definitiva en el punto final de *stmt* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-266">Si *stmt* es una instrucción de declaración con inicializadores, a continuación, el estado de asignación definitiva para *v* se determina como si *stmt* eran una lista de instrucciones, con una asignación instrucción para cada declaración con un inicializador (en el orden de declaración).</span><span class="sxs-lookup"><span data-stu-id="0ae45-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="0ae45-267">Si las instrucciones</span><span class="sxs-lookup"><span data-stu-id="0ae45-267">If statements</span></span>

<span data-ttu-id="0ae45-268">Para un `if` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="0ae45-269">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-270">Si *v* se asigna definitivamente al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control a *then_stmt* y cualquiera *else_stmt*  o para el punto de conexión de *stmt* si no hay ninguna cláusula else.</span><span class="sxs-lookup"><span data-stu-id="0ae45-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="0ae45-271">Si *v* tiene el estado "asignado definitivamente después de una expresión true" al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control a *then_stmt*y no asignado definitivamente en la transferencia de flujo de control como *else_stmt* o para el punto de conexión de *stmt* si no hay ninguna cláusula else.</span><span class="sxs-lookup"><span data-stu-id="0ae45-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="0ae45-272">Si *v* tiene el estado "asignado definitivamente después de una expresión false" al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control a *else_stmt*y no se asigna definitivamente en la transferencia de flujo de control a *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="0ae45-273">Se asigna definitivamente en el punto final de *stmt* solo si se asigna definitivamente en el punto final de *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="0ae45-274">En caso contrario, *v* no se considera asignado definitivamente en la transferencia de flujo de control como el *then_stmt* o *else_stmt*, o para el punto de conexión de  *stmt* si no hay ninguna cláusula else.</span><span class="sxs-lookup"><span data-stu-id="0ae45-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="0ae45-275">Instrucciones switch</span><span class="sxs-lookup"><span data-stu-id="0ae45-275">Switch statements</span></span>

<span data-ttu-id="0ae45-276">En un `switch` instrucción *stmt* con una expresión de control *expr*:</span><span class="sxs-lookup"><span data-stu-id="0ae45-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="0ae45-277">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-278">El estado de asignación definitiva de *v* transferencia a una lista de instrucciones switch puede obtener acceso al bloque en el flujo de control es el mismo que el estado de asignación definitiva de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="0ae45-279">Instrucciones while</span><span class="sxs-lookup"><span data-stu-id="0ae45-279">While statements</span></span>

<span data-ttu-id="0ae45-280">Para un `while` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="0ae45-281">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-282">Si *v* se asigna definitivamente al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control a *while_body* y para el punto final de  *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-283">Si *v* tiene el estado "asignado definitivamente después de una expresión true" al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control a *while_body*, pero no se asigna definitivamente en el punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-284">Si *v* tiene el estado "asignado definitivamente después de una expresión false" al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control para el punto final de *stmt* , pero no asignado definitivamente en la transferencia de flujo de control a *while_body*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="0ae45-285">Siga las instrucciones</span><span class="sxs-lookup"><span data-stu-id="0ae45-285">Do statements</span></span>

<span data-ttu-id="0ae45-286">Para un `do` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="0ae45-287">*v* tiene el mismo estado de asignación definitiva en la transferencia de flujo de control desde el principio del *stmt* a *do_body* como al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-288">*v* tiene el mismo estado de asignación definitiva al principio de *expr* como en el punto final de *do_body*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="0ae45-289">Si *v* se asigna definitivamente al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control para el punto final de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-290">Si *v* tiene el estado "asignado definitivamente después de una expresión false" al final de *expr*, a continuación, se asigna definitivamente en la transferencia de flujo de control para el punto final de *stmt* .</span><span class="sxs-lookup"><span data-stu-id="0ae45-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="0ae45-291">Para las instrucciones</span><span class="sxs-lookup"><span data-stu-id="0ae45-291">For statements</span></span>

<span data-ttu-id="0ae45-292">Asignación definitiva buscando un `for` instrucción del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="0ae45-293">se realiza como si hubiera escrito la instrucción:</span><span class="sxs-lookup"><span data-stu-id="0ae45-293">is done as if the statement were written:</span></span>
```csharp
{
for_initializer ;
while ( for_condition ) {
embedded_statement ;
for_iterator ;
}
}
```

<span data-ttu-id="0ae45-294">Si el *for_condition* se omite de la `for` instrucción y, a continuación, la evaluación de asignación definitiva continúa como si *for_condition* se reemplazaron con `true` en la expansión anterior .</span><span class="sxs-lookup"><span data-stu-id="0ae45-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="0ae45-295">Break, continue y las instrucciones goto</span><span class="sxs-lookup"><span data-stu-id="0ae45-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="0ae45-296">El estado de asignación definitiva de *v* en la transferencia de flujo de control causada por un `break`, `continue`, o `goto` instrucción es el mismo que el estado de asignación definitiva de *v* en el a partir de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="0ae45-297">Throw (instrucciones)</span><span class="sxs-lookup"><span data-stu-id="0ae45-297">Throw statements</span></span>

<span data-ttu-id="0ae45-298">Para una instrucción *stmt* del formulario</span><span class="sxs-lookup"><span data-stu-id="0ae45-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="0ae45-299">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="0ae45-300">Instrucciones return</span><span class="sxs-lookup"><span data-stu-id="0ae45-300">Return statements</span></span>

<span data-ttu-id="0ae45-301">Para una instrucción *stmt* del formulario</span><span class="sxs-lookup"><span data-stu-id="0ae45-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="0ae45-302">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-303">Si *v* es un parámetro output, a continuación, se debe asignarlo definitivamente cualquiera:</span><span class="sxs-lookup"><span data-stu-id="0ae45-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="0ae45-304">una vez *expr*</span><span class="sxs-lookup"><span data-stu-id="0ae45-304">after *expr*</span></span>
    * <span data-ttu-id="0ae45-305">o al final de la `finally` block de un `try` - `finally` o `try` - `catch` - `finally` que rodea el `return` instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="0ae45-306">Para una instrucción stmt del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="0ae45-307">Si *v* es un parámetro output, a continuación, se debe asignarlo definitivamente cualquiera:</span><span class="sxs-lookup"><span data-stu-id="0ae45-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="0ae45-308">antes de *stmt*</span><span class="sxs-lookup"><span data-stu-id="0ae45-308">before *stmt*</span></span>
    * <span data-ttu-id="0ae45-309">o al final de la `finally` block de un `try` - `finally` o `try` - `catch` - `finally` que rodea el `return` instrucción.</span><span class="sxs-lookup"><span data-stu-id="0ae45-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="0ae45-310">Instrucciones try-catch</span><span class="sxs-lookup"><span data-stu-id="0ae45-310">Try-catch statements</span></span>

<span data-ttu-id="0ae45-311">Para una instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="0ae45-312">El estado de asignación definitiva de *v* al principio de *try_block* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-313">El estado de asignación definitiva de *v* al principio de *catch_block_i* (para cualquier *i*) es el mismo que el estado de asignación definitiva de *v*al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-314">El estado de asignación definitiva de *v* en el punto final de *stmt* está asignado definitivamente si (y sólo si) *v* se asigna definitivamente en el punto final de *try_block* y cada *catch_block_i* (para cada *i* de 1 a *n*).</span><span class="sxs-lookup"><span data-stu-id="0ae45-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="0ae45-315">Instrucciones try-finally</span><span class="sxs-lookup"><span data-stu-id="0ae45-315">Try-finally statements</span></span>

<span data-ttu-id="0ae45-316">Para un `try` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="0ae45-317">El estado de asignación definitiva de *v* al principio de *try_block* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-318">El estado de asignación definitiva de *v* al principio de *finally_block* es el mismo que el estado de asignación definitiva de *v* al principio de *stmt* .</span><span class="sxs-lookup"><span data-stu-id="0ae45-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-319">El estado de asignación definitiva de *v* en el punto final de *stmt* está asignado definitivamente si (y sólo si) al menos uno de los siguientes es true:</span><span class="sxs-lookup"><span data-stu-id="0ae45-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="0ae45-320">*v* se asigna definitivamente en el punto final de *try_block*</span><span class="sxs-lookup"><span data-stu-id="0ae45-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="0ae45-321">*v* se asigna definitivamente en el punto final de *finally_block*</span><span class="sxs-lookup"><span data-stu-id="0ae45-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="0ae45-322">Si una transferencia de flujo de control (por ejemplo, un `goto` instrucción) se realiza alguna que comienza en *try_block*y termina fuera de *try_block*, a continuación, *v* también es considera asignado definitivamente en esa transferencia de flujo de control si *v* se asigna definitivamente en el punto final de *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="0ae45-323">(Esta condición no es exclusiva: si *v* se asigna definitivamente por otra razón en esta transferencia de flujo de control, a continuación, se considera asignado definitivamente.)</span><span class="sxs-lookup"><span data-stu-id="0ae45-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="0ae45-324">Instrucciones try-catch-finally</span><span class="sxs-lookup"><span data-stu-id="0ae45-324">Try-catch-finally statements</span></span>

<span data-ttu-id="0ae45-325">Análisis de asignación definitiva para un `try` - `catch` - `finally` instrucción del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="0ae45-326">se realiza como si la instrucción fuera un `try` - `finally` instrucción envolvente un `try` - `catch` instrucción:</span><span class="sxs-lookup"><span data-stu-id="0ae45-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="0ae45-327">En el ejemplo siguiente se muestra cómo los diferentes bloques de un `try` instrucción ([la instrucción try](statements.md#the-try-statement)) afectan a la asignación definitiva.</span><span class="sxs-lookup"><span data-stu-id="0ae45-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
static void F() {
int i, j;
try {
goto LABEL;
// neither i nor j definitely assigned
i = 1;
// i definitely assigned
}

catch {
// neither i nor j definitely assigned
i = 3;
// i definitely assigned
}

finally {
// neither i nor j definitely assigned
j = 5;
// j definitely assigned
}
// i and j definitely assigned
LABEL:;
// j definitely assigned

}
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="0ae45-328">Instrucciones foreach</span><span class="sxs-lookup"><span data-stu-id="0ae45-328">Foreach statements</span></span>

<span data-ttu-id="0ae45-329">Para un `foreach` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="0ae45-330">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-331">El estado de asignación definitiva de *v* en la transferencia de flujo de control a *embedded_statement* o hasta el punto final de *stmt* es el mismo que el estado de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="0ae45-332">Las instrucciones using</span><span class="sxs-lookup"><span data-stu-id="0ae45-332">Using statements</span></span>

<span data-ttu-id="0ae45-333">Para un `using` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="0ae45-334">El estado de asignación definitiva de *v* al principio de *resource_acquisition* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-335">El estado de asignación definitiva de *v* en la transferencia de flujo de control a *embedded_statement* es el mismo que el estado de *v* al final de *resource_ adquisición*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="0ae45-336">Instrucciones de bloqueo</span><span class="sxs-lookup"><span data-stu-id="0ae45-336">Lock statements</span></span>

<span data-ttu-id="0ae45-337">Para un `lock` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="0ae45-338">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-339">El estado de asignación definitiva de *v* en la transferencia de flujo de control a *embedded_statement* es el mismo que el estado de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="0ae45-340">Instrucciones yield</span><span class="sxs-lookup"><span data-stu-id="0ae45-340">Yield statements</span></span>

<span data-ttu-id="0ae45-341">Para un `yield return` instrucción *stmt* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="0ae45-342">El estado de asignación definitiva de *v* al principio de *expr* es el mismo que el estado de *v* al principio de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0ae45-343">El estado de asignación definitiva de *v* al final de *stmt* es el mismo que el estado de *v* al final de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="0ae45-344">Un `yield break` instrucción no tiene ningún efecto sobre el estado de asignación definitiva.</span><span class="sxs-lookup"><span data-stu-id="0ae45-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="0ae45-345">Reglas generales para las expresiones simples</span><span class="sxs-lookup"><span data-stu-id="0ae45-345">General rules for simple expressions</span></span>

<span data-ttu-id="0ae45-346">La siguiente regla se aplica a estos tipos de expresiones: literales ([literales](expressions.md#literals)), nombres simples ([nombres simples](expressions.md#simple-names)), expresiones de acceso a miembro ([acceso a miembros](expressions.md#member-access)), las expresiones de acceso base no indizada ([Base acceso](expressions.md#base-access)), `typeof` expresiones ([el operador typeof](expressions.md#the-typeof-operator)), expresiones de valor predeterminado ([expresiones de valor predeterminado ](expressions.md#default-value-expressions)) y `nameof` expresiones ([expresiones Nameof](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="0ae45-347">El estado de asignación definitiva de *v* al final de este tipo de expresión es el mismo que el estado de asignación definitiva de *v* al principio de la expresión.</span><span class="sxs-lookup"><span data-stu-id="0ae45-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="0ae45-348">Reglas generales para expresiones con expresiones incrustadas</span><span class="sxs-lookup"><span data-stu-id="0ae45-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="0ae45-349">Las reglas siguientes se aplican a estos tipos de expresiones: las expresiones entre paréntesis ([las expresiones entre paréntesis](expressions.md#parenthesized-expressions)), las expresiones de acceso de elemento ([acceso de elemento](expressions.md#element-access)) base, obtener acceso a las expresiones con indexación ([Base acceso](expressions.md#base-access)), aumentar y disminuir las expresiones ([operadores postfijos de incremento y decremento](expressions.md#postfix-increment-and-decrement-operators), [prefijo de incremento y decremento operadores](expressions.md#prefix-increment-and-decrement-operators)), las expresiones de conversión ([expresiones de conversión](expressions.md#cast-expressions)), unario `+`, `-`, `~`, `*` expresiones, binarias `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expresiones ([operadores aritméticos](expressions.md#arithmetic-operators), [operadores de desplazamiento](expressions.md#shift-operators), [operadores de comprobación de tipos y relacionales](expressions.md#relational-and-type-testing-operators) [Operadores lógicos](expressions.md#logical-operators)), compuesta de expresiones de asignación ([asignación compuesta](expressions.md#compound-assignment)), `checked` y `unchecked` expresiones ([checked y unchecked operadores](expressions.md#the-checked-and-unchecked-operators)), además de las expresiones de creación de matriz y un delegado ([el operador new](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="0ae45-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="0ae45-350">Cada una de estas expresiones tiene uno o más subexpresiones que se evalúan incondicionalmente en un orden fijo.</span><span class="sxs-lookup"><span data-stu-id="0ae45-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="0ae45-351">Por ejemplo, el archivo binario `%` operador evalúa el lado izquierdo del operador y, después, en el lado derecho.</span><span class="sxs-lookup"><span data-stu-id="0ae45-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="0ae45-352">Una operación de indización evalúa la expresión indizada y, a continuación, evalúa cada una de las expresiones de índice, en orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="0ae45-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="0ae45-353">Para una expresión *expr*, que tiene las subexpresiones *e1, e2,..., eN*, evaluada en ese orden:</span><span class="sxs-lookup"><span data-stu-id="0ae45-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="0ae45-354">El estado de asignación definitiva de *v* al principio de *e1* es el mismo que el estado de asignación definitiva al principio de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="0ae45-355">El estado de asignación definitiva de *v* al principio de *ei* (*i* mayor que uno) es el mismo que el estado de asignación definitiva al final de la subexpresión anterior.</span><span class="sxs-lookup"><span data-stu-id="0ae45-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="0ae45-356">El estado de asignación definitiva de *v* al final de *expr* es el mismo que el estado de asignación definitiva al final de *eN*</span><span class="sxs-lookup"><span data-stu-id="0ae45-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="0ae45-357">Expresiones de invocación y expresiones de creación de objeto</span><span class="sxs-lookup"><span data-stu-id="0ae45-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="0ae45-358">Para una expresión de invocación *expr* del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="0ae45-359">o una expresión de creación de objeto del formulario:</span><span class="sxs-lookup"><span data-stu-id="0ae45-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="0ae45-360">Para una expresión de invocación, el estado de asignación definitiva de *v* antes *primary_expression* es el mismo que el estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-361">Para una expresión de invocación, el estado de asignación definitiva de *v* antes *arg1* es el mismo que el estado de *v* después *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="0ae45-362">Para una expresión de creación de objeto, el estado de asignación definitiva de *v* antes *arg1* es el mismo que el estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-363">Para cada argumento *argi*, el estado de asignación definitiva de *v* después *argi* viene determinada por las reglas de expresión normales, se omitirá cualquier `ref` o `out`modificadores.</span><span class="sxs-lookup"><span data-stu-id="0ae45-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="0ae45-364">Para cada argumento *argi* para cualquier *i* mayor que uno, el estado de asignación definitiva de *v* antes *argi* es el mismo que el estado de *v* después de la anterior *arg*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="0ae45-365">Si la variable *v* se pasa como un `out` argumento (es decir, un argumento del formulario `out v`) en cualquiera de los argumentos y, a continuación, el estado de *v* después *expr* se ha asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="0ae45-366">En caso contrario, el estado de *v* después *expr* es el mismo que el estado de *v* después *argN*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="0ae45-367">Inicializadores de matriz ([expresiones de creación de matriz](expressions.md#array-creation-expressions)), inicializadores de objeto ([inicializadores de objeto](expressions.md#object-initializers)), los inicializadores de colección ([inicializadores de colección](expressions.md#collection-initializers)) y los inicializadores de objeto anónimo ([expresiones de creación de objeto anónimo](expressions.md#anonymous-object-creation-expressions)), el estado de asignación definitiva viene determinada por la expansión que estas construcciones se definen en términos de.</span><span class="sxs-lookup"><span data-stu-id="0ae45-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="0ae45-368">Expresiones de asignación simple</span><span class="sxs-lookup"><span data-stu-id="0ae45-368">Simple assignment expressions</span></span>

<span data-ttu-id="0ae45-369">Para una expresión *expr* del formulario `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="0ae45-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="0ae45-370">El estado de asignación definitiva de *v* antes *expr_rhs* es el mismo que el estado de asignación definitiva de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-371">El estado de asignación definitiva de *v* después *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="0ae45-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="0ae45-372">Si *w* es la misma variable como *v*, a continuación, el estado de asignación definitiva de *v* después *expr* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="0ae45-373">En caso contrario, si la asignación se produce dentro del constructor de instancia de un tipo de estructura, si *w* es un acceso de propiedad que designa una propiedad implementada automáticamente *P* en la instancia que se está construyendo y *v* es el campo de respaldo oculto de *P*, a continuación, el estado de asignación definitiva de *v* después *expr* definitivamente asignado.</span><span class="sxs-lookup"><span data-stu-id="0ae45-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="0ae45-374">En caso contrario, el estado de asignación definitiva de *v* después *expr* es el mismo que el estado de asignación definitiva de *v* después *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="0ae45-375">& & (AND condicional) expresiones</span><span class="sxs-lookup"><span data-stu-id="0ae45-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="0ae45-376">Para una expresión *expr* del formulario `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="0ae45-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="0ae45-377">El estado de asignación definitiva de *v* antes *expr_first* es el mismo que el estado de asignación definitiva de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-378">El estado de asignación definitiva de *v* antes *expr_second* se asigna definitivamente si el estado de *v* después *expr_first* sea asignado definitivamente o "asignado definitivamente después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="0ae45-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="0ae45-379">En caso contrario, no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="0ae45-380">El estado de asignación definitiva de *v* después *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="0ae45-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0ae45-381">Si *expr_first* es una expresión constante con el valor `false`, a continuación, el estado de asignación definitiva de *v* después *expr* es igual que la asignación definitiva estado de *v* después *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="0ae45-382">De lo contrario, si el estado de *v* después *expr_first* se asigna definitivamente, a continuación, el estado de *v* después *expr* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0ae45-383">De lo contrario, si el estado de *v* después *expr_second* se asigna definitivamente y el estado de *v* después *expr_first* "definitivamente asignado después de una expresión false", entonces el estado de *v* después *expr* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0ae45-384">De lo contrario, si el estado de *v* después *expr_second* se asigna definitivamente o "asignado definitivamente después de una expresión true", entonces el estado de *v* después  *Expr* es "asignado definitivamente después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="0ae45-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="0ae45-385">De lo contrario, si el estado de *v* después *expr_first* es "asignado definitivamente después de una expresión false" y el estado de *v* después *expr_second* es "asignado definitivamente después de una expresión false", entonces el estado de *v* después *expr* es "asignado definitivamente después de una expresión false".</span><span class="sxs-lookup"><span data-stu-id="0ae45-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="0ae45-386">En caso contrario, el estado de *v* después *expr* no se ha asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="0ae45-387">En el ejemplo</span><span class="sxs-lookup"><span data-stu-id="0ae45-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="0ae45-388">la variable `i` se considera asignado definitivamente en una de las instrucciones incrustadas de una `if` instrucción pero no en el otro.</span><span class="sxs-lookup"><span data-stu-id="0ae45-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="0ae45-389">En el `if` instrucción en el método `F`, la variable `i` se asigna definitivamente en la primera instrucción incrustada porque la ejecución de la expresión `(i = y)` siempre precede a la ejecución de esta instrucción incrustada.</span><span class="sxs-lookup"><span data-stu-id="0ae45-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="0ae45-390">En cambio, la variable `i` no se asigna definitivamente en la segunda instrucción incrustada, ya que `x >= 0` podría dar como resultado false, lo que resulta en la variable `i` sin asignar.</span><span class="sxs-lookup"><span data-stu-id="0ae45-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="0ae45-391">|| (OR condicional) expresiones</span><span class="sxs-lookup"><span data-stu-id="0ae45-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="0ae45-392">Para una expresión *expr* del formulario `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="0ae45-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="0ae45-393">El estado de asignación definitiva de *v* antes *expr_first* es el mismo que el estado de asignación definitiva de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-394">El estado de asignación definitiva de *v* antes *expr_second* se asigna definitivamente si el estado de *v* después *expr_first* sea asignado definitivamente o "asignado definitivamente después de una expresión false".</span><span class="sxs-lookup"><span data-stu-id="0ae45-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="0ae45-395">En caso contrario, no se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="0ae45-396">La instrucción de asignación definitiva de *v* después *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="0ae45-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0ae45-397">Si *expr_first* es una expresión constante con el valor `true`, a continuación, el estado de asignación definitiva de *v* después *expr* es igual que la asignación definitiva estado de *v* después *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="0ae45-398">De lo contrario, si el estado de *v* después *expr_first* se asigna definitivamente, a continuación, el estado de *v* después *expr* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0ae45-399">De lo contrario, si el estado de *v* después *expr_second* se asigna definitivamente y el estado de *v* después *expr_first* "definitivamente asignado después de una expresión true", entonces el estado de *v* después *expr* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0ae45-400">De lo contrario, si el estado de *v* después *expr_second* se asigna definitivamente o "asignado definitivamente después de una expresión false", entonces el estado de *v* después *expr* es "asignado definitivamente después de una expresión false".</span><span class="sxs-lookup"><span data-stu-id="0ae45-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="0ae45-401">De lo contrario, si el estado de *v* después *expr_first* es "asignado definitivamente después de una expresión true" y el estado de *v* después *expr_second*es "asignado definitivamente después de una expresión true", entonces el estado de *v* después *expr* es "asignado definitivamente después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="0ae45-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="0ae45-402">En caso contrario, el estado de *v* después *expr* no se ha asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="0ae45-403">En el ejemplo</span><span class="sxs-lookup"><span data-stu-id="0ae45-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="0ae45-404">la variable `i` se considera asignado definitivamente en una de las instrucciones incrustadas de una `if` instrucción pero no en el otro.</span><span class="sxs-lookup"><span data-stu-id="0ae45-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="0ae45-405">En el `if` instrucción en el método `G`, la variable `i` se asigna definitivamente en la segunda instrucción incrustada porque la ejecución de la expresión `(i = y)` siempre precede a la ejecución de esta instrucción incrustada.</span><span class="sxs-lookup"><span data-stu-id="0ae45-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="0ae45-406">En cambio, la variable `i` no se asigna definitivamente en la primera instrucción incrustada, ya que `x >= 0` podría dar como resultado true, lo que resulta en la variable `i` sin asignar.</span><span class="sxs-lookup"><span data-stu-id="0ae45-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="0ae45-407">!</span><span class="sxs-lookup"><span data-stu-id="0ae45-407">!</span></span> <span data-ttu-id="0ae45-408">expresiones (negación lógica)</span><span class="sxs-lookup"><span data-stu-id="0ae45-408">(logical negation) expressions</span></span>

<span data-ttu-id="0ae45-409">Para una expresión *expr* del formulario `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="0ae45-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="0ae45-410">El estado de asignación definitiva de *v* antes *expr_operand* es el mismo que el estado de asignación definitiva de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-411">El estado de asignación definitiva de *v* después *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="0ae45-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0ae45-412">Si el estado de *v* después \* expr_operand \* se asigna definitivamente, a continuación, el estado de *v* después *expr* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0ae45-413">Si el estado de *v* después \* expr_operand \* no es asigna definitivamente, a continuación, el estado de *v* después *expr* no se ha asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="0ae45-414">Si el estado de *v* después \* expr_operand \* es "asignado definitivamente después de una expresión false", entonces el estado de *v* después *expr* es "asignado definitivamente después true expresión".</span><span class="sxs-lookup"><span data-stu-id="0ae45-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="0ae45-415">Si el estado de *v* después \* expr_operand \* es "asignado definitivamente después de una expresión true", entonces el estado de *v* después *expr* es "asignado definitivamente después false expresión".</span><span class="sxs-lookup"><span data-stu-id="0ae45-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="0ae45-416">??</span><span class="sxs-lookup"><span data-stu-id="0ae45-416">??</span></span> <span data-ttu-id="0ae45-417">expresiones (uso combinado de null)</span><span class="sxs-lookup"><span data-stu-id="0ae45-417">(null coalescing) expressions</span></span>

<span data-ttu-id="0ae45-418">Para una expresión *expr* del formulario `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="0ae45-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="0ae45-419">El estado de asignación definitiva de *v* antes *expr_first* es el mismo que el estado de asignación definitiva de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-420">El estado de asignación definitiva de *v* antes *expr_second* es el mismo que el estado de asignación definitiva de *v* después *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="0ae45-421">La instrucción de asignación definitiva de *v* después *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="0ae45-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0ae45-422">Si *expr_first* es una expresión constante ([expresiones constantes](expressions.md#constant-expressions)) con el valor null, el el estado de *v* después *expr* es el mismo como el estado de *v* después *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="0ae45-423">En caso contrario, el estado de *v* después *expr* es el mismo que el estado de asignación definitiva de *v* después *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="0ae45-424">?: (condicionales) expresiones</span><span class="sxs-lookup"><span data-stu-id="0ae45-424">?: (conditional) expressions</span></span>

<span data-ttu-id="0ae45-425">Para una expresión *expr* del formulario `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="0ae45-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="0ae45-426">El estado de asignación definitiva de *v* antes *expr_cond* es el mismo que el estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0ae45-427">El estado de asignación definitiva de *v* antes *expr_true* se asigna definitivamente solo si uno de los siguientes contiene:</span><span class="sxs-lookup"><span data-stu-id="0ae45-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="0ae45-428">*expr_cond* es una expresión constante con el valor `false`</span><span class="sxs-lookup"><span data-stu-id="0ae45-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="0ae45-429">el estado de *v* después *expr_cond* se asigna definitivamente o "asignado definitivamente después de una expresión true".</span><span class="sxs-lookup"><span data-stu-id="0ae45-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="0ae45-430">El estado de asignación definitiva de *v* antes *expr_false* se asigna definitivamente solo si uno de los siguientes contiene:</span><span class="sxs-lookup"><span data-stu-id="0ae45-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="0ae45-431">*expr_cond* es una expresión constante con el valor `true`</span><span class="sxs-lookup"><span data-stu-id="0ae45-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="0ae45-432">el estado de *v* después *expr_cond* se asigna definitivamente o "asignado definitivamente después de una expresión false".</span><span class="sxs-lookup"><span data-stu-id="0ae45-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="0ae45-433">El estado de asignación definitiva de *v* después *expr* viene determinada por:</span><span class="sxs-lookup"><span data-stu-id="0ae45-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0ae45-434">Si *expr_cond* es una expresión constante ([expresiones constantes](expressions.md#constant-expressions)) con el valor `true` , a continuación, el estado de *v* después *expr* es el mismo que el estado de *v* después *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="0ae45-435">De lo contrario, si *expr_cond* es una expresión constante ([expresiones constantes](expressions.md#constant-expressions)) con el valor `false` , a continuación, el estado de *v* después *expr* es el mismo que el estado de *v* después *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="0ae45-436">De lo contrario, si el estado de *v* después *expr_true* se asigna definitivamente y el estado de *v* después *expr_false* definitivamente asigna, a continuación, el estado de *v* después *expr* se asigna definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0ae45-437">En caso contrario, el estado de *v* después *expr* no se ha asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="0ae45-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="0ae45-438">Funciones anónimas</span><span class="sxs-lookup"><span data-stu-id="0ae45-438">Anonymous functions</span></span>

<span data-ttu-id="0ae45-439">Para un *lambda_expression* o *anonymous_method_expression* *expr* con un cuerpo (ya sea *bloque* o *expresión* ) *cuerpo*:</span><span class="sxs-lookup"><span data-stu-id="0ae45-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="0ae45-440">El estado de asignación definitiva de una variable externa *v* antes *cuerpo* es el mismo que el estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="0ae45-441">Es decir, el estado de asignación definitiva de variables externas se hereda el contexto de la función anónima.</span><span class="sxs-lookup"><span data-stu-id="0ae45-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="0ae45-442">El estado de asignación definitiva de una variable externa *v* después *expr* es el mismo que el estado de *v* antes *expr*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="0ae45-443">El ejemplo</span><span class="sxs-lookup"><span data-stu-id="0ae45-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="0ae45-444">genera un error en tiempo de compilación desde `max` no se ha asignado definitivamente donde se declara la función anónima.</span><span class="sxs-lookup"><span data-stu-id="0ae45-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="0ae45-445">El ejemplo</span><span class="sxs-lookup"><span data-stu-id="0ae45-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="0ae45-446">También genera un error en tiempo de compilación desde la asignación a `n` en la función anónima no tiene ningún efecto sobre el estado de asignación definitiva de `n` fuera de la función anónima.</span><span class="sxs-lookup"><span data-stu-id="0ae45-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="0ae45-447">Referencias de variables</span><span class="sxs-lookup"><span data-stu-id="0ae45-447">Variable references</span></span>

<span data-ttu-id="0ae45-448">Un *variable_reference* es un *expresión* que se clasifica como una variable.</span><span class="sxs-lookup"><span data-stu-id="0ae45-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="0ae45-449">Un *variable_reference* denota una ubicación de almacenamiento que se puede acceder tanto para capturar el valor actual y para almacenar un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="0ae45-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="0ae45-450">En C y C++, un *variable_reference* se conoce como un *lvalue*.</span><span class="sxs-lookup"><span data-stu-id="0ae45-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="0ae45-451">Atomicidad de las referencias de variables</span><span class="sxs-lookup"><span data-stu-id="0ae45-451">Atomicity of variable references</span></span>

<span data-ttu-id="0ae45-452">Lecturas y escrituras de los siguientes tipos de datos son atómicas: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`y tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="0ae45-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="0ae45-453">Además, las lecturas y escrituras de los tipos de enumeración con un tipo subyacente de la lista anterior son también atómicas.</span><span class="sxs-lookup"><span data-stu-id="0ae45-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="0ae45-454">Lecturas y escrituras de otros tipos, incluidos `long`, `ulong`, `double`, y `decimal`, así como los tipos definidos por el usuario, no se garantiza que sea atómica.</span><span class="sxs-lookup"><span data-stu-id="0ae45-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="0ae45-455">Aparte de las funciones de biblioteca destinadas para dicho propósito, hay ninguna garantía de atomic lectura-modificación-escritura, como en el caso de incremento o decremento.</span><span class="sxs-lookup"><span data-stu-id="0ae45-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

